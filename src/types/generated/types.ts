export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends " $fragmentName" | "__typename" ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string };
  String: { input: string; output: string };
  Boolean: { input: boolean; output: boolean };
  Int: { input: number; output: number };
  Float: { input: number; output: number };
  bigint: { input: any; output: any };
  bytea: { input: any; output: any };
  jsonb: { input: any; output: any };
  numeric: { input: any; output: any };
  timestamp: { input: any; output: any };
};

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type BooleanComparisonExp = {
  _eq?: InputMaybe<Scalars["Boolean"]["input"]>;
  _gt?: InputMaybe<Scalars["Boolean"]["input"]>;
  _gte?: InputMaybe<Scalars["Boolean"]["input"]>;
  _in?: InputMaybe<Array<Scalars["Boolean"]["input"]>>;
  _is_null?: InputMaybe<Scalars["Boolean"]["input"]>;
  _lt?: InputMaybe<Scalars["Boolean"]["input"]>;
  _lte?: InputMaybe<Scalars["Boolean"]["input"]>;
  _neq?: InputMaybe<Scalars["Boolean"]["input"]>;
  _nin?: InputMaybe<Array<Scalars["Boolean"]["input"]>>;
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type IntComparisonExp = {
  _eq?: InputMaybe<Scalars["Int"]["input"]>;
  _gt?: InputMaybe<Scalars["Int"]["input"]>;
  _gte?: InputMaybe<Scalars["Int"]["input"]>;
  _in?: InputMaybe<Array<Scalars["Int"]["input"]>>;
  _is_null?: InputMaybe<Scalars["Boolean"]["input"]>;
  _lt?: InputMaybe<Scalars["Int"]["input"]>;
  _lte?: InputMaybe<Scalars["Int"]["input"]>;
  _neq?: InputMaybe<Scalars["Int"]["input"]>;
  _nin?: InputMaybe<Array<Scalars["Int"]["input"]>>;
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type StringComparisonExp = {
  _eq?: InputMaybe<Scalars["String"]["input"]>;
  _gt?: InputMaybe<Scalars["String"]["input"]>;
  _gte?: InputMaybe<Scalars["String"]["input"]>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars["String"]["input"]>;
  _in?: InputMaybe<Array<Scalars["String"]["input"]>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars["String"]["input"]>;
  _is_null?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars["String"]["input"]>;
  _lt?: InputMaybe<Scalars["String"]["input"]>;
  _lte?: InputMaybe<Scalars["String"]["input"]>;
  _neq?: InputMaybe<Scalars["String"]["input"]>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars["String"]["input"]>;
  _nin?: InputMaybe<Array<Scalars["String"]["input"]>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars["String"]["input"]>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars["String"]["input"]>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars["String"]["input"]>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars["String"]["input"]>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars["String"]["input"]>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars["String"]["input"]>;
};

/** columns and relationships of "account_transactions" */
export type AccountTransactions = {
  account_address: Scalars["String"]["output"];
  /** fetch data from the table: "delegated_staking_activities" */
  delegated_staking_activities: Array<DelegatedStakingActivities>;
  /** fetch aggregated fields from the table: "delegated_staking_activities" */
  delegated_staking_activities_aggregate: DelegatedStakingActivitiesAggregate;
  /** fetch data from the table: "fungible_asset_activities" */
  fungible_asset_activities: Array<FungibleAssetActivities>;
  /** fetch aggregated fields from the table: "fungible_asset_activities" */
  fungible_asset_activities_aggregate: FungibleAssetActivitiesAggregate;
  inserted_at: Scalars["timestamp"]["output"];
  /** fetch data from the table: "token_activities_v2" */
  token_activities_v2: Array<TokenActivitiesV2>;
  /** fetch aggregated fields from the table: "token_activities_v2" */
  token_activities_v2_aggregate: TokenActivitiesV2Aggregate;
  transaction_version: Scalars["bigint"]["output"];
  /** An object relationship */
  user_transaction?: Maybe<UserTransactions>;
};

/** columns and relationships of "account_transactions" */
export type AccountTransactionsDelegatedStakingActivitiesArgs = {
  distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;
  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
};

/** columns and relationships of "account_transactions" */
export type AccountTransactionsDelegatedStakingActivitiesAggregateArgs = {
  distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;
  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
};

/** columns and relationships of "account_transactions" */
export type AccountTransactionsFungibleAssetActivitiesArgs = {
  distinct_on?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<FungibleAssetActivitiesOrderBy>>;
  where?: InputMaybe<FungibleAssetActivitiesBoolExp>;
};

/** columns and relationships of "account_transactions" */
export type AccountTransactionsFungibleAssetActivitiesAggregateArgs = {
  distinct_on?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<FungibleAssetActivitiesOrderBy>>;
  where?: InputMaybe<FungibleAssetActivitiesBoolExp>;
};

/** columns and relationships of "account_transactions" */
export type AccountTransactionsTokenActivitiesV2Args = {
  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;
  where?: InputMaybe<TokenActivitiesV2BoolExp>;
};

/** columns and relationships of "account_transactions" */
export type AccountTransactionsTokenActivitiesV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;
  where?: InputMaybe<TokenActivitiesV2BoolExp>;
};

/** aggregated selection of "account_transactions" */
export type AccountTransactionsAggregate = {
  aggregate?: Maybe<AccountTransactionsAggregateFields>;
  nodes: Array<AccountTransactions>;
};

/** aggregate fields of "account_transactions" */
export type AccountTransactionsAggregateFields = {
  avg?: Maybe<AccountTransactionsAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<AccountTransactionsMaxFields>;
  min?: Maybe<AccountTransactionsMinFields>;
  stddev?: Maybe<AccountTransactionsStddevFields>;
  stddev_pop?: Maybe<AccountTransactionsStddevPopFields>;
  stddev_samp?: Maybe<AccountTransactionsStddevSampFields>;
  sum?: Maybe<AccountTransactionsSumFields>;
  var_pop?: Maybe<AccountTransactionsVarPopFields>;
  var_samp?: Maybe<AccountTransactionsVarSampFields>;
  variance?: Maybe<AccountTransactionsVarianceFields>;
};

/** aggregate fields of "account_transactions" */
export type AccountTransactionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AccountTransactionsSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type AccountTransactionsAvgFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "account_transactions". All fields are combined with a logical 'AND'. */
export type AccountTransactionsBoolExp = {
  _and?: InputMaybe<Array<AccountTransactionsBoolExp>>;
  _not?: InputMaybe<AccountTransactionsBoolExp>;
  _or?: InputMaybe<Array<AccountTransactionsBoolExp>>;
  account_address?: InputMaybe<StringComparisonExp>;
  delegated_staking_activities?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
  delegated_staking_activities_aggregate?: InputMaybe<DelegatedStakingActivitiesAggregateBoolExp>;
  fungible_asset_activities?: InputMaybe<FungibleAssetActivitiesBoolExp>;
  fungible_asset_activities_aggregate?: InputMaybe<FungibleAssetActivitiesAggregateBoolExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  token_activities_v2?: InputMaybe<TokenActivitiesV2BoolExp>;
  token_activities_v2_aggregate?: InputMaybe<TokenActivitiesV2AggregateBoolExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  user_transaction?: InputMaybe<UserTransactionsBoolExp>;
};

/** unique or primary key constraints on table "account_transactions" */
export enum AccountTransactionsConstraint {
  /** unique or primary key constraint on columns "account_address", "transaction_version" */
  AccountTransactionsPkey = "account_transactions_pkey",
}

/** input type for incrementing numeric columns in table "account_transactions" */
export type AccountTransactionsIncInput = {
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "account_transactions" */
export type AccountTransactionsInsertInput = {
  account_address?: InputMaybe<Scalars["String"]["input"]>;
  delegated_staking_activities?: InputMaybe<DelegatedStakingActivitiesArrRelInsertInput>;
  fungible_asset_activities?: InputMaybe<FungibleAssetActivitiesArrRelInsertInput>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  token_activities_v2?: InputMaybe<TokenActivitiesV2ArrRelInsertInput>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  user_transaction?: InputMaybe<UserTransactionsObjRelInsertInput>;
};

/** aggregate max on columns */
export type AccountTransactionsMaxFields = {
  account_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type AccountTransactionsMinFields = {
  account_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "account_transactions" */
export type AccountTransactionsMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<AccountTransactions>;
};

/** on_conflict condition type for table "account_transactions" */
export type AccountTransactionsOnConflict = {
  constraint: AccountTransactionsConstraint;
  update_columns?: Array<AccountTransactionsUpdateColumn>;
  where?: InputMaybe<AccountTransactionsBoolExp>;
};

/** Ordering options when selecting data from "account_transactions". */
export type AccountTransactionsOrderBy = {
  account_address?: InputMaybe<OrderBy>;
  delegated_staking_activities_aggregate?: InputMaybe<DelegatedStakingActivitiesAggregateOrderBy>;
  fungible_asset_activities_aggregate?: InputMaybe<FungibleAssetActivitiesAggregateOrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  token_activities_v2_aggregate?: InputMaybe<TokenActivitiesV2AggregateOrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  user_transaction?: InputMaybe<UserTransactionsOrderBy>;
};

/** primary key columns input for table: account_transactions */
export type AccountTransactionsPkColumnsInput = {
  account_address: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** select columns of table "account_transactions" */
export enum AccountTransactionsSelectColumn {
  /** column name */
  AccountAddress = "account_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  TransactionVersion = "transaction_version",
}

/** input type for updating data in table "account_transactions" */
export type AccountTransactionsSetInput = {
  account_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type AccountTransactionsStddevFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type AccountTransactionsStddevPopFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type AccountTransactionsStddevSampFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "account_transactions" */
export type AccountTransactionsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: AccountTransactionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AccountTransactionsStreamCursorValueInput = {
  account_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type AccountTransactionsSumFields = {
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "account_transactions" */
export enum AccountTransactionsUpdateColumn {
  /** column name */
  AccountAddress = "account_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  TransactionVersion = "transaction_version",
}

export type AccountTransactionsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<AccountTransactionsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AccountTransactionsSetInput>;
  /** filter the rows which have to be updated */
  where: AccountTransactionsBoolExp;
};

/** aggregate var_pop on columns */
export type AccountTransactionsVarPopFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type AccountTransactionsVarSampFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type AccountTransactionsVarianceFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "address_events_summary" */
export type AddressEventsSummary = {
  account_address?: Maybe<Scalars["String"]["output"]>;
  /** An object relationship */
  block_metadata?: Maybe<BlockMetadataTransactions>;
  min_block_height?: Maybe<Scalars["bigint"]["output"]>;
  num_distinct_versions?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregated selection of "address_events_summary" */
export type AddressEventsSummaryAggregate = {
  aggregate?: Maybe<AddressEventsSummaryAggregateFields>;
  nodes: Array<AddressEventsSummary>;
};

/** aggregate fields of "address_events_summary" */
export type AddressEventsSummaryAggregateFields = {
  avg?: Maybe<AddressEventsSummaryAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<AddressEventsSummaryMaxFields>;
  min?: Maybe<AddressEventsSummaryMinFields>;
  stddev?: Maybe<AddressEventsSummaryStddevFields>;
  stddev_pop?: Maybe<AddressEventsSummaryStddevPopFields>;
  stddev_samp?: Maybe<AddressEventsSummaryStddevSampFields>;
  sum?: Maybe<AddressEventsSummarySumFields>;
  var_pop?: Maybe<AddressEventsSummaryVarPopFields>;
  var_samp?: Maybe<AddressEventsSummaryVarSampFields>;
  variance?: Maybe<AddressEventsSummaryVarianceFields>;
};

/** aggregate fields of "address_events_summary" */
export type AddressEventsSummaryAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AddressEventsSummarySelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type AddressEventsSummaryAvgFields = {
  min_block_height?: Maybe<Scalars["Float"]["output"]>;
  num_distinct_versions?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "address_events_summary". All fields are combined with a logical 'AND'. */
export type AddressEventsSummaryBoolExp = {
  _and?: InputMaybe<Array<AddressEventsSummaryBoolExp>>;
  _not?: InputMaybe<AddressEventsSummaryBoolExp>;
  _or?: InputMaybe<Array<AddressEventsSummaryBoolExp>>;
  account_address?: InputMaybe<StringComparisonExp>;
  block_metadata?: InputMaybe<BlockMetadataTransactionsBoolExp>;
  min_block_height?: InputMaybe<BigintComparisonExp>;
  num_distinct_versions?: InputMaybe<BigintComparisonExp>;
};

/** aggregate max on columns */
export type AddressEventsSummaryMaxFields = {
  account_address?: Maybe<Scalars["String"]["output"]>;
  min_block_height?: Maybe<Scalars["bigint"]["output"]>;
  num_distinct_versions?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type AddressEventsSummaryMinFields = {
  account_address?: Maybe<Scalars["String"]["output"]>;
  min_block_height?: Maybe<Scalars["bigint"]["output"]>;
  num_distinct_versions?: Maybe<Scalars["bigint"]["output"]>;
};

/** Ordering options when selecting data from "address_events_summary". */
export type AddressEventsSummaryOrderBy = {
  account_address?: InputMaybe<OrderBy>;
  block_metadata?: InputMaybe<BlockMetadataTransactionsOrderBy>;
  min_block_height?: InputMaybe<OrderBy>;
  num_distinct_versions?: InputMaybe<OrderBy>;
};

/** select columns of table "address_events_summary" */
export enum AddressEventsSummarySelectColumn {
  /** column name */
  AccountAddress = "account_address",
  /** column name */
  MinBlockHeight = "min_block_height",
  /** column name */
  NumDistinctVersions = "num_distinct_versions",
}

/** aggregate stddev on columns */
export type AddressEventsSummaryStddevFields = {
  min_block_height?: Maybe<Scalars["Float"]["output"]>;
  num_distinct_versions?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type AddressEventsSummaryStddevPopFields = {
  min_block_height?: Maybe<Scalars["Float"]["output"]>;
  num_distinct_versions?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type AddressEventsSummaryStddevSampFields = {
  min_block_height?: Maybe<Scalars["Float"]["output"]>;
  num_distinct_versions?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "address_events_summary" */
export type AddressEventsSummaryStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: AddressEventsSummaryStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AddressEventsSummaryStreamCursorValueInput = {
  account_address?: InputMaybe<Scalars["String"]["input"]>;
  min_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  num_distinct_versions?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type AddressEventsSummarySumFields = {
  min_block_height?: Maybe<Scalars["bigint"]["output"]>;
  num_distinct_versions?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate var_pop on columns */
export type AddressEventsSummaryVarPopFields = {
  min_block_height?: Maybe<Scalars["Float"]["output"]>;
  num_distinct_versions?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type AddressEventsSummaryVarSampFields = {
  min_block_height?: Maybe<Scalars["Float"]["output"]>;
  num_distinct_versions?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type AddressEventsSummaryVarianceFields = {
  min_block_height?: Maybe<Scalars["Float"]["output"]>;
  num_distinct_versions?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "address_version_from_events" */
export type AddressVersionFromEvents = {
  account_address?: Maybe<Scalars["String"]["output"]>;
  /** fetch data from the table: "delegated_staking_activities" */
  delegated_staking_activities: Array<DelegatedStakingActivities>;
  /** fetch aggregated fields from the table: "delegated_staking_activities" */
  delegated_staking_activities_aggregate: DelegatedStakingActivitiesAggregate;
  /** fetch data from the table: "token_activities_v2" */
  token_activities_v2: Array<TokenActivitiesV2>;
  /** fetch aggregated fields from the table: "token_activities_v2" */
  token_activities_v2_aggregate: TokenActivitiesV2Aggregate;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** columns and relationships of "address_version_from_events" */
export type AddressVersionFromEventsDelegatedStakingActivitiesArgs = {
  distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;
  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
};

/** columns and relationships of "address_version_from_events" */
export type AddressVersionFromEventsDelegatedStakingActivitiesAggregateArgs = {
  distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;
  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
};

/** columns and relationships of "address_version_from_events" */
export type AddressVersionFromEventsTokenActivitiesV2Args = {
  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;
  where?: InputMaybe<TokenActivitiesV2BoolExp>;
};

/** columns and relationships of "address_version_from_events" */
export type AddressVersionFromEventsTokenActivitiesV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;
  where?: InputMaybe<TokenActivitiesV2BoolExp>;
};

/** aggregated selection of "address_version_from_events" */
export type AddressVersionFromEventsAggregate = {
  aggregate?: Maybe<AddressVersionFromEventsAggregateFields>;
  nodes: Array<AddressVersionFromEvents>;
};

/** aggregate fields of "address_version_from_events" */
export type AddressVersionFromEventsAggregateFields = {
  avg?: Maybe<AddressVersionFromEventsAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<AddressVersionFromEventsMaxFields>;
  min?: Maybe<AddressVersionFromEventsMinFields>;
  stddev?: Maybe<AddressVersionFromEventsStddevFields>;
  stddev_pop?: Maybe<AddressVersionFromEventsStddevPopFields>;
  stddev_samp?: Maybe<AddressVersionFromEventsStddevSampFields>;
  sum?: Maybe<AddressVersionFromEventsSumFields>;
  var_pop?: Maybe<AddressVersionFromEventsVarPopFields>;
  var_samp?: Maybe<AddressVersionFromEventsVarSampFields>;
  variance?: Maybe<AddressVersionFromEventsVarianceFields>;
};

/** aggregate fields of "address_version_from_events" */
export type AddressVersionFromEventsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AddressVersionFromEventsSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type AddressVersionFromEventsAvgFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "address_version_from_events". All fields are combined with a logical 'AND'. */
export type AddressVersionFromEventsBoolExp = {
  _and?: InputMaybe<Array<AddressVersionFromEventsBoolExp>>;
  _not?: InputMaybe<AddressVersionFromEventsBoolExp>;
  _or?: InputMaybe<Array<AddressVersionFromEventsBoolExp>>;
  account_address?: InputMaybe<StringComparisonExp>;
  delegated_staking_activities?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
  delegated_staking_activities_aggregate?: InputMaybe<DelegatedStakingActivitiesAggregateBoolExp>;
  token_activities_v2?: InputMaybe<TokenActivitiesV2BoolExp>;
  token_activities_v2_aggregate?: InputMaybe<TokenActivitiesV2AggregateBoolExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
};

/** aggregate max on columns */
export type AddressVersionFromEventsMaxFields = {
  account_address?: Maybe<Scalars["String"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type AddressVersionFromEventsMinFields = {
  account_address?: Maybe<Scalars["String"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** Ordering options when selecting data from "address_version_from_events". */
export type AddressVersionFromEventsOrderBy = {
  account_address?: InputMaybe<OrderBy>;
  delegated_staking_activities_aggregate?: InputMaybe<DelegatedStakingActivitiesAggregateOrderBy>;
  token_activities_v2_aggregate?: InputMaybe<TokenActivitiesV2AggregateOrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** select columns of table "address_version_from_events" */
export enum AddressVersionFromEventsSelectColumn {
  /** column name */
  AccountAddress = "account_address",
  /** column name */
  TransactionVersion = "transaction_version",
}

/** aggregate stddev on columns */
export type AddressVersionFromEventsStddevFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type AddressVersionFromEventsStddevPopFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type AddressVersionFromEventsStddevSampFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "address_version_from_events" */
export type AddressVersionFromEventsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: AddressVersionFromEventsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AddressVersionFromEventsStreamCursorValueInput = {
  account_address?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type AddressVersionFromEventsSumFields = {
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate var_pop on columns */
export type AddressVersionFromEventsVarPopFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type AddressVersionFromEventsVarSampFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type AddressVersionFromEventsVarianceFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "address_version_from_move_resources" */
export type AddressVersionFromMoveResources = {
  address?: Maybe<Scalars["String"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregated selection of "address_version_from_move_resources" */
export type AddressVersionFromMoveResourcesAggregate = {
  aggregate?: Maybe<AddressVersionFromMoveResourcesAggregateFields>;
  nodes: Array<AddressVersionFromMoveResources>;
};

/** aggregate fields of "address_version_from_move_resources" */
export type AddressVersionFromMoveResourcesAggregateFields = {
  avg?: Maybe<AddressVersionFromMoveResourcesAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<AddressVersionFromMoveResourcesMaxFields>;
  min?: Maybe<AddressVersionFromMoveResourcesMinFields>;
  stddev?: Maybe<AddressVersionFromMoveResourcesStddevFields>;
  stddev_pop?: Maybe<AddressVersionFromMoveResourcesStddevPopFields>;
  stddev_samp?: Maybe<AddressVersionFromMoveResourcesStddevSampFields>;
  sum?: Maybe<AddressVersionFromMoveResourcesSumFields>;
  var_pop?: Maybe<AddressVersionFromMoveResourcesVarPopFields>;
  var_samp?: Maybe<AddressVersionFromMoveResourcesVarSampFields>;
  variance?: Maybe<AddressVersionFromMoveResourcesVarianceFields>;
};

/** aggregate fields of "address_version_from_move_resources" */
export type AddressVersionFromMoveResourcesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AddressVersionFromMoveResourcesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type AddressVersionFromMoveResourcesAvgFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "address_version_from_move_resources". All fields are combined with a logical 'AND'. */
export type AddressVersionFromMoveResourcesBoolExp = {
  _and?: InputMaybe<Array<AddressVersionFromMoveResourcesBoolExp>>;
  _not?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;
  _or?: InputMaybe<Array<AddressVersionFromMoveResourcesBoolExp>>;
  address?: InputMaybe<StringComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
};

/** aggregate max on columns */
export type AddressVersionFromMoveResourcesMaxFields = {
  address?: Maybe<Scalars["String"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type AddressVersionFromMoveResourcesMinFields = {
  address?: Maybe<Scalars["String"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** Ordering options when selecting data from "address_version_from_move_resources". */
export type AddressVersionFromMoveResourcesOrderBy = {
  address?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** select columns of table "address_version_from_move_resources" */
export enum AddressVersionFromMoveResourcesSelectColumn {
  /** column name */
  Address = "address",
  /** column name */
  TransactionVersion = "transaction_version",
}

/** aggregate stddev on columns */
export type AddressVersionFromMoveResourcesStddevFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type AddressVersionFromMoveResourcesStddevPopFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type AddressVersionFromMoveResourcesStddevSampFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "address_version_from_move_resources" */
export type AddressVersionFromMoveResourcesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: AddressVersionFromMoveResourcesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AddressVersionFromMoveResourcesStreamCursorValueInput = {
  address?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type AddressVersionFromMoveResourcesSumFields = {
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate var_pop on columns */
export type AddressVersionFromMoveResourcesVarPopFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type AddressVersionFromMoveResourcesVarSampFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type AddressVersionFromMoveResourcesVarianceFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "ans_lookup" */
export type AnsLookup = {
  domain: Scalars["String"]["output"];
  expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  inserted_at: Scalars["timestamp"]["output"];
  is_deleted: Scalars["Boolean"]["output"];
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain: Scalars["String"]["output"];
  token_name: Scalars["String"]["output"];
  transaction_version: Scalars["bigint"]["output"];
  write_set_change_index: Scalars["bigint"]["output"];
};

/** aggregated selection of "ans_lookup" */
export type AnsLookupAggregate = {
  aggregate?: Maybe<AnsLookupAggregateFields>;
  nodes: Array<AnsLookup>;
};

/** aggregate fields of "ans_lookup" */
export type AnsLookupAggregateFields = {
  avg?: Maybe<AnsLookupAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<AnsLookupMaxFields>;
  min?: Maybe<AnsLookupMinFields>;
  stddev?: Maybe<AnsLookupStddevFields>;
  stddev_pop?: Maybe<AnsLookupStddevPopFields>;
  stddev_samp?: Maybe<AnsLookupStddevSampFields>;
  sum?: Maybe<AnsLookupSumFields>;
  var_pop?: Maybe<AnsLookupVarPopFields>;
  var_samp?: Maybe<AnsLookupVarSampFields>;
  variance?: Maybe<AnsLookupVarianceFields>;
};

/** aggregate fields of "ans_lookup" */
export type AnsLookupAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AnsLookupSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type AnsLookupAvgFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "ans_lookup". All fields are combined with a logical 'AND'. */
export type AnsLookupBoolExp = {
  _and?: InputMaybe<Array<AnsLookupBoolExp>>;
  _not?: InputMaybe<AnsLookupBoolExp>;
  _or?: InputMaybe<Array<AnsLookupBoolExp>>;
  domain?: InputMaybe<StringComparisonExp>;
  expiration_timestamp?: InputMaybe<TimestampComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_deleted?: InputMaybe<BooleanComparisonExp>;
  registered_address?: InputMaybe<StringComparisonExp>;
  subdomain?: InputMaybe<StringComparisonExp>;
  token_name?: InputMaybe<StringComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  write_set_change_index?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "ans_lookup" */
export enum AnsLookupConstraint {
  /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
  AnsLookupPkey = "ans_lookup_pkey",
}

/** input type for incrementing numeric columns in table "ans_lookup" */
export type AnsLookupIncInput = {
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "ans_lookup" */
export type AnsLookupInsertInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type AnsLookupMaxFields = {
  domain?: Maybe<Scalars["String"]["output"]>;
  expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type AnsLookupMinFields = {
  domain?: Maybe<Scalars["String"]["output"]>;
  expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "ans_lookup" */
export type AnsLookupMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<AnsLookup>;
};

/** on_conflict condition type for table "ans_lookup" */
export type AnsLookupOnConflict = {
  constraint: AnsLookupConstraint;
  update_columns?: Array<AnsLookupUpdateColumn>;
  where?: InputMaybe<AnsLookupBoolExp>;
};

/** Ordering options when selecting data from "ans_lookup". */
export type AnsLookupOrderBy = {
  domain?: InputMaybe<OrderBy>;
  expiration_timestamp?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_deleted?: InputMaybe<OrderBy>;
  registered_address?: InputMaybe<OrderBy>;
  subdomain?: InputMaybe<OrderBy>;
  token_name?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  write_set_change_index?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: ans_lookup */
export type AnsLookupPkColumnsInput = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** select columns of table "ans_lookup" */
export enum AnsLookupSelectColumn {
  /** column name */
  Domain = "domain",
  /** column name */
  ExpirationTimestamp = "expiration_timestamp",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  RegisteredAddress = "registered_address",
  /** column name */
  Subdomain = "subdomain",
  /** column name */
  TokenName = "token_name",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

/** input type for updating data in table "ans_lookup" */
export type AnsLookupSetInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type AnsLookupStddevFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type AnsLookupStddevPopFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type AnsLookupStddevSampFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "ans_lookup" */
export type AnsLookupStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: AnsLookupStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AnsLookupStreamCursorValueInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type AnsLookupSumFields = {
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "ans_lookup" */
export enum AnsLookupUpdateColumn {
  /** column name */
  Domain = "domain",
  /** column name */
  ExpirationTimestamp = "expiration_timestamp",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  RegisteredAddress = "registered_address",
  /** column name */
  Subdomain = "subdomain",
  /** column name */
  TokenName = "token_name",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

export type AnsLookupUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<AnsLookupIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AnsLookupSetInput>;
  /** filter the rows which have to be updated */
  where: AnsLookupBoolExp;
};

/** columns and relationships of "ans_lookup_v2" */
export type AnsLookupV2 = {
  domain: Scalars["String"]["output"];
  expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  inserted_at: Scalars["timestamp"]["output"];
  is_deleted: Scalars["Boolean"]["output"];
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain: Scalars["String"]["output"];
  subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
  token_name: Scalars["String"]["output"];
  token_standard: Scalars["String"]["output"];
  transaction_version: Scalars["bigint"]["output"];
  write_set_change_index: Scalars["bigint"]["output"];
};

/** aggregated selection of "ans_lookup_v2" */
export type AnsLookupV2Aggregate = {
  aggregate?: Maybe<AnsLookupV2AggregateFields>;
  nodes: Array<AnsLookupV2>;
};

/** aggregate fields of "ans_lookup_v2" */
export type AnsLookupV2AggregateFields = {
  avg?: Maybe<AnsLookupV2AvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<AnsLookupV2MaxFields>;
  min?: Maybe<AnsLookupV2MinFields>;
  stddev?: Maybe<AnsLookupV2StddevFields>;
  stddev_pop?: Maybe<AnsLookupV2StddevPopFields>;
  stddev_samp?: Maybe<AnsLookupV2StddevSampFields>;
  sum?: Maybe<AnsLookupV2SumFields>;
  var_pop?: Maybe<AnsLookupV2VarPopFields>;
  var_samp?: Maybe<AnsLookupV2VarSampFields>;
  variance?: Maybe<AnsLookupV2VarianceFields>;
};

/** aggregate fields of "ans_lookup_v2" */
export type AnsLookupV2AggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AnsLookupV2SelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type AnsLookupV2AvgFields = {
  subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "ans_lookup_v2". All fields are combined with a logical 'AND'. */
export type AnsLookupV2BoolExp = {
  _and?: InputMaybe<Array<AnsLookupV2BoolExp>>;
  _not?: InputMaybe<AnsLookupV2BoolExp>;
  _or?: InputMaybe<Array<AnsLookupV2BoolExp>>;
  domain?: InputMaybe<StringComparisonExp>;
  expiration_timestamp?: InputMaybe<TimestampComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_deleted?: InputMaybe<BooleanComparisonExp>;
  registered_address?: InputMaybe<StringComparisonExp>;
  subdomain?: InputMaybe<StringComparisonExp>;
  subdomain_expiration_policy?: InputMaybe<BigintComparisonExp>;
  token_name?: InputMaybe<StringComparisonExp>;
  token_standard?: InputMaybe<StringComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  write_set_change_index?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "ans_lookup_v2" */
export enum AnsLookupV2Constraint {
  /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
  AnsLookupV2Pkey = "ans_lookup_v2_pkey",
}

/** input type for incrementing numeric columns in table "ans_lookup_v2" */
export type AnsLookupV2IncInput = {
  subdomain_expiration_policy?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "ans_lookup_v2" */
export type AnsLookupV2InsertInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  subdomain_expiration_policy?: InputMaybe<Scalars["bigint"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type AnsLookupV2MaxFields = {
  domain?: Maybe<Scalars["String"]["output"]>;
  expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain?: Maybe<Scalars["String"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type AnsLookupV2MinFields = {
  domain?: Maybe<Scalars["String"]["output"]>;
  expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain?: Maybe<Scalars["String"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "ans_lookup_v2" */
export type AnsLookupV2MutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<AnsLookupV2>;
};

/** on_conflict condition type for table "ans_lookup_v2" */
export type AnsLookupV2OnConflict = {
  constraint: AnsLookupV2Constraint;
  update_columns?: Array<AnsLookupV2UpdateColumn>;
  where?: InputMaybe<AnsLookupV2BoolExp>;
};

/** Ordering options when selecting data from "ans_lookup_v2". */
export type AnsLookupV2OrderBy = {
  domain?: InputMaybe<OrderBy>;
  expiration_timestamp?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_deleted?: InputMaybe<OrderBy>;
  registered_address?: InputMaybe<OrderBy>;
  subdomain?: InputMaybe<OrderBy>;
  subdomain_expiration_policy?: InputMaybe<OrderBy>;
  token_name?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  write_set_change_index?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: ans_lookup_v2 */
export type AnsLookupV2PkColumnsInput = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** select columns of table "ans_lookup_v2" */
export enum AnsLookupV2SelectColumn {
  /** column name */
  Domain = "domain",
  /** column name */
  ExpirationTimestamp = "expiration_timestamp",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  RegisteredAddress = "registered_address",
  /** column name */
  Subdomain = "subdomain",
  /** column name */
  SubdomainExpirationPolicy = "subdomain_expiration_policy",
  /** column name */
  TokenName = "token_name",
  /** column name */
  TokenStandard = "token_standard",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

/** input type for updating data in table "ans_lookup_v2" */
export type AnsLookupV2SetInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  subdomain_expiration_policy?: InputMaybe<Scalars["bigint"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type AnsLookupV2StddevFields = {
  subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type AnsLookupV2StddevPopFields = {
  subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type AnsLookupV2StddevSampFields = {
  subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "ans_lookup_v2" */
export type AnsLookupV2StreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: AnsLookupV2StreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AnsLookupV2StreamCursorValueInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  subdomain_expiration_policy?: InputMaybe<Scalars["bigint"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type AnsLookupV2SumFields = {
  subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "ans_lookup_v2" */
export enum AnsLookupV2UpdateColumn {
  /** column name */
  Domain = "domain",
  /** column name */
  ExpirationTimestamp = "expiration_timestamp",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  RegisteredAddress = "registered_address",
  /** column name */
  Subdomain = "subdomain",
  /** column name */
  SubdomainExpirationPolicy = "subdomain_expiration_policy",
  /** column name */
  TokenName = "token_name",
  /** column name */
  TokenStandard = "token_standard",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

export type AnsLookupV2Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<AnsLookupV2IncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AnsLookupV2SetInput>;
  /** filter the rows which have to be updated */
  where: AnsLookupV2BoolExp;
};

/** aggregate var_pop on columns */
export type AnsLookupV2VarPopFields = {
  subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type AnsLookupV2VarSampFields = {
  subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type AnsLookupV2VarianceFields = {
  subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_pop on columns */
export type AnsLookupVarPopFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type AnsLookupVarSampFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type AnsLookupVarianceFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "ans_primary_name" */
export type AnsPrimaryName = {
  domain?: Maybe<Scalars["String"]["output"]>;
  inserted_at: Scalars["timestamp"]["output"];
  is_deleted: Scalars["Boolean"]["output"];
  registered_address: Scalars["String"]["output"];
  subdomain?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  transaction_version: Scalars["bigint"]["output"];
  write_set_change_index: Scalars["bigint"]["output"];
};

/** aggregated selection of "ans_primary_name" */
export type AnsPrimaryNameAggregate = {
  aggregate?: Maybe<AnsPrimaryNameAggregateFields>;
  nodes: Array<AnsPrimaryName>;
};

/** aggregate fields of "ans_primary_name" */
export type AnsPrimaryNameAggregateFields = {
  avg?: Maybe<AnsPrimaryNameAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<AnsPrimaryNameMaxFields>;
  min?: Maybe<AnsPrimaryNameMinFields>;
  stddev?: Maybe<AnsPrimaryNameStddevFields>;
  stddev_pop?: Maybe<AnsPrimaryNameStddevPopFields>;
  stddev_samp?: Maybe<AnsPrimaryNameStddevSampFields>;
  sum?: Maybe<AnsPrimaryNameSumFields>;
  var_pop?: Maybe<AnsPrimaryNameVarPopFields>;
  var_samp?: Maybe<AnsPrimaryNameVarSampFields>;
  variance?: Maybe<AnsPrimaryNameVarianceFields>;
};

/** aggregate fields of "ans_primary_name" */
export type AnsPrimaryNameAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AnsPrimaryNameSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type AnsPrimaryNameAvgFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "ans_primary_name". All fields are combined with a logical 'AND'. */
export type AnsPrimaryNameBoolExp = {
  _and?: InputMaybe<Array<AnsPrimaryNameBoolExp>>;
  _not?: InputMaybe<AnsPrimaryNameBoolExp>;
  _or?: InputMaybe<Array<AnsPrimaryNameBoolExp>>;
  domain?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_deleted?: InputMaybe<BooleanComparisonExp>;
  registered_address?: InputMaybe<StringComparisonExp>;
  subdomain?: InputMaybe<StringComparisonExp>;
  token_name?: InputMaybe<StringComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  write_set_change_index?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "ans_primary_name" */
export enum AnsPrimaryNameConstraint {
  /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
  AnsPrimaryNamePkey = "ans_primary_name_pkey",
}

/** input type for incrementing numeric columns in table "ans_primary_name" */
export type AnsPrimaryNameIncInput = {
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "ans_primary_name" */
export type AnsPrimaryNameInsertInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type AnsPrimaryNameMaxFields = {
  domain?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type AnsPrimaryNameMinFields = {
  domain?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "ans_primary_name" */
export type AnsPrimaryNameMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<AnsPrimaryName>;
};

/** on_conflict condition type for table "ans_primary_name" */
export type AnsPrimaryNameOnConflict = {
  constraint: AnsPrimaryNameConstraint;
  update_columns?: Array<AnsPrimaryNameUpdateColumn>;
  where?: InputMaybe<AnsPrimaryNameBoolExp>;
};

/** Ordering options when selecting data from "ans_primary_name". */
export type AnsPrimaryNameOrderBy = {
  domain?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_deleted?: InputMaybe<OrderBy>;
  registered_address?: InputMaybe<OrderBy>;
  subdomain?: InputMaybe<OrderBy>;
  token_name?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  write_set_change_index?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: ans_primary_name */
export type AnsPrimaryNamePkColumnsInput = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** select columns of table "ans_primary_name" */
export enum AnsPrimaryNameSelectColumn {
  /** column name */
  Domain = "domain",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  RegisteredAddress = "registered_address",
  /** column name */
  Subdomain = "subdomain",
  /** column name */
  TokenName = "token_name",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

/** input type for updating data in table "ans_primary_name" */
export type AnsPrimaryNameSetInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type AnsPrimaryNameStddevFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type AnsPrimaryNameStddevPopFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type AnsPrimaryNameStddevSampFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "ans_primary_name" */
export type AnsPrimaryNameStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: AnsPrimaryNameStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AnsPrimaryNameStreamCursorValueInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type AnsPrimaryNameSumFields = {
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "ans_primary_name" */
export enum AnsPrimaryNameUpdateColumn {
  /** column name */
  Domain = "domain",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  RegisteredAddress = "registered_address",
  /** column name */
  Subdomain = "subdomain",
  /** column name */
  TokenName = "token_name",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

export type AnsPrimaryNameUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<AnsPrimaryNameIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AnsPrimaryNameSetInput>;
  /** filter the rows which have to be updated */
  where: AnsPrimaryNameBoolExp;
};

/** columns and relationships of "ans_primary_name_v2" */
export type AnsPrimaryNameV2 = {
  domain?: Maybe<Scalars["String"]["output"]>;
  inserted_at: Scalars["timestamp"]["output"];
  is_deleted: Scalars["Boolean"]["output"];
  registered_address: Scalars["String"]["output"];
  subdomain?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  token_standard: Scalars["String"]["output"];
  transaction_version: Scalars["bigint"]["output"];
  write_set_change_index: Scalars["bigint"]["output"];
};

/** aggregated selection of "ans_primary_name_v2" */
export type AnsPrimaryNameV2Aggregate = {
  aggregate?: Maybe<AnsPrimaryNameV2AggregateFields>;
  nodes: Array<AnsPrimaryNameV2>;
};

/** aggregate fields of "ans_primary_name_v2" */
export type AnsPrimaryNameV2AggregateFields = {
  avg?: Maybe<AnsPrimaryNameV2AvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<AnsPrimaryNameV2MaxFields>;
  min?: Maybe<AnsPrimaryNameV2MinFields>;
  stddev?: Maybe<AnsPrimaryNameV2StddevFields>;
  stddev_pop?: Maybe<AnsPrimaryNameV2StddevPopFields>;
  stddev_samp?: Maybe<AnsPrimaryNameV2StddevSampFields>;
  sum?: Maybe<AnsPrimaryNameV2SumFields>;
  var_pop?: Maybe<AnsPrimaryNameV2VarPopFields>;
  var_samp?: Maybe<AnsPrimaryNameV2VarSampFields>;
  variance?: Maybe<AnsPrimaryNameV2VarianceFields>;
};

/** aggregate fields of "ans_primary_name_v2" */
export type AnsPrimaryNameV2AggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AnsPrimaryNameV2SelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type AnsPrimaryNameV2AvgFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "ans_primary_name_v2". All fields are combined with a logical 'AND'. */
export type AnsPrimaryNameV2BoolExp = {
  _and?: InputMaybe<Array<AnsPrimaryNameV2BoolExp>>;
  _not?: InputMaybe<AnsPrimaryNameV2BoolExp>;
  _or?: InputMaybe<Array<AnsPrimaryNameV2BoolExp>>;
  domain?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_deleted?: InputMaybe<BooleanComparisonExp>;
  registered_address?: InputMaybe<StringComparisonExp>;
  subdomain?: InputMaybe<StringComparisonExp>;
  token_name?: InputMaybe<StringComparisonExp>;
  token_standard?: InputMaybe<StringComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  write_set_change_index?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "ans_primary_name_v2" */
export enum AnsPrimaryNameV2Constraint {
  /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
  AnsPrimaryNameV2Pkey = "ans_primary_name_v2_pkey",
}

/** input type for incrementing numeric columns in table "ans_primary_name_v2" */
export type AnsPrimaryNameV2IncInput = {
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "ans_primary_name_v2" */
export type AnsPrimaryNameV2InsertInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type AnsPrimaryNameV2MaxFields = {
  domain?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type AnsPrimaryNameV2MinFields = {
  domain?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "ans_primary_name_v2" */
export type AnsPrimaryNameV2MutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<AnsPrimaryNameV2>;
};

/** on_conflict condition type for table "ans_primary_name_v2" */
export type AnsPrimaryNameV2OnConflict = {
  constraint: AnsPrimaryNameV2Constraint;
  update_columns?: Array<AnsPrimaryNameV2UpdateColumn>;
  where?: InputMaybe<AnsPrimaryNameV2BoolExp>;
};

/** Ordering options when selecting data from "ans_primary_name_v2". */
export type AnsPrimaryNameV2OrderBy = {
  domain?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_deleted?: InputMaybe<OrderBy>;
  registered_address?: InputMaybe<OrderBy>;
  subdomain?: InputMaybe<OrderBy>;
  token_name?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  write_set_change_index?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: ans_primary_name_v2 */
export type AnsPrimaryNameV2PkColumnsInput = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** select columns of table "ans_primary_name_v2" */
export enum AnsPrimaryNameV2SelectColumn {
  /** column name */
  Domain = "domain",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  RegisteredAddress = "registered_address",
  /** column name */
  Subdomain = "subdomain",
  /** column name */
  TokenName = "token_name",
  /** column name */
  TokenStandard = "token_standard",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

/** input type for updating data in table "ans_primary_name_v2" */
export type AnsPrimaryNameV2SetInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type AnsPrimaryNameV2StddevFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type AnsPrimaryNameV2StddevPopFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type AnsPrimaryNameV2StddevSampFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "ans_primary_name_v2" */
export type AnsPrimaryNameV2StreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: AnsPrimaryNameV2StreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AnsPrimaryNameV2StreamCursorValueInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type AnsPrimaryNameV2SumFields = {
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "ans_primary_name_v2" */
export enum AnsPrimaryNameV2UpdateColumn {
  /** column name */
  Domain = "domain",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  RegisteredAddress = "registered_address",
  /** column name */
  Subdomain = "subdomain",
  /** column name */
  TokenName = "token_name",
  /** column name */
  TokenStandard = "token_standard",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

export type AnsPrimaryNameV2Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<AnsPrimaryNameV2IncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AnsPrimaryNameV2SetInput>;
  /** filter the rows which have to be updated */
  where: AnsPrimaryNameV2BoolExp;
};

/** aggregate var_pop on columns */
export type AnsPrimaryNameV2VarPopFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type AnsPrimaryNameV2VarSampFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type AnsPrimaryNameV2VarianceFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_pop on columns */
export type AnsPrimaryNameVarPopFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type AnsPrimaryNameVarSampFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type AnsPrimaryNameVarianceFields = {
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "auth_key_account_addresses" */
export type AuthKeyAccountAddresses = {
  account_address: Scalars["String"]["output"];
  auth_key: Scalars["String"]["output"];
  is_auth_key_used: Scalars["Boolean"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
};

/** aggregated selection of "auth_key_account_addresses" */
export type AuthKeyAccountAddressesAggregate = {
  aggregate?: Maybe<AuthKeyAccountAddressesAggregateFields>;
  nodes: Array<AuthKeyAccountAddresses>;
};

/** aggregate fields of "auth_key_account_addresses" */
export type AuthKeyAccountAddressesAggregateFields = {
  avg?: Maybe<AuthKeyAccountAddressesAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<AuthKeyAccountAddressesMaxFields>;
  min?: Maybe<AuthKeyAccountAddressesMinFields>;
  stddev?: Maybe<AuthKeyAccountAddressesStddevFields>;
  stddev_pop?: Maybe<AuthKeyAccountAddressesStddevPopFields>;
  stddev_samp?: Maybe<AuthKeyAccountAddressesStddevSampFields>;
  sum?: Maybe<AuthKeyAccountAddressesSumFields>;
  var_pop?: Maybe<AuthKeyAccountAddressesVarPopFields>;
  var_samp?: Maybe<AuthKeyAccountAddressesVarSampFields>;
  variance?: Maybe<AuthKeyAccountAddressesVarianceFields>;
};

/** aggregate fields of "auth_key_account_addresses" */
export type AuthKeyAccountAddressesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AuthKeyAccountAddressesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type AuthKeyAccountAddressesAvgFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "auth_key_account_addresses". All fields are combined with a logical 'AND'. */
export type AuthKeyAccountAddressesBoolExp = {
  _and?: InputMaybe<Array<AuthKeyAccountAddressesBoolExp>>;
  _not?: InputMaybe<AuthKeyAccountAddressesBoolExp>;
  _or?: InputMaybe<Array<AuthKeyAccountAddressesBoolExp>>;
  account_address?: InputMaybe<StringComparisonExp>;
  auth_key?: InputMaybe<StringComparisonExp>;
  is_auth_key_used?: InputMaybe<BooleanComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "auth_key_account_addresses" */
export enum AuthKeyAccountAddressesConstraint {
  /** unique or primary key constraint on columns "account_address" */
  AuthKeyAccountAddressesPkey = "auth_key_account_addresses_pkey",
}

/** input type for incrementing numeric columns in table "auth_key_account_addresses" */
export type AuthKeyAccountAddressesIncInput = {
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "auth_key_account_addresses" */
export type AuthKeyAccountAddressesInsertInput = {
  account_address?: InputMaybe<Scalars["String"]["input"]>;
  auth_key?: InputMaybe<Scalars["String"]["input"]>;
  is_auth_key_used?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type AuthKeyAccountAddressesMaxFields = {
  account_address?: Maybe<Scalars["String"]["output"]>;
  auth_key?: Maybe<Scalars["String"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type AuthKeyAccountAddressesMinFields = {
  account_address?: Maybe<Scalars["String"]["output"]>;
  auth_key?: Maybe<Scalars["String"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "auth_key_account_addresses" */
export type AuthKeyAccountAddressesMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<AuthKeyAccountAddresses>;
};

/** on_conflict condition type for table "auth_key_account_addresses" */
export type AuthKeyAccountAddressesOnConflict = {
  constraint: AuthKeyAccountAddressesConstraint;
  update_columns?: Array<AuthKeyAccountAddressesUpdateColumn>;
  where?: InputMaybe<AuthKeyAccountAddressesBoolExp>;
};

/** Ordering options when selecting data from "auth_key_account_addresses". */
export type AuthKeyAccountAddressesOrderBy = {
  account_address?: InputMaybe<OrderBy>;
  auth_key?: InputMaybe<OrderBy>;
  is_auth_key_used?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: auth_key_account_addresses */
export type AuthKeyAccountAddressesPkColumnsInput = {
  account_address: Scalars["String"]["input"];
};

/** select columns of table "auth_key_account_addresses" */
export enum AuthKeyAccountAddressesSelectColumn {
  /** column name */
  AccountAddress = "account_address",
  /** column name */
  AuthKey = "auth_key",
  /** column name */
  IsAuthKeyUsed = "is_auth_key_used",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
}

/** input type for updating data in table "auth_key_account_addresses" */
export type AuthKeyAccountAddressesSetInput = {
  account_address?: InputMaybe<Scalars["String"]["input"]>;
  auth_key?: InputMaybe<Scalars["String"]["input"]>;
  is_auth_key_used?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type AuthKeyAccountAddressesStddevFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type AuthKeyAccountAddressesStddevPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type AuthKeyAccountAddressesStddevSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "auth_key_account_addresses" */
export type AuthKeyAccountAddressesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: AuthKeyAccountAddressesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AuthKeyAccountAddressesStreamCursorValueInput = {
  account_address?: InputMaybe<Scalars["String"]["input"]>;
  auth_key?: InputMaybe<Scalars["String"]["input"]>;
  is_auth_key_used?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type AuthKeyAccountAddressesSumFields = {
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "auth_key_account_addresses" */
export enum AuthKeyAccountAddressesUpdateColumn {
  /** column name */
  AccountAddress = "account_address",
  /** column name */
  AuthKey = "auth_key",
  /** column name */
  IsAuthKeyUsed = "is_auth_key_used",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
}

export type AuthKeyAccountAddressesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<AuthKeyAccountAddressesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AuthKeyAccountAddressesSetInput>;
  /** filter the rows which have to be updated */
  where: AuthKeyAccountAddressesBoolExp;
};

/** aggregate var_pop on columns */
export type AuthKeyAccountAddressesVarPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type AuthKeyAccountAddressesVarSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type AuthKeyAccountAddressesVarianceFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'. */
export type BigintComparisonExp = {
  _eq?: InputMaybe<Scalars["bigint"]["input"]>;
  _gt?: InputMaybe<Scalars["bigint"]["input"]>;
  _gte?: InputMaybe<Scalars["bigint"]["input"]>;
  _in?: InputMaybe<Array<Scalars["bigint"]["input"]>>;
  _is_null?: InputMaybe<Scalars["Boolean"]["input"]>;
  _lt?: InputMaybe<Scalars["bigint"]["input"]>;
  _lte?: InputMaybe<Scalars["bigint"]["input"]>;
  _neq?: InputMaybe<Scalars["bigint"]["input"]>;
  _nin?: InputMaybe<Array<Scalars["bigint"]["input"]>>;
};

/** columns and relationships of "block_metadata_transactions" */
export type BlockMetadataTransactions = {
  block_height: Scalars["bigint"]["output"];
  epoch: Scalars["bigint"]["output"];
  failed_proposer_indices: Scalars["jsonb"]["output"];
  id: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  previous_block_votes_bitvec: Scalars["jsonb"]["output"];
  proposer: Scalars["String"]["output"];
  round: Scalars["bigint"]["output"];
  timestamp: Scalars["timestamp"]["output"];
  version: Scalars["bigint"]["output"];
};

/** columns and relationships of "block_metadata_transactions" */
export type BlockMetadataTransactionsFailedProposerIndicesArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** columns and relationships of "block_metadata_transactions" */
export type BlockMetadataTransactionsPreviousBlockVotesBitvecArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregated selection of "block_metadata_transactions" */
export type BlockMetadataTransactionsAggregate = {
  aggregate?: Maybe<BlockMetadataTransactionsAggregateFields>;
  nodes: Array<BlockMetadataTransactions>;
};

/** aggregate fields of "block_metadata_transactions" */
export type BlockMetadataTransactionsAggregateFields = {
  avg?: Maybe<BlockMetadataTransactionsAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<BlockMetadataTransactionsMaxFields>;
  min?: Maybe<BlockMetadataTransactionsMinFields>;
  stddev?: Maybe<BlockMetadataTransactionsStddevFields>;
  stddev_pop?: Maybe<BlockMetadataTransactionsStddevPopFields>;
  stddev_samp?: Maybe<BlockMetadataTransactionsStddevSampFields>;
  sum?: Maybe<BlockMetadataTransactionsSumFields>;
  var_pop?: Maybe<BlockMetadataTransactionsVarPopFields>;
  var_samp?: Maybe<BlockMetadataTransactionsVarSampFields>;
  variance?: Maybe<BlockMetadataTransactionsVarianceFields>;
};

/** aggregate fields of "block_metadata_transactions" */
export type BlockMetadataTransactionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<BlockMetadataTransactionsSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type BlockMetadataTransactionsAppendInput = {
  failed_proposer_indices?: InputMaybe<Scalars["jsonb"]["input"]>;
  previous_block_votes_bitvec?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** aggregate avg on columns */
export type BlockMetadataTransactionsAvgFields = {
  block_height?: Maybe<Scalars["Float"]["output"]>;
  epoch?: Maybe<Scalars["Float"]["output"]>;
  round?: Maybe<Scalars["Float"]["output"]>;
  version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "block_metadata_transactions". All fields are combined with a logical 'AND'. */
export type BlockMetadataTransactionsBoolExp = {
  _and?: InputMaybe<Array<BlockMetadataTransactionsBoolExp>>;
  _not?: InputMaybe<BlockMetadataTransactionsBoolExp>;
  _or?: InputMaybe<Array<BlockMetadataTransactionsBoolExp>>;
  block_height?: InputMaybe<BigintComparisonExp>;
  epoch?: InputMaybe<BigintComparisonExp>;
  failed_proposer_indices?: InputMaybe<JsonbComparisonExp>;
  id?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  previous_block_votes_bitvec?: InputMaybe<JsonbComparisonExp>;
  proposer?: InputMaybe<StringComparisonExp>;
  round?: InputMaybe<BigintComparisonExp>;
  timestamp?: InputMaybe<TimestampComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "block_metadata_transactions" */
export enum BlockMetadataTransactionsConstraint {
  /** unique or primary key constraint on columns "block_height" */
  BlockMetadataTransactionsBlockHeightKey = "block_metadata_transactions_block_height_key",
  /** unique or primary key constraint on columns "version" */
  BlockMetadataTransactionsPkey = "block_metadata_transactions_pkey",
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type BlockMetadataTransactionsDeleteAtPathInput = {
  failed_proposer_indices?: InputMaybe<Array<Scalars["String"]["input"]>>;
  previous_block_votes_bitvec?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type BlockMetadataTransactionsDeleteElemInput = {
  failed_proposer_indices?: InputMaybe<Scalars["Int"]["input"]>;
  previous_block_votes_bitvec?: InputMaybe<Scalars["Int"]["input"]>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type BlockMetadataTransactionsDeleteKeyInput = {
  failed_proposer_indices?: InputMaybe<Scalars["String"]["input"]>;
  previous_block_votes_bitvec?: InputMaybe<Scalars["String"]["input"]>;
};

/** input type for incrementing numeric columns in table "block_metadata_transactions" */
export type BlockMetadataTransactionsIncInput = {
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  epoch?: InputMaybe<Scalars["bigint"]["input"]>;
  round?: InputMaybe<Scalars["bigint"]["input"]>;
  version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "block_metadata_transactions" */
export type BlockMetadataTransactionsInsertInput = {
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  epoch?: InputMaybe<Scalars["bigint"]["input"]>;
  failed_proposer_indices?: InputMaybe<Scalars["jsonb"]["input"]>;
  id?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  previous_block_votes_bitvec?: InputMaybe<Scalars["jsonb"]["input"]>;
  proposer?: InputMaybe<Scalars["String"]["input"]>;
  round?: InputMaybe<Scalars["bigint"]["input"]>;
  timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type BlockMetadataTransactionsMaxFields = {
  block_height?: Maybe<Scalars["bigint"]["output"]>;
  epoch?: Maybe<Scalars["bigint"]["output"]>;
  id?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  proposer?: Maybe<Scalars["String"]["output"]>;
  round?: Maybe<Scalars["bigint"]["output"]>;
  timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type BlockMetadataTransactionsMinFields = {
  block_height?: Maybe<Scalars["bigint"]["output"]>;
  epoch?: Maybe<Scalars["bigint"]["output"]>;
  id?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  proposer?: Maybe<Scalars["String"]["output"]>;
  round?: Maybe<Scalars["bigint"]["output"]>;
  timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  version?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "block_metadata_transactions" */
export type BlockMetadataTransactionsMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<BlockMetadataTransactions>;
};

/** on_conflict condition type for table "block_metadata_transactions" */
export type BlockMetadataTransactionsOnConflict = {
  constraint: BlockMetadataTransactionsConstraint;
  update_columns?: Array<BlockMetadataTransactionsUpdateColumn>;
  where?: InputMaybe<BlockMetadataTransactionsBoolExp>;
};

/** Ordering options when selecting data from "block_metadata_transactions". */
export type BlockMetadataTransactionsOrderBy = {
  block_height?: InputMaybe<OrderBy>;
  epoch?: InputMaybe<OrderBy>;
  failed_proposer_indices?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  previous_block_votes_bitvec?: InputMaybe<OrderBy>;
  proposer?: InputMaybe<OrderBy>;
  round?: InputMaybe<OrderBy>;
  timestamp?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: block_metadata_transactions */
export type BlockMetadataTransactionsPkColumnsInput = {
  version: Scalars["bigint"]["input"];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type BlockMetadataTransactionsPrependInput = {
  failed_proposer_indices?: InputMaybe<Scalars["jsonb"]["input"]>;
  previous_block_votes_bitvec?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** select columns of table "block_metadata_transactions" */
export enum BlockMetadataTransactionsSelectColumn {
  /** column name */
  BlockHeight = "block_height",
  /** column name */
  Epoch = "epoch",
  /** column name */
  FailedProposerIndices = "failed_proposer_indices",
  /** column name */
  Id = "id",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  PreviousBlockVotesBitvec = "previous_block_votes_bitvec",
  /** column name */
  Proposer = "proposer",
  /** column name */
  Round = "round",
  /** column name */
  Timestamp = "timestamp",
  /** column name */
  Version = "version",
}

/** input type for updating data in table "block_metadata_transactions" */
export type BlockMetadataTransactionsSetInput = {
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  epoch?: InputMaybe<Scalars["bigint"]["input"]>;
  failed_proposer_indices?: InputMaybe<Scalars["jsonb"]["input"]>;
  id?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  previous_block_votes_bitvec?: InputMaybe<Scalars["jsonb"]["input"]>;
  proposer?: InputMaybe<Scalars["String"]["input"]>;
  round?: InputMaybe<Scalars["bigint"]["input"]>;
  timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type BlockMetadataTransactionsStddevFields = {
  block_height?: Maybe<Scalars["Float"]["output"]>;
  epoch?: Maybe<Scalars["Float"]["output"]>;
  round?: Maybe<Scalars["Float"]["output"]>;
  version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type BlockMetadataTransactionsStddevPopFields = {
  block_height?: Maybe<Scalars["Float"]["output"]>;
  epoch?: Maybe<Scalars["Float"]["output"]>;
  round?: Maybe<Scalars["Float"]["output"]>;
  version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type BlockMetadataTransactionsStddevSampFields = {
  block_height?: Maybe<Scalars["Float"]["output"]>;
  epoch?: Maybe<Scalars["Float"]["output"]>;
  round?: Maybe<Scalars["Float"]["output"]>;
  version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "block_metadata_transactions" */
export type BlockMetadataTransactionsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: BlockMetadataTransactionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type BlockMetadataTransactionsStreamCursorValueInput = {
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  epoch?: InputMaybe<Scalars["bigint"]["input"]>;
  failed_proposer_indices?: InputMaybe<Scalars["jsonb"]["input"]>;
  id?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  previous_block_votes_bitvec?: InputMaybe<Scalars["jsonb"]["input"]>;
  proposer?: InputMaybe<Scalars["String"]["input"]>;
  round?: InputMaybe<Scalars["bigint"]["input"]>;
  timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type BlockMetadataTransactionsSumFields = {
  block_height?: Maybe<Scalars["bigint"]["output"]>;
  epoch?: Maybe<Scalars["bigint"]["output"]>;
  round?: Maybe<Scalars["bigint"]["output"]>;
  version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "block_metadata_transactions" */
export enum BlockMetadataTransactionsUpdateColumn {
  /** column name */
  BlockHeight = "block_height",
  /** column name */
  Epoch = "epoch",
  /** column name */
  FailedProposerIndices = "failed_proposer_indices",
  /** column name */
  Id = "id",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  PreviousBlockVotesBitvec = "previous_block_votes_bitvec",
  /** column name */
  Proposer = "proposer",
  /** column name */
  Round = "round",
  /** column name */
  Timestamp = "timestamp",
  /** column name */
  Version = "version",
}

export type BlockMetadataTransactionsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<BlockMetadataTransactionsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<BlockMetadataTransactionsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<BlockMetadataTransactionsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<BlockMetadataTransactionsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<BlockMetadataTransactionsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<BlockMetadataTransactionsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<BlockMetadataTransactionsSetInput>;
  /** filter the rows which have to be updated */
  where: BlockMetadataTransactionsBoolExp;
};

/** aggregate var_pop on columns */
export type BlockMetadataTransactionsVarPopFields = {
  block_height?: Maybe<Scalars["Float"]["output"]>;
  epoch?: Maybe<Scalars["Float"]["output"]>;
  round?: Maybe<Scalars["Float"]["output"]>;
  version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type BlockMetadataTransactionsVarSampFields = {
  block_height?: Maybe<Scalars["Float"]["output"]>;
  epoch?: Maybe<Scalars["Float"]["output"]>;
  round?: Maybe<Scalars["Float"]["output"]>;
  version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type BlockMetadataTransactionsVarianceFields = {
  block_height?: Maybe<Scalars["Float"]["output"]>;
  epoch?: Maybe<Scalars["Float"]["output"]>;
  round?: Maybe<Scalars["Float"]["output"]>;
  version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to compare columns of type "bytea". All fields are combined with logical 'AND'. */
export type ByteaComparisonExp = {
  _eq?: InputMaybe<Scalars["bytea"]["input"]>;
  _gt?: InputMaybe<Scalars["bytea"]["input"]>;
  _gte?: InputMaybe<Scalars["bytea"]["input"]>;
  _in?: InputMaybe<Array<Scalars["bytea"]["input"]>>;
  _is_null?: InputMaybe<Scalars["Boolean"]["input"]>;
  _lt?: InputMaybe<Scalars["bytea"]["input"]>;
  _lte?: InputMaybe<Scalars["bytea"]["input"]>;
  _neq?: InputMaybe<Scalars["bytea"]["input"]>;
  _nin?: InputMaybe<Array<Scalars["bytea"]["input"]>>;
};

/** columns and relationships of "coin_activities" */
export type CoinActivities = {
  activity_type: Scalars["String"]["output"];
  amount: Scalars["numeric"]["output"];
  block_height: Scalars["bigint"]["output"];
  coin_type: Scalars["String"]["output"];
  entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
  event_account_address: Scalars["String"]["output"];
  event_creation_number: Scalars["bigint"]["output"];
  event_index?: Maybe<Scalars["bigint"]["output"]>;
  event_sequence_number: Scalars["bigint"]["output"];
  gas_fee_payer_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at: Scalars["timestamp"]["output"];
  is_gas_fee: Scalars["Boolean"]["output"];
  is_transaction_success: Scalars["Boolean"]["output"];
  owner_address: Scalars["String"]["output"];
  storage_refund_amount: Scalars["numeric"]["output"];
  transaction_timestamp: Scalars["timestamp"]["output"];
  transaction_version: Scalars["bigint"]["output"];
};

/** aggregated selection of "coin_activities" */
export type CoinActivitiesAggregate = {
  aggregate?: Maybe<CoinActivitiesAggregateFields>;
  nodes: Array<CoinActivities>;
};

/** aggregate fields of "coin_activities" */
export type CoinActivitiesAggregateFields = {
  avg?: Maybe<CoinActivitiesAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CoinActivitiesMaxFields>;
  min?: Maybe<CoinActivitiesMinFields>;
  stddev?: Maybe<CoinActivitiesStddevFields>;
  stddev_pop?: Maybe<CoinActivitiesStddevPopFields>;
  stddev_samp?: Maybe<CoinActivitiesStddevSampFields>;
  sum?: Maybe<CoinActivitiesSumFields>;
  var_pop?: Maybe<CoinActivitiesVarPopFields>;
  var_samp?: Maybe<CoinActivitiesVarSampFields>;
  variance?: Maybe<CoinActivitiesVarianceFields>;
};

/** aggregate fields of "coin_activities" */
export type CoinActivitiesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CoinActivitiesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CoinActivitiesAvgFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  block_height?: Maybe<Scalars["Float"]["output"]>;
  event_creation_number?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "coin_activities". All fields are combined with a logical 'AND'. */
export type CoinActivitiesBoolExp = {
  _and?: InputMaybe<Array<CoinActivitiesBoolExp>>;
  _not?: InputMaybe<CoinActivitiesBoolExp>;
  _or?: InputMaybe<Array<CoinActivitiesBoolExp>>;
  activity_type?: InputMaybe<StringComparisonExp>;
  amount?: InputMaybe<NumericComparisonExp>;
  block_height?: InputMaybe<BigintComparisonExp>;
  coin_type?: InputMaybe<StringComparisonExp>;
  entry_function_id_str?: InputMaybe<StringComparisonExp>;
  event_account_address?: InputMaybe<StringComparisonExp>;
  event_creation_number?: InputMaybe<BigintComparisonExp>;
  event_index?: InputMaybe<BigintComparisonExp>;
  event_sequence_number?: InputMaybe<BigintComparisonExp>;
  gas_fee_payer_address?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_gas_fee?: InputMaybe<BooleanComparisonExp>;
  is_transaction_success?: InputMaybe<BooleanComparisonExp>;
  owner_address?: InputMaybe<StringComparisonExp>;
  storage_refund_amount?: InputMaybe<NumericComparisonExp>;
  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "coin_activities" */
export enum CoinActivitiesConstraint {
  /** unique or primary key constraint on columns "event_sequence_number", "event_creation_number", "transaction_version", "event_account_address" */
  CoinActivitiesPkey = "coin_activities_pkey",
}

/** input type for incrementing numeric columns in table "coin_activities" */
export type CoinActivitiesIncInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  event_creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  event_sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
  storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "coin_activities" */
export type CoinActivitiesInsertInput = {
  activity_type?: InputMaybe<Scalars["String"]["input"]>;
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  coin_type?: InputMaybe<Scalars["String"]["input"]>;
  entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
  event_account_address?: InputMaybe<Scalars["String"]["input"]>;
  event_creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  event_sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
  gas_fee_payer_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_gas_fee?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_transaction_success?: InputMaybe<Scalars["Boolean"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type CoinActivitiesMaxFields = {
  activity_type?: Maybe<Scalars["String"]["output"]>;
  amount?: Maybe<Scalars["numeric"]["output"]>;
  block_height?: Maybe<Scalars["bigint"]["output"]>;
  coin_type?: Maybe<Scalars["String"]["output"]>;
  entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
  event_account_address?: Maybe<Scalars["String"]["output"]>;
  event_creation_number?: Maybe<Scalars["bigint"]["output"]>;
  event_index?: Maybe<Scalars["bigint"]["output"]>;
  event_sequence_number?: Maybe<Scalars["bigint"]["output"]>;
  gas_fee_payer_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["numeric"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type CoinActivitiesMinFields = {
  activity_type?: Maybe<Scalars["String"]["output"]>;
  amount?: Maybe<Scalars["numeric"]["output"]>;
  block_height?: Maybe<Scalars["bigint"]["output"]>;
  coin_type?: Maybe<Scalars["String"]["output"]>;
  entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
  event_account_address?: Maybe<Scalars["String"]["output"]>;
  event_creation_number?: Maybe<Scalars["bigint"]["output"]>;
  event_index?: Maybe<Scalars["bigint"]["output"]>;
  event_sequence_number?: Maybe<Scalars["bigint"]["output"]>;
  gas_fee_payer_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["numeric"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "coin_activities" */
export type CoinActivitiesMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CoinActivities>;
};

/** on_conflict condition type for table "coin_activities" */
export type CoinActivitiesOnConflict = {
  constraint: CoinActivitiesConstraint;
  update_columns?: Array<CoinActivitiesUpdateColumn>;
  where?: InputMaybe<CoinActivitiesBoolExp>;
};

/** Ordering options when selecting data from "coin_activities". */
export type CoinActivitiesOrderBy = {
  activity_type?: InputMaybe<OrderBy>;
  amount?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  coin_type?: InputMaybe<OrderBy>;
  entry_function_id_str?: InputMaybe<OrderBy>;
  event_account_address?: InputMaybe<OrderBy>;
  event_creation_number?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  event_sequence_number?: InputMaybe<OrderBy>;
  gas_fee_payer_address?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_gas_fee?: InputMaybe<OrderBy>;
  is_transaction_success?: InputMaybe<OrderBy>;
  owner_address?: InputMaybe<OrderBy>;
  storage_refund_amount?: InputMaybe<OrderBy>;
  transaction_timestamp?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: coin_activities */
export type CoinActivitiesPkColumnsInput = {
  event_account_address: Scalars["String"]["input"];
  event_creation_number: Scalars["bigint"]["input"];
  event_sequence_number: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** select columns of table "coin_activities" */
export enum CoinActivitiesSelectColumn {
  /** column name */
  ActivityType = "activity_type",
  /** column name */
  Amount = "amount",
  /** column name */
  BlockHeight = "block_height",
  /** column name */
  CoinType = "coin_type",
  /** column name */
  EntryFunctionIdStr = "entry_function_id_str",
  /** column name */
  EventAccountAddress = "event_account_address",
  /** column name */
  EventCreationNumber = "event_creation_number",
  /** column name */
  EventIndex = "event_index",
  /** column name */
  EventSequenceNumber = "event_sequence_number",
  /** column name */
  GasFeePayerAddress = "gas_fee_payer_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsGasFee = "is_gas_fee",
  /** column name */
  IsTransactionSuccess = "is_transaction_success",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  StorageRefundAmount = "storage_refund_amount",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
}

/** input type for updating data in table "coin_activities" */
export type CoinActivitiesSetInput = {
  activity_type?: InputMaybe<Scalars["String"]["input"]>;
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  coin_type?: InputMaybe<Scalars["String"]["input"]>;
  entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
  event_account_address?: InputMaybe<Scalars["String"]["input"]>;
  event_creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  event_sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
  gas_fee_payer_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_gas_fee?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_transaction_success?: InputMaybe<Scalars["Boolean"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type CoinActivitiesStddevFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  block_height?: Maybe<Scalars["Float"]["output"]>;
  event_creation_number?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CoinActivitiesStddevPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  block_height?: Maybe<Scalars["Float"]["output"]>;
  event_creation_number?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CoinActivitiesStddevSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  block_height?: Maybe<Scalars["Float"]["output"]>;
  event_creation_number?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "coin_activities" */
export type CoinActivitiesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CoinActivitiesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CoinActivitiesStreamCursorValueInput = {
  activity_type?: InputMaybe<Scalars["String"]["input"]>;
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  coin_type?: InputMaybe<Scalars["String"]["input"]>;
  entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
  event_account_address?: InputMaybe<Scalars["String"]["input"]>;
  event_creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  event_sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
  gas_fee_payer_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_gas_fee?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_transaction_success?: InputMaybe<Scalars["Boolean"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type CoinActivitiesSumFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  block_height?: Maybe<Scalars["bigint"]["output"]>;
  event_creation_number?: Maybe<Scalars["bigint"]["output"]>;
  event_index?: Maybe<Scalars["bigint"]["output"]>;
  event_sequence_number?: Maybe<Scalars["bigint"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["numeric"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "coin_activities" */
export enum CoinActivitiesUpdateColumn {
  /** column name */
  ActivityType = "activity_type",
  /** column name */
  Amount = "amount",
  /** column name */
  BlockHeight = "block_height",
  /** column name */
  CoinType = "coin_type",
  /** column name */
  EntryFunctionIdStr = "entry_function_id_str",
  /** column name */
  EventAccountAddress = "event_account_address",
  /** column name */
  EventCreationNumber = "event_creation_number",
  /** column name */
  EventIndex = "event_index",
  /** column name */
  EventSequenceNumber = "event_sequence_number",
  /** column name */
  GasFeePayerAddress = "gas_fee_payer_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsGasFee = "is_gas_fee",
  /** column name */
  IsTransactionSuccess = "is_transaction_success",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  StorageRefundAmount = "storage_refund_amount",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
}

export type CoinActivitiesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CoinActivitiesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CoinActivitiesSetInput>;
  /** filter the rows which have to be updated */
  where: CoinActivitiesBoolExp;
};

/** aggregate var_pop on columns */
export type CoinActivitiesVarPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  block_height?: Maybe<Scalars["Float"]["output"]>;
  event_creation_number?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CoinActivitiesVarSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  block_height?: Maybe<Scalars["Float"]["output"]>;
  event_creation_number?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CoinActivitiesVarianceFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  block_height?: Maybe<Scalars["Float"]["output"]>;
  event_creation_number?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "coin_balances" */
export type CoinBalances = {
  amount: Scalars["numeric"]["output"];
  coin_type: Scalars["String"]["output"];
  coin_type_hash: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  owner_address: Scalars["String"]["output"];
  transaction_timestamp: Scalars["timestamp"]["output"];
  transaction_version: Scalars["bigint"]["output"];
};

/** aggregated selection of "coin_balances" */
export type CoinBalancesAggregate = {
  aggregate?: Maybe<CoinBalancesAggregateFields>;
  nodes: Array<CoinBalances>;
};

/** aggregate fields of "coin_balances" */
export type CoinBalancesAggregateFields = {
  avg?: Maybe<CoinBalancesAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CoinBalancesMaxFields>;
  min?: Maybe<CoinBalancesMinFields>;
  stddev?: Maybe<CoinBalancesStddevFields>;
  stddev_pop?: Maybe<CoinBalancesStddevPopFields>;
  stddev_samp?: Maybe<CoinBalancesStddevSampFields>;
  sum?: Maybe<CoinBalancesSumFields>;
  var_pop?: Maybe<CoinBalancesVarPopFields>;
  var_samp?: Maybe<CoinBalancesVarSampFields>;
  variance?: Maybe<CoinBalancesVarianceFields>;
};

/** aggregate fields of "coin_balances" */
export type CoinBalancesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CoinBalancesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CoinBalancesAvgFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "coin_balances". All fields are combined with a logical 'AND'. */
export type CoinBalancesBoolExp = {
  _and?: InputMaybe<Array<CoinBalancesBoolExp>>;
  _not?: InputMaybe<CoinBalancesBoolExp>;
  _or?: InputMaybe<Array<CoinBalancesBoolExp>>;
  amount?: InputMaybe<NumericComparisonExp>;
  coin_type?: InputMaybe<StringComparisonExp>;
  coin_type_hash?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  owner_address?: InputMaybe<StringComparisonExp>;
  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "coin_balances" */
export enum CoinBalancesConstraint {
  /** unique or primary key constraint on columns "coin_type_hash", "owner_address", "transaction_version" */
  CoinBalancesPkey = "coin_balances_pkey",
}

/** input type for incrementing numeric columns in table "coin_balances" */
export type CoinBalancesIncInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "coin_balances" */
export type CoinBalancesInsertInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  coin_type?: InputMaybe<Scalars["String"]["input"]>;
  coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type CoinBalancesMaxFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  coin_type?: Maybe<Scalars["String"]["output"]>;
  coin_type_hash?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type CoinBalancesMinFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  coin_type?: Maybe<Scalars["String"]["output"]>;
  coin_type_hash?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "coin_balances" */
export type CoinBalancesMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CoinBalances>;
};

/** on_conflict condition type for table "coin_balances" */
export type CoinBalancesOnConflict = {
  constraint: CoinBalancesConstraint;
  update_columns?: Array<CoinBalancesUpdateColumn>;
  where?: InputMaybe<CoinBalancesBoolExp>;
};

/** Ordering options when selecting data from "coin_balances". */
export type CoinBalancesOrderBy = {
  amount?: InputMaybe<OrderBy>;
  coin_type?: InputMaybe<OrderBy>;
  coin_type_hash?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  owner_address?: InputMaybe<OrderBy>;
  transaction_timestamp?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: coin_balances */
export type CoinBalancesPkColumnsInput = {
  coin_type_hash: Scalars["String"]["input"];
  owner_address: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** select columns of table "coin_balances" */
export enum CoinBalancesSelectColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  CoinType = "coin_type",
  /** column name */
  CoinTypeHash = "coin_type_hash",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
}

/** input type for updating data in table "coin_balances" */
export type CoinBalancesSetInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  coin_type?: InputMaybe<Scalars["String"]["input"]>;
  coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type CoinBalancesStddevFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CoinBalancesStddevPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CoinBalancesStddevSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "coin_balances" */
export type CoinBalancesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CoinBalancesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CoinBalancesStreamCursorValueInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  coin_type?: InputMaybe<Scalars["String"]["input"]>;
  coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type CoinBalancesSumFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "coin_balances" */
export enum CoinBalancesUpdateColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  CoinType = "coin_type",
  /** column name */
  CoinTypeHash = "coin_type_hash",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
}

export type CoinBalancesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CoinBalancesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CoinBalancesSetInput>;
  /** filter the rows which have to be updated */
  where: CoinBalancesBoolExp;
};

/** aggregate var_pop on columns */
export type CoinBalancesVarPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CoinBalancesVarSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CoinBalancesVarianceFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "coin_infos" */
export type CoinInfos = {
  coin_type: Scalars["String"]["output"];
  coin_type_hash: Scalars["String"]["output"];
  creator_address: Scalars["String"]["output"];
  decimals: Scalars["Int"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  name: Scalars["String"]["output"];
  supply_aggregator_table_handle?: Maybe<Scalars["String"]["output"]>;
  supply_aggregator_table_key?: Maybe<Scalars["String"]["output"]>;
  symbol: Scalars["String"]["output"];
  transaction_created_timestamp: Scalars["timestamp"]["output"];
  transaction_version_created: Scalars["bigint"]["output"];
};

/** aggregated selection of "coin_infos" */
export type CoinInfosAggregate = {
  aggregate?: Maybe<CoinInfosAggregateFields>;
  nodes: Array<CoinInfos>;
};

/** aggregate fields of "coin_infos" */
export type CoinInfosAggregateFields = {
  avg?: Maybe<CoinInfosAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CoinInfosMaxFields>;
  min?: Maybe<CoinInfosMinFields>;
  stddev?: Maybe<CoinInfosStddevFields>;
  stddev_pop?: Maybe<CoinInfosStddevPopFields>;
  stddev_samp?: Maybe<CoinInfosStddevSampFields>;
  sum?: Maybe<CoinInfosSumFields>;
  var_pop?: Maybe<CoinInfosVarPopFields>;
  var_samp?: Maybe<CoinInfosVarSampFields>;
  variance?: Maybe<CoinInfosVarianceFields>;
};

/** aggregate fields of "coin_infos" */
export type CoinInfosAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CoinInfosSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CoinInfosAvgFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  transaction_version_created?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "coin_infos". All fields are combined with a logical 'AND'. */
export type CoinInfosBoolExp = {
  _and?: InputMaybe<Array<CoinInfosBoolExp>>;
  _not?: InputMaybe<CoinInfosBoolExp>;
  _or?: InputMaybe<Array<CoinInfosBoolExp>>;
  coin_type?: InputMaybe<StringComparisonExp>;
  coin_type_hash?: InputMaybe<StringComparisonExp>;
  creator_address?: InputMaybe<StringComparisonExp>;
  decimals?: InputMaybe<IntComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  supply_aggregator_table_handle?: InputMaybe<StringComparisonExp>;
  supply_aggregator_table_key?: InputMaybe<StringComparisonExp>;
  symbol?: InputMaybe<StringComparisonExp>;
  transaction_created_timestamp?: InputMaybe<TimestampComparisonExp>;
  transaction_version_created?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "coin_infos" */
export enum CoinInfosConstraint {
  /** unique or primary key constraint on columns "coin_type_hash" */
  CoinInfosPkey = "coin_infos_pkey",
}

/** input type for incrementing numeric columns in table "coin_infos" */
export type CoinInfosIncInput = {
  decimals?: InputMaybe<Scalars["Int"]["input"]>;
  transaction_version_created?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "coin_infos" */
export type CoinInfosInsertInput = {
  coin_type?: InputMaybe<Scalars["String"]["input"]>;
  coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  decimals?: InputMaybe<Scalars["Int"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  supply_aggregator_table_handle?: InputMaybe<Scalars["String"]["input"]>;
  supply_aggregator_table_key?: InputMaybe<Scalars["String"]["input"]>;
  symbol?: InputMaybe<Scalars["String"]["input"]>;
  transaction_created_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version_created?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type CoinInfosMaxFields = {
  coin_type?: Maybe<Scalars["String"]["output"]>;
  coin_type_hash?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  decimals?: Maybe<Scalars["Int"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  supply_aggregator_table_handle?: Maybe<Scalars["String"]["output"]>;
  supply_aggregator_table_key?: Maybe<Scalars["String"]["output"]>;
  symbol?: Maybe<Scalars["String"]["output"]>;
  transaction_created_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version_created?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type CoinInfosMinFields = {
  coin_type?: Maybe<Scalars["String"]["output"]>;
  coin_type_hash?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  decimals?: Maybe<Scalars["Int"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  supply_aggregator_table_handle?: Maybe<Scalars["String"]["output"]>;
  supply_aggregator_table_key?: Maybe<Scalars["String"]["output"]>;
  symbol?: Maybe<Scalars["String"]["output"]>;
  transaction_created_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version_created?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "coin_infos" */
export type CoinInfosMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CoinInfos>;
};

/** on_conflict condition type for table "coin_infos" */
export type CoinInfosOnConflict = {
  constraint: CoinInfosConstraint;
  update_columns?: Array<CoinInfosUpdateColumn>;
  where?: InputMaybe<CoinInfosBoolExp>;
};

/** Ordering options when selecting data from "coin_infos". */
export type CoinInfosOrderBy = {
  coin_type?: InputMaybe<OrderBy>;
  coin_type_hash?: InputMaybe<OrderBy>;
  creator_address?: InputMaybe<OrderBy>;
  decimals?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  supply_aggregator_table_handle?: InputMaybe<OrderBy>;
  supply_aggregator_table_key?: InputMaybe<OrderBy>;
  symbol?: InputMaybe<OrderBy>;
  transaction_created_timestamp?: InputMaybe<OrderBy>;
  transaction_version_created?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: coin_infos */
export type CoinInfosPkColumnsInput = {
  coin_type_hash: Scalars["String"]["input"];
};

/** select columns of table "coin_infos" */
export enum CoinInfosSelectColumn {
  /** column name */
  CoinType = "coin_type",
  /** column name */
  CoinTypeHash = "coin_type_hash",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  Decimals = "decimals",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  Name = "name",
  /** column name */
  SupplyAggregatorTableHandle = "supply_aggregator_table_handle",
  /** column name */
  SupplyAggregatorTableKey = "supply_aggregator_table_key",
  /** column name */
  Symbol = "symbol",
  /** column name */
  TransactionCreatedTimestamp = "transaction_created_timestamp",
  /** column name */
  TransactionVersionCreated = "transaction_version_created",
}

/** input type for updating data in table "coin_infos" */
export type CoinInfosSetInput = {
  coin_type?: InputMaybe<Scalars["String"]["input"]>;
  coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  decimals?: InputMaybe<Scalars["Int"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  supply_aggregator_table_handle?: InputMaybe<Scalars["String"]["input"]>;
  supply_aggregator_table_key?: InputMaybe<Scalars["String"]["input"]>;
  symbol?: InputMaybe<Scalars["String"]["input"]>;
  transaction_created_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version_created?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type CoinInfosStddevFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  transaction_version_created?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CoinInfosStddevPopFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  transaction_version_created?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CoinInfosStddevSampFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  transaction_version_created?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "coin_infos" */
export type CoinInfosStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CoinInfosStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CoinInfosStreamCursorValueInput = {
  coin_type?: InputMaybe<Scalars["String"]["input"]>;
  coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  decimals?: InputMaybe<Scalars["Int"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  supply_aggregator_table_handle?: InputMaybe<Scalars["String"]["input"]>;
  supply_aggregator_table_key?: InputMaybe<Scalars["String"]["input"]>;
  symbol?: InputMaybe<Scalars["String"]["input"]>;
  transaction_created_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version_created?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type CoinInfosSumFields = {
  decimals?: Maybe<Scalars["Int"]["output"]>;
  transaction_version_created?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "coin_infos" */
export enum CoinInfosUpdateColumn {
  /** column name */
  CoinType = "coin_type",
  /** column name */
  CoinTypeHash = "coin_type_hash",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  Decimals = "decimals",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  Name = "name",
  /** column name */
  SupplyAggregatorTableHandle = "supply_aggregator_table_handle",
  /** column name */
  SupplyAggregatorTableKey = "supply_aggregator_table_key",
  /** column name */
  Symbol = "symbol",
  /** column name */
  TransactionCreatedTimestamp = "transaction_created_timestamp",
  /** column name */
  TransactionVersionCreated = "transaction_version_created",
}

export type CoinInfosUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CoinInfosIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CoinInfosSetInput>;
  /** filter the rows which have to be updated */
  where: CoinInfosBoolExp;
};

/** aggregate var_pop on columns */
export type CoinInfosVarPopFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  transaction_version_created?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CoinInfosVarSampFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  transaction_version_created?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CoinInfosVarianceFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  transaction_version_created?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "coin_supply" */
export type CoinSupply = {
  coin_type: Scalars["String"]["output"];
  coin_type_hash: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  supply: Scalars["numeric"]["output"];
  transaction_epoch: Scalars["bigint"]["output"];
  transaction_timestamp: Scalars["timestamp"]["output"];
  transaction_version: Scalars["bigint"]["output"];
};

/** aggregated selection of "coin_supply" */
export type CoinSupplyAggregate = {
  aggregate?: Maybe<CoinSupplyAggregateFields>;
  nodes: Array<CoinSupply>;
};

/** aggregate fields of "coin_supply" */
export type CoinSupplyAggregateFields = {
  avg?: Maybe<CoinSupplyAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CoinSupplyMaxFields>;
  min?: Maybe<CoinSupplyMinFields>;
  stddev?: Maybe<CoinSupplyStddevFields>;
  stddev_pop?: Maybe<CoinSupplyStddevPopFields>;
  stddev_samp?: Maybe<CoinSupplyStddevSampFields>;
  sum?: Maybe<CoinSupplySumFields>;
  var_pop?: Maybe<CoinSupplyVarPopFields>;
  var_samp?: Maybe<CoinSupplyVarSampFields>;
  variance?: Maybe<CoinSupplyVarianceFields>;
};

/** aggregate fields of "coin_supply" */
export type CoinSupplyAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CoinSupplySelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CoinSupplyAvgFields = {
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_epoch?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "coin_supply". All fields are combined with a logical 'AND'. */
export type CoinSupplyBoolExp = {
  _and?: InputMaybe<Array<CoinSupplyBoolExp>>;
  _not?: InputMaybe<CoinSupplyBoolExp>;
  _or?: InputMaybe<Array<CoinSupplyBoolExp>>;
  coin_type?: InputMaybe<StringComparisonExp>;
  coin_type_hash?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  supply?: InputMaybe<NumericComparisonExp>;
  transaction_epoch?: InputMaybe<BigintComparisonExp>;
  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "coin_supply" */
export enum CoinSupplyConstraint {
  /** unique or primary key constraint on columns "coin_type_hash", "transaction_version" */
  CoinSupplyPkey = "coin_supply_pkey",
}

/** input type for incrementing numeric columns in table "coin_supply" */
export type CoinSupplyIncInput = {
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_epoch?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "coin_supply" */
export type CoinSupplyInsertInput = {
  coin_type?: InputMaybe<Scalars["String"]["input"]>;
  coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_epoch?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type CoinSupplyMaxFields = {
  coin_type?: Maybe<Scalars["String"]["output"]>;
  coin_type_hash?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  supply?: Maybe<Scalars["numeric"]["output"]>;
  transaction_epoch?: Maybe<Scalars["bigint"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type CoinSupplyMinFields = {
  coin_type?: Maybe<Scalars["String"]["output"]>;
  coin_type_hash?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  supply?: Maybe<Scalars["numeric"]["output"]>;
  transaction_epoch?: Maybe<Scalars["bigint"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "coin_supply" */
export type CoinSupplyMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CoinSupply>;
};

/** on_conflict condition type for table "coin_supply" */
export type CoinSupplyOnConflict = {
  constraint: CoinSupplyConstraint;
  update_columns?: Array<CoinSupplyUpdateColumn>;
  where?: InputMaybe<CoinSupplyBoolExp>;
};

/** Ordering options when selecting data from "coin_supply". */
export type CoinSupplyOrderBy = {
  coin_type?: InputMaybe<OrderBy>;
  coin_type_hash?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  supply?: InputMaybe<OrderBy>;
  transaction_epoch?: InputMaybe<OrderBy>;
  transaction_timestamp?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: coin_supply */
export type CoinSupplyPkColumnsInput = {
  coin_type_hash: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** select columns of table "coin_supply" */
export enum CoinSupplySelectColumn {
  /** column name */
  CoinType = "coin_type",
  /** column name */
  CoinTypeHash = "coin_type_hash",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  Supply = "supply",
  /** column name */
  TransactionEpoch = "transaction_epoch",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
}

/** input type for updating data in table "coin_supply" */
export type CoinSupplySetInput = {
  coin_type?: InputMaybe<Scalars["String"]["input"]>;
  coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_epoch?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type CoinSupplyStddevFields = {
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_epoch?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CoinSupplyStddevPopFields = {
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_epoch?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CoinSupplyStddevSampFields = {
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_epoch?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "coin_supply" */
export type CoinSupplyStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CoinSupplyStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CoinSupplyStreamCursorValueInput = {
  coin_type?: InputMaybe<Scalars["String"]["input"]>;
  coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_epoch?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type CoinSupplySumFields = {
  supply?: Maybe<Scalars["numeric"]["output"]>;
  transaction_epoch?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "coin_supply" */
export enum CoinSupplyUpdateColumn {
  /** column name */
  CoinType = "coin_type",
  /** column name */
  CoinTypeHash = "coin_type_hash",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  Supply = "supply",
  /** column name */
  TransactionEpoch = "transaction_epoch",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
}

export type CoinSupplyUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CoinSupplyIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CoinSupplySetInput>;
  /** filter the rows which have to be updated */
  where: CoinSupplyBoolExp;
};

/** aggregate var_pop on columns */
export type CoinSupplyVarPopFields = {
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_epoch?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CoinSupplyVarSampFields = {
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_epoch?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CoinSupplyVarianceFields = {
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_epoch?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "collection_datas" */
export type CollectionDatas = {
  collection_data_id_hash: Scalars["String"]["output"];
  collection_name: Scalars["String"]["output"];
  creator_address: Scalars["String"]["output"];
  description: Scalars["String"]["output"];
  description_mutable: Scalars["Boolean"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  maximum: Scalars["numeric"]["output"];
  maximum_mutable: Scalars["Boolean"]["output"];
  metadata_uri: Scalars["String"]["output"];
  supply: Scalars["numeric"]["output"];
  table_handle: Scalars["String"]["output"];
  transaction_timestamp: Scalars["timestamp"]["output"];
  transaction_version: Scalars["bigint"]["output"];
  uri_mutable: Scalars["Boolean"]["output"];
};

/** aggregated selection of "collection_datas" */
export type CollectionDatasAggregate = {
  aggregate?: Maybe<CollectionDatasAggregateFields>;
  nodes: Array<CollectionDatas>;
};

/** aggregate fields of "collection_datas" */
export type CollectionDatasAggregateFields = {
  avg?: Maybe<CollectionDatasAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CollectionDatasMaxFields>;
  min?: Maybe<CollectionDatasMinFields>;
  stddev?: Maybe<CollectionDatasStddevFields>;
  stddev_pop?: Maybe<CollectionDatasStddevPopFields>;
  stddev_samp?: Maybe<CollectionDatasStddevSampFields>;
  sum?: Maybe<CollectionDatasSumFields>;
  var_pop?: Maybe<CollectionDatasVarPopFields>;
  var_samp?: Maybe<CollectionDatasVarSampFields>;
  variance?: Maybe<CollectionDatasVarianceFields>;
};

/** aggregate fields of "collection_datas" */
export type CollectionDatasAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CollectionDatasSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CollectionDatasAvgFields = {
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "collection_datas". All fields are combined with a logical 'AND'. */
export type CollectionDatasBoolExp = {
  _and?: InputMaybe<Array<CollectionDatasBoolExp>>;
  _not?: InputMaybe<CollectionDatasBoolExp>;
  _or?: InputMaybe<Array<CollectionDatasBoolExp>>;
  collection_data_id_hash?: InputMaybe<StringComparisonExp>;
  collection_name?: InputMaybe<StringComparisonExp>;
  creator_address?: InputMaybe<StringComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  description_mutable?: InputMaybe<BooleanComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  maximum?: InputMaybe<NumericComparisonExp>;
  maximum_mutable?: InputMaybe<BooleanComparisonExp>;
  metadata_uri?: InputMaybe<StringComparisonExp>;
  supply?: InputMaybe<NumericComparisonExp>;
  table_handle?: InputMaybe<StringComparisonExp>;
  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  uri_mutable?: InputMaybe<BooleanComparisonExp>;
};

/** unique or primary key constraints on table "collection_datas" */
export enum CollectionDatasConstraint {
  /** unique or primary key constraint on columns "collection_data_id_hash", "transaction_version" */
  CollectionDatasPkey = "collection_datas_pkey",
}

/** input type for incrementing numeric columns in table "collection_datas" */
export type CollectionDatasIncInput = {
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "collection_datas" */
export type CollectionDatasInsertInput = {
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate max on columns */
export type CollectionDatasMaxFields = {
  collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  description?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  maximum?: Maybe<Scalars["numeric"]["output"]>;
  metadata_uri?: Maybe<Scalars["String"]["output"]>;
  supply?: Maybe<Scalars["numeric"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type CollectionDatasMinFields = {
  collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  description?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  maximum?: Maybe<Scalars["numeric"]["output"]>;
  metadata_uri?: Maybe<Scalars["String"]["output"]>;
  supply?: Maybe<Scalars["numeric"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "collection_datas" */
export type CollectionDatasMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CollectionDatas>;
};

/** on_conflict condition type for table "collection_datas" */
export type CollectionDatasOnConflict = {
  constraint: CollectionDatasConstraint;
  update_columns?: Array<CollectionDatasUpdateColumn>;
  where?: InputMaybe<CollectionDatasBoolExp>;
};

/** Ordering options when selecting data from "collection_datas". */
export type CollectionDatasOrderBy = {
  collection_data_id_hash?: InputMaybe<OrderBy>;
  collection_name?: InputMaybe<OrderBy>;
  creator_address?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  description_mutable?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  maximum?: InputMaybe<OrderBy>;
  maximum_mutable?: InputMaybe<OrderBy>;
  metadata_uri?: InputMaybe<OrderBy>;
  supply?: InputMaybe<OrderBy>;
  table_handle?: InputMaybe<OrderBy>;
  transaction_timestamp?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  uri_mutable?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: collection_datas */
export type CollectionDatasPkColumnsInput = {
  collection_data_id_hash: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** select columns of table "collection_datas" */
export enum CollectionDatasSelectColumn {
  /** column name */
  CollectionDataIdHash = "collection_data_id_hash",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  Description = "description",
  /** column name */
  DescriptionMutable = "description_mutable",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  Maximum = "maximum",
  /** column name */
  MaximumMutable = "maximum_mutable",
  /** column name */
  MetadataUri = "metadata_uri",
  /** column name */
  Supply = "supply",
  /** column name */
  TableHandle = "table_handle",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  UriMutable = "uri_mutable",
}

/** input type for updating data in table "collection_datas" */
export type CollectionDatasSetInput = {
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate stddev on columns */
export type CollectionDatasStddevFields = {
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CollectionDatasStddevPopFields = {
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CollectionDatasStddevSampFields = {
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "collection_datas" */
export type CollectionDatasStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CollectionDatasStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CollectionDatasStreamCursorValueInput = {
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate sum on columns */
export type CollectionDatasSumFields = {
  maximum?: Maybe<Scalars["numeric"]["output"]>;
  supply?: Maybe<Scalars["numeric"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "collection_datas" */
export enum CollectionDatasUpdateColumn {
  /** column name */
  CollectionDataIdHash = "collection_data_id_hash",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  Description = "description",
  /** column name */
  DescriptionMutable = "description_mutable",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  Maximum = "maximum",
  /** column name */
  MaximumMutable = "maximum_mutable",
  /** column name */
  MetadataUri = "metadata_uri",
  /** column name */
  Supply = "supply",
  /** column name */
  TableHandle = "table_handle",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  UriMutable = "uri_mutable",
}

export type CollectionDatasUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CollectionDatasIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CollectionDatasSetInput>;
  /** filter the rows which have to be updated */
  where: CollectionDatasBoolExp;
};

/** aggregate var_pop on columns */
export type CollectionDatasVarPopFields = {
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CollectionDatasVarSampFields = {
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CollectionDatasVarianceFields = {
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "collections_v2" */
export type CollectionsV2 = {
  collection_id: Scalars["String"]["output"];
  collection_name: Scalars["String"]["output"];
  collection_properties?: Maybe<Scalars["jsonb"]["output"]>;
  creator_address: Scalars["String"]["output"];
  current_supply: Scalars["numeric"]["output"];
  description: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  max_supply?: Maybe<Scalars["numeric"]["output"]>;
  mutable_description?: Maybe<Scalars["Boolean"]["output"]>;
  mutable_uri?: Maybe<Scalars["Boolean"]["output"]>;
  table_handle_v1?: Maybe<Scalars["String"]["output"]>;
  token_standard: Scalars["String"]["output"];
  total_minted_v2?: Maybe<Scalars["numeric"]["output"]>;
  transaction_timestamp: Scalars["timestamp"]["output"];
  transaction_version: Scalars["bigint"]["output"];
  uri: Scalars["String"]["output"];
  write_set_change_index: Scalars["bigint"]["output"];
};

/** columns and relationships of "collections_v2" */
export type CollectionsV2CollectionPropertiesArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregated selection of "collections_v2" */
export type CollectionsV2Aggregate = {
  aggregate?: Maybe<CollectionsV2AggregateFields>;
  nodes: Array<CollectionsV2>;
};

/** aggregate fields of "collections_v2" */
export type CollectionsV2AggregateFields = {
  avg?: Maybe<CollectionsV2AvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CollectionsV2MaxFields>;
  min?: Maybe<CollectionsV2MinFields>;
  stddev?: Maybe<CollectionsV2StddevFields>;
  stddev_pop?: Maybe<CollectionsV2StddevPopFields>;
  stddev_samp?: Maybe<CollectionsV2StddevSampFields>;
  sum?: Maybe<CollectionsV2SumFields>;
  var_pop?: Maybe<CollectionsV2VarPopFields>;
  var_samp?: Maybe<CollectionsV2VarSampFields>;
  variance?: Maybe<CollectionsV2VarianceFields>;
};

/** aggregate fields of "collections_v2" */
export type CollectionsV2AggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CollectionsV2SelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type CollectionsV2AppendInput = {
  collection_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** aggregate avg on columns */
export type CollectionsV2AvgFields = {
  current_supply?: Maybe<Scalars["Float"]["output"]>;
  max_supply?: Maybe<Scalars["Float"]["output"]>;
  total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "collections_v2". All fields are combined with a logical 'AND'. */
export type CollectionsV2BoolExp = {
  _and?: InputMaybe<Array<CollectionsV2BoolExp>>;
  _not?: InputMaybe<CollectionsV2BoolExp>;
  _or?: InputMaybe<Array<CollectionsV2BoolExp>>;
  collection_id?: InputMaybe<StringComparisonExp>;
  collection_name?: InputMaybe<StringComparisonExp>;
  collection_properties?: InputMaybe<JsonbComparisonExp>;
  creator_address?: InputMaybe<StringComparisonExp>;
  current_supply?: InputMaybe<NumericComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  max_supply?: InputMaybe<NumericComparisonExp>;
  mutable_description?: InputMaybe<BooleanComparisonExp>;
  mutable_uri?: InputMaybe<BooleanComparisonExp>;
  table_handle_v1?: InputMaybe<StringComparisonExp>;
  token_standard?: InputMaybe<StringComparisonExp>;
  total_minted_v2?: InputMaybe<NumericComparisonExp>;
  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  uri?: InputMaybe<StringComparisonExp>;
  write_set_change_index?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "collections_v2" */
export enum CollectionsV2Constraint {
  /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
  CollectionsV2Pkey = "collections_v2_pkey",
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type CollectionsV2DeleteAtPathInput = {
  collection_properties?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type CollectionsV2DeleteElemInput = {
  collection_properties?: InputMaybe<Scalars["Int"]["input"]>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type CollectionsV2DeleteKeyInput = {
  collection_properties?: InputMaybe<Scalars["String"]["input"]>;
};

/** input type for incrementing numeric columns in table "collections_v2" */
export type CollectionsV2IncInput = {
  current_supply?: InputMaybe<Scalars["numeric"]["input"]>;
  max_supply?: InputMaybe<Scalars["numeric"]["input"]>;
  total_minted_v2?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "collections_v2" */
export type CollectionsV2InsertInput = {
  collection_id?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  collection_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  current_supply?: InputMaybe<Scalars["numeric"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  max_supply?: InputMaybe<Scalars["numeric"]["input"]>;
  mutable_description?: InputMaybe<Scalars["Boolean"]["input"]>;
  mutable_uri?: InputMaybe<Scalars["Boolean"]["input"]>;
  table_handle_v1?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  total_minted_v2?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  uri?: InputMaybe<Scalars["String"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type CollectionsV2MaxFields = {
  collection_id?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  current_supply?: Maybe<Scalars["numeric"]["output"]>;
  description?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  max_supply?: Maybe<Scalars["numeric"]["output"]>;
  table_handle_v1?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
  total_minted_v2?: Maybe<Scalars["numeric"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  uri?: Maybe<Scalars["String"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type CollectionsV2MinFields = {
  collection_id?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  current_supply?: Maybe<Scalars["numeric"]["output"]>;
  description?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  max_supply?: Maybe<Scalars["numeric"]["output"]>;
  table_handle_v1?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
  total_minted_v2?: Maybe<Scalars["numeric"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  uri?: Maybe<Scalars["String"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "collections_v2" */
export type CollectionsV2MutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CollectionsV2>;
};

/** on_conflict condition type for table "collections_v2" */
export type CollectionsV2OnConflict = {
  constraint: CollectionsV2Constraint;
  update_columns?: Array<CollectionsV2UpdateColumn>;
  where?: InputMaybe<CollectionsV2BoolExp>;
};

/** Ordering options when selecting data from "collections_v2". */
export type CollectionsV2OrderBy = {
  collection_id?: InputMaybe<OrderBy>;
  collection_name?: InputMaybe<OrderBy>;
  collection_properties?: InputMaybe<OrderBy>;
  creator_address?: InputMaybe<OrderBy>;
  current_supply?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  max_supply?: InputMaybe<OrderBy>;
  mutable_description?: InputMaybe<OrderBy>;
  mutable_uri?: InputMaybe<OrderBy>;
  table_handle_v1?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
  total_minted_v2?: InputMaybe<OrderBy>;
  transaction_timestamp?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  uri?: InputMaybe<OrderBy>;
  write_set_change_index?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: collections_v2 */
export type CollectionsV2PkColumnsInput = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type CollectionsV2PrependInput = {
  collection_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** select columns of table "collections_v2" */
export enum CollectionsV2SelectColumn {
  /** column name */
  CollectionId = "collection_id",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CollectionProperties = "collection_properties",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  CurrentSupply = "current_supply",
  /** column name */
  Description = "description",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  MaxSupply = "max_supply",
  /** column name */
  MutableDescription = "mutable_description",
  /** column name */
  MutableUri = "mutable_uri",
  /** column name */
  TableHandleV1 = "table_handle_v1",
  /** column name */
  TokenStandard = "token_standard",
  /** column name */
  TotalMintedV2 = "total_minted_v2",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  Uri = "uri",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

/** input type for updating data in table "collections_v2" */
export type CollectionsV2SetInput = {
  collection_id?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  collection_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  current_supply?: InputMaybe<Scalars["numeric"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  max_supply?: InputMaybe<Scalars["numeric"]["input"]>;
  mutable_description?: InputMaybe<Scalars["Boolean"]["input"]>;
  mutable_uri?: InputMaybe<Scalars["Boolean"]["input"]>;
  table_handle_v1?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  total_minted_v2?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  uri?: InputMaybe<Scalars["String"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type CollectionsV2StddevFields = {
  current_supply?: Maybe<Scalars["Float"]["output"]>;
  max_supply?: Maybe<Scalars["Float"]["output"]>;
  total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CollectionsV2StddevPopFields = {
  current_supply?: Maybe<Scalars["Float"]["output"]>;
  max_supply?: Maybe<Scalars["Float"]["output"]>;
  total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CollectionsV2StddevSampFields = {
  current_supply?: Maybe<Scalars["Float"]["output"]>;
  max_supply?: Maybe<Scalars["Float"]["output"]>;
  total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "collections_v2" */
export type CollectionsV2StreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CollectionsV2StreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CollectionsV2StreamCursorValueInput = {
  collection_id?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  collection_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  current_supply?: InputMaybe<Scalars["numeric"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  max_supply?: InputMaybe<Scalars["numeric"]["input"]>;
  mutable_description?: InputMaybe<Scalars["Boolean"]["input"]>;
  mutable_uri?: InputMaybe<Scalars["Boolean"]["input"]>;
  table_handle_v1?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  total_minted_v2?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  uri?: InputMaybe<Scalars["String"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type CollectionsV2SumFields = {
  current_supply?: Maybe<Scalars["numeric"]["output"]>;
  max_supply?: Maybe<Scalars["numeric"]["output"]>;
  total_minted_v2?: Maybe<Scalars["numeric"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "collections_v2" */
export enum CollectionsV2UpdateColumn {
  /** column name */
  CollectionId = "collection_id",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CollectionProperties = "collection_properties",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  CurrentSupply = "current_supply",
  /** column name */
  Description = "description",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  MaxSupply = "max_supply",
  /** column name */
  MutableDescription = "mutable_description",
  /** column name */
  MutableUri = "mutable_uri",
  /** column name */
  TableHandleV1 = "table_handle_v1",
  /** column name */
  TokenStandard = "token_standard",
  /** column name */
  TotalMintedV2 = "total_minted_v2",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  Uri = "uri",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

export type CollectionsV2Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<CollectionsV2AppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<CollectionsV2DeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<CollectionsV2DeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<CollectionsV2DeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CollectionsV2IncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<CollectionsV2PrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CollectionsV2SetInput>;
  /** filter the rows which have to be updated */
  where: CollectionsV2BoolExp;
};

/** aggregate var_pop on columns */
export type CollectionsV2VarPopFields = {
  current_supply?: Maybe<Scalars["Float"]["output"]>;
  max_supply?: Maybe<Scalars["Float"]["output"]>;
  total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CollectionsV2VarSampFields = {
  current_supply?: Maybe<Scalars["Float"]["output"]>;
  max_supply?: Maybe<Scalars["Float"]["output"]>;
  total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CollectionsV2VarianceFields = {
  current_supply?: Maybe<Scalars["Float"]["output"]>;
  max_supply?: Maybe<Scalars["Float"]["output"]>;
  total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "current_ans_lookup" */
export type CurrentAnsLookup = {
  domain: Scalars["String"]["output"];
  expiration_timestamp: Scalars["timestamp"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  is_deleted: Scalars["Boolean"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain: Scalars["String"]["output"];
  token_name: Scalars["String"]["output"];
};

/** aggregated selection of "current_ans_lookup" */
export type CurrentAnsLookupAggregate = {
  aggregate?: Maybe<CurrentAnsLookupAggregateFields>;
  nodes: Array<CurrentAnsLookup>;
};

/** aggregate fields of "current_ans_lookup" */
export type CurrentAnsLookupAggregateFields = {
  avg?: Maybe<CurrentAnsLookupAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentAnsLookupMaxFields>;
  min?: Maybe<CurrentAnsLookupMinFields>;
  stddev?: Maybe<CurrentAnsLookupStddevFields>;
  stddev_pop?: Maybe<CurrentAnsLookupStddevPopFields>;
  stddev_samp?: Maybe<CurrentAnsLookupStddevSampFields>;
  sum?: Maybe<CurrentAnsLookupSumFields>;
  var_pop?: Maybe<CurrentAnsLookupVarPopFields>;
  var_samp?: Maybe<CurrentAnsLookupVarSampFields>;
  variance?: Maybe<CurrentAnsLookupVarianceFields>;
};

/** aggregate fields of "current_ans_lookup" */
export type CurrentAnsLookupAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentAnsLookupSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentAnsLookupAvgFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_ans_lookup". All fields are combined with a logical 'AND'. */
export type CurrentAnsLookupBoolExp = {
  _and?: InputMaybe<Array<CurrentAnsLookupBoolExp>>;
  _not?: InputMaybe<CurrentAnsLookupBoolExp>;
  _or?: InputMaybe<Array<CurrentAnsLookupBoolExp>>;
  domain?: InputMaybe<StringComparisonExp>;
  expiration_timestamp?: InputMaybe<TimestampComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_deleted?: InputMaybe<BooleanComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  registered_address?: InputMaybe<StringComparisonExp>;
  subdomain?: InputMaybe<StringComparisonExp>;
  token_name?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "current_ans_lookup" */
export enum CurrentAnsLookupConstraint {
  /** unique or primary key constraint on columns "domain", "subdomain" */
  CurrentAnsLookupPkey = "current_ans_lookup_pkey",
}

/** input type for incrementing numeric columns in table "current_ans_lookup" */
export type CurrentAnsLookupIncInput = {
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "current_ans_lookup" */
export type CurrentAnsLookupInsertInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type CurrentAnsLookupMaxFields = {
  domain?: Maybe<Scalars["String"]["output"]>;
  expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentAnsLookupMinFields = {
  domain?: Maybe<Scalars["String"]["output"]>;
  expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "current_ans_lookup" */
export type CurrentAnsLookupMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentAnsLookup>;
};

/** on_conflict condition type for table "current_ans_lookup" */
export type CurrentAnsLookupOnConflict = {
  constraint: CurrentAnsLookupConstraint;
  update_columns?: Array<CurrentAnsLookupUpdateColumn>;
  where?: InputMaybe<CurrentAnsLookupBoolExp>;
};

/** Ordering options when selecting data from "current_ans_lookup". */
export type CurrentAnsLookupOrderBy = {
  domain?: InputMaybe<OrderBy>;
  expiration_timestamp?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_deleted?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  registered_address?: InputMaybe<OrderBy>;
  subdomain?: InputMaybe<OrderBy>;
  token_name?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: current_ans_lookup */
export type CurrentAnsLookupPkColumnsInput = {
  domain: Scalars["String"]["input"];
  subdomain: Scalars["String"]["input"];
};

/** select columns of table "current_ans_lookup" */
export enum CurrentAnsLookupSelectColumn {
  /** column name */
  Domain = "domain",
  /** column name */
  ExpirationTimestamp = "expiration_timestamp",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  RegisteredAddress = "registered_address",
  /** column name */
  Subdomain = "subdomain",
  /** column name */
  TokenName = "token_name",
}

/** input type for updating data in table "current_ans_lookup" */
export type CurrentAnsLookupSetInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentAnsLookupStddevFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentAnsLookupStddevPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentAnsLookupStddevSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_ans_lookup" */
export type CurrentAnsLookupStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentAnsLookupStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentAnsLookupStreamCursorValueInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentAnsLookupSumFields = {
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "current_ans_lookup" */
export enum CurrentAnsLookupUpdateColumn {
  /** column name */
  Domain = "domain",
  /** column name */
  ExpirationTimestamp = "expiration_timestamp",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  RegisteredAddress = "registered_address",
  /** column name */
  Subdomain = "subdomain",
  /** column name */
  TokenName = "token_name",
}

export type CurrentAnsLookupUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentAnsLookupIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentAnsLookupSetInput>;
  /** filter the rows which have to be updated */
  where: CurrentAnsLookupBoolExp;
};

/** columns and relationships of "current_ans_lookup_v2" */
export type CurrentAnsLookupV2 = {
  domain: Scalars["String"]["output"];
  expiration_timestamp: Scalars["timestamp"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  is_deleted: Scalars["Boolean"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain: Scalars["String"]["output"];
  subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  token_standard: Scalars["String"]["output"];
};

/** aggregated selection of "current_ans_lookup_v2" */
export type CurrentAnsLookupV2Aggregate = {
  aggregate?: Maybe<CurrentAnsLookupV2AggregateFields>;
  nodes: Array<CurrentAnsLookupV2>;
};

/** aggregate fields of "current_ans_lookup_v2" */
export type CurrentAnsLookupV2AggregateFields = {
  avg?: Maybe<CurrentAnsLookupV2AvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentAnsLookupV2MaxFields>;
  min?: Maybe<CurrentAnsLookupV2MinFields>;
  stddev?: Maybe<CurrentAnsLookupV2StddevFields>;
  stddev_pop?: Maybe<CurrentAnsLookupV2StddevPopFields>;
  stddev_samp?: Maybe<CurrentAnsLookupV2StddevSampFields>;
  sum?: Maybe<CurrentAnsLookupV2SumFields>;
  var_pop?: Maybe<CurrentAnsLookupV2VarPopFields>;
  var_samp?: Maybe<CurrentAnsLookupV2VarSampFields>;
  variance?: Maybe<CurrentAnsLookupV2VarianceFields>;
};

/** aggregate fields of "current_ans_lookup_v2" */
export type CurrentAnsLookupV2AggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentAnsLookupV2SelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentAnsLookupV2AvgFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_ans_lookup_v2". All fields are combined with a logical 'AND'. */
export type CurrentAnsLookupV2BoolExp = {
  _and?: InputMaybe<Array<CurrentAnsLookupV2BoolExp>>;
  _not?: InputMaybe<CurrentAnsLookupV2BoolExp>;
  _or?: InputMaybe<Array<CurrentAnsLookupV2BoolExp>>;
  domain?: InputMaybe<StringComparisonExp>;
  expiration_timestamp?: InputMaybe<TimestampComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_deleted?: InputMaybe<BooleanComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  registered_address?: InputMaybe<StringComparisonExp>;
  subdomain?: InputMaybe<StringComparisonExp>;
  subdomain_expiration_policy?: InputMaybe<BigintComparisonExp>;
  token_name?: InputMaybe<StringComparisonExp>;
  token_standard?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "current_ans_lookup_v2" */
export enum CurrentAnsLookupV2Constraint {
  /** unique or primary key constraint on columns "domain", "token_standard", "subdomain" */
  CurrentAnsLookupV2Pkey = "current_ans_lookup_v2_pkey",
}

/** input type for incrementing numeric columns in table "current_ans_lookup_v2" */
export type CurrentAnsLookupV2IncInput = {
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  subdomain_expiration_policy?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "current_ans_lookup_v2" */
export type CurrentAnsLookupV2InsertInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  subdomain_expiration_policy?: InputMaybe<Scalars["bigint"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type CurrentAnsLookupV2MaxFields = {
  domain?: Maybe<Scalars["String"]["output"]>;
  expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain?: Maybe<Scalars["String"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentAnsLookupV2MinFields = {
  domain?: Maybe<Scalars["String"]["output"]>;
  expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain?: Maybe<Scalars["String"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "current_ans_lookup_v2" */
export type CurrentAnsLookupV2MutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentAnsLookupV2>;
};

/** on_conflict condition type for table "current_ans_lookup_v2" */
export type CurrentAnsLookupV2OnConflict = {
  constraint: CurrentAnsLookupV2Constraint;
  update_columns?: Array<CurrentAnsLookupV2UpdateColumn>;
  where?: InputMaybe<CurrentAnsLookupV2BoolExp>;
};

/** Ordering options when selecting data from "current_ans_lookup_v2". */
export type CurrentAnsLookupV2OrderBy = {
  domain?: InputMaybe<OrderBy>;
  expiration_timestamp?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_deleted?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  registered_address?: InputMaybe<OrderBy>;
  subdomain?: InputMaybe<OrderBy>;
  subdomain_expiration_policy?: InputMaybe<OrderBy>;
  token_name?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: current_ans_lookup_v2 */
export type CurrentAnsLookupV2PkColumnsInput = {
  domain: Scalars["String"]["input"];
  subdomain: Scalars["String"]["input"];
  token_standard: Scalars["String"]["input"];
};

/** select columns of table "current_ans_lookup_v2" */
export enum CurrentAnsLookupV2SelectColumn {
  /** column name */
  Domain = "domain",
  /** column name */
  ExpirationTimestamp = "expiration_timestamp",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  RegisteredAddress = "registered_address",
  /** column name */
  Subdomain = "subdomain",
  /** column name */
  SubdomainExpirationPolicy = "subdomain_expiration_policy",
  /** column name */
  TokenName = "token_name",
  /** column name */
  TokenStandard = "token_standard",
}

/** input type for updating data in table "current_ans_lookup_v2" */
export type CurrentAnsLookupV2SetInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  subdomain_expiration_policy?: InputMaybe<Scalars["bigint"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentAnsLookupV2StddevFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentAnsLookupV2StddevPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentAnsLookupV2StddevSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_ans_lookup_v2" */
export type CurrentAnsLookupV2StreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentAnsLookupV2StreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentAnsLookupV2StreamCursorValueInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  subdomain_expiration_policy?: InputMaybe<Scalars["bigint"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentAnsLookupV2SumFields = {
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "current_ans_lookup_v2" */
export enum CurrentAnsLookupV2UpdateColumn {
  /** column name */
  Domain = "domain",
  /** column name */
  ExpirationTimestamp = "expiration_timestamp",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  RegisteredAddress = "registered_address",
  /** column name */
  Subdomain = "subdomain",
  /** column name */
  SubdomainExpirationPolicy = "subdomain_expiration_policy",
  /** column name */
  TokenName = "token_name",
  /** column name */
  TokenStandard = "token_standard",
}

export type CurrentAnsLookupV2Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentAnsLookupV2IncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentAnsLookupV2SetInput>;
  /** filter the rows which have to be updated */
  where: CurrentAnsLookupV2BoolExp;
};

/** aggregate var_pop on columns */
export type CurrentAnsLookupV2VarPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentAnsLookupV2VarSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentAnsLookupV2VarianceFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_pop on columns */
export type CurrentAnsLookupVarPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentAnsLookupVarSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentAnsLookupVarianceFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "current_ans_primary_name" */
export type CurrentAnsPrimaryName = {
  domain?: Maybe<Scalars["String"]["output"]>;
  inserted_at: Scalars["timestamp"]["output"];
  is_deleted: Scalars["Boolean"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  registered_address: Scalars["String"]["output"];
  subdomain?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
};

/** aggregated selection of "current_ans_primary_name" */
export type CurrentAnsPrimaryNameAggregate = {
  aggregate?: Maybe<CurrentAnsPrimaryNameAggregateFields>;
  nodes: Array<CurrentAnsPrimaryName>;
};

/** aggregate fields of "current_ans_primary_name" */
export type CurrentAnsPrimaryNameAggregateFields = {
  avg?: Maybe<CurrentAnsPrimaryNameAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentAnsPrimaryNameMaxFields>;
  min?: Maybe<CurrentAnsPrimaryNameMinFields>;
  stddev?: Maybe<CurrentAnsPrimaryNameStddevFields>;
  stddev_pop?: Maybe<CurrentAnsPrimaryNameStddevPopFields>;
  stddev_samp?: Maybe<CurrentAnsPrimaryNameStddevSampFields>;
  sum?: Maybe<CurrentAnsPrimaryNameSumFields>;
  var_pop?: Maybe<CurrentAnsPrimaryNameVarPopFields>;
  var_samp?: Maybe<CurrentAnsPrimaryNameVarSampFields>;
  variance?: Maybe<CurrentAnsPrimaryNameVarianceFields>;
};

/** aggregate fields of "current_ans_primary_name" */
export type CurrentAnsPrimaryNameAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentAnsPrimaryNameSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentAnsPrimaryNameAvgFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_ans_primary_name". All fields are combined with a logical 'AND'. */
export type CurrentAnsPrimaryNameBoolExp = {
  _and?: InputMaybe<Array<CurrentAnsPrimaryNameBoolExp>>;
  _not?: InputMaybe<CurrentAnsPrimaryNameBoolExp>;
  _or?: InputMaybe<Array<CurrentAnsPrimaryNameBoolExp>>;
  domain?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_deleted?: InputMaybe<BooleanComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  registered_address?: InputMaybe<StringComparisonExp>;
  subdomain?: InputMaybe<StringComparisonExp>;
  token_name?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "current_ans_primary_name" */
export enum CurrentAnsPrimaryNameConstraint {
  /** unique or primary key constraint on columns "registered_address" */
  CurrentAnsPrimaryNamePkey = "current_ans_primary_name_pkey",
}

/** input type for incrementing numeric columns in table "current_ans_primary_name" */
export type CurrentAnsPrimaryNameIncInput = {
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "current_ans_primary_name" */
export type CurrentAnsPrimaryNameInsertInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type CurrentAnsPrimaryNameMaxFields = {
  domain?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentAnsPrimaryNameMinFields = {
  domain?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "current_ans_primary_name" */
export type CurrentAnsPrimaryNameMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentAnsPrimaryName>;
};

/** on_conflict condition type for table "current_ans_primary_name" */
export type CurrentAnsPrimaryNameOnConflict = {
  constraint: CurrentAnsPrimaryNameConstraint;
  update_columns?: Array<CurrentAnsPrimaryNameUpdateColumn>;
  where?: InputMaybe<CurrentAnsPrimaryNameBoolExp>;
};

/** Ordering options when selecting data from "current_ans_primary_name". */
export type CurrentAnsPrimaryNameOrderBy = {
  domain?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_deleted?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  registered_address?: InputMaybe<OrderBy>;
  subdomain?: InputMaybe<OrderBy>;
  token_name?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: current_ans_primary_name */
export type CurrentAnsPrimaryNamePkColumnsInput = {
  registered_address: Scalars["String"]["input"];
};

/** select columns of table "current_ans_primary_name" */
export enum CurrentAnsPrimaryNameSelectColumn {
  /** column name */
  Domain = "domain",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  RegisteredAddress = "registered_address",
  /** column name */
  Subdomain = "subdomain",
  /** column name */
  TokenName = "token_name",
}

/** input type for updating data in table "current_ans_primary_name" */
export type CurrentAnsPrimaryNameSetInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentAnsPrimaryNameStddevFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentAnsPrimaryNameStddevPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentAnsPrimaryNameStddevSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_ans_primary_name" */
export type CurrentAnsPrimaryNameStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentAnsPrimaryNameStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentAnsPrimaryNameStreamCursorValueInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentAnsPrimaryNameSumFields = {
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "current_ans_primary_name" */
export enum CurrentAnsPrimaryNameUpdateColumn {
  /** column name */
  Domain = "domain",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  RegisteredAddress = "registered_address",
  /** column name */
  Subdomain = "subdomain",
  /** column name */
  TokenName = "token_name",
}

export type CurrentAnsPrimaryNameUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentAnsPrimaryNameIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentAnsPrimaryNameSetInput>;
  /** filter the rows which have to be updated */
  where: CurrentAnsPrimaryNameBoolExp;
};

/** columns and relationships of "current_ans_primary_name_v2" */
export type CurrentAnsPrimaryNameV2 = {
  domain?: Maybe<Scalars["String"]["output"]>;
  inserted_at: Scalars["timestamp"]["output"];
  is_deleted: Scalars["Boolean"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  registered_address: Scalars["String"]["output"];
  subdomain?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  token_standard: Scalars["String"]["output"];
};

/** aggregated selection of "current_ans_primary_name_v2" */
export type CurrentAnsPrimaryNameV2Aggregate = {
  aggregate?: Maybe<CurrentAnsPrimaryNameV2AggregateFields>;
  nodes: Array<CurrentAnsPrimaryNameV2>;
};

/** aggregate fields of "current_ans_primary_name_v2" */
export type CurrentAnsPrimaryNameV2AggregateFields = {
  avg?: Maybe<CurrentAnsPrimaryNameV2AvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentAnsPrimaryNameV2MaxFields>;
  min?: Maybe<CurrentAnsPrimaryNameV2MinFields>;
  stddev?: Maybe<CurrentAnsPrimaryNameV2StddevFields>;
  stddev_pop?: Maybe<CurrentAnsPrimaryNameV2StddevPopFields>;
  stddev_samp?: Maybe<CurrentAnsPrimaryNameV2StddevSampFields>;
  sum?: Maybe<CurrentAnsPrimaryNameV2SumFields>;
  var_pop?: Maybe<CurrentAnsPrimaryNameV2VarPopFields>;
  var_samp?: Maybe<CurrentAnsPrimaryNameV2VarSampFields>;
  variance?: Maybe<CurrentAnsPrimaryNameV2VarianceFields>;
};

/** aggregate fields of "current_ans_primary_name_v2" */
export type CurrentAnsPrimaryNameV2AggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentAnsPrimaryNameV2SelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentAnsPrimaryNameV2AvgFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_ans_primary_name_v2". All fields are combined with a logical 'AND'. */
export type CurrentAnsPrimaryNameV2BoolExp = {
  _and?: InputMaybe<Array<CurrentAnsPrimaryNameV2BoolExp>>;
  _not?: InputMaybe<CurrentAnsPrimaryNameV2BoolExp>;
  _or?: InputMaybe<Array<CurrentAnsPrimaryNameV2BoolExp>>;
  domain?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_deleted?: InputMaybe<BooleanComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  registered_address?: InputMaybe<StringComparisonExp>;
  subdomain?: InputMaybe<StringComparisonExp>;
  token_name?: InputMaybe<StringComparisonExp>;
  token_standard?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "current_ans_primary_name_v2" */
export enum CurrentAnsPrimaryNameV2Constraint {
  /** unique or primary key constraint on columns "token_standard", "registered_address" */
  CurrentAnsPrimaryNameV2Pkey = "current_ans_primary_name_v2_pkey",
}

/** input type for incrementing numeric columns in table "current_ans_primary_name_v2" */
export type CurrentAnsPrimaryNameV2IncInput = {
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "current_ans_primary_name_v2" */
export type CurrentAnsPrimaryNameV2InsertInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type CurrentAnsPrimaryNameV2MaxFields = {
  domain?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentAnsPrimaryNameV2MinFields = {
  domain?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "current_ans_primary_name_v2" */
export type CurrentAnsPrimaryNameV2MutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentAnsPrimaryNameV2>;
};

/** on_conflict condition type for table "current_ans_primary_name_v2" */
export type CurrentAnsPrimaryNameV2OnConflict = {
  constraint: CurrentAnsPrimaryNameV2Constraint;
  update_columns?: Array<CurrentAnsPrimaryNameV2UpdateColumn>;
  where?: InputMaybe<CurrentAnsPrimaryNameV2BoolExp>;
};

/** Ordering options when selecting data from "current_ans_primary_name_v2". */
export type CurrentAnsPrimaryNameV2OrderBy = {
  domain?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_deleted?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  registered_address?: InputMaybe<OrderBy>;
  subdomain?: InputMaybe<OrderBy>;
  token_name?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: current_ans_primary_name_v2 */
export type CurrentAnsPrimaryNameV2PkColumnsInput = {
  registered_address: Scalars["String"]["input"];
  token_standard: Scalars["String"]["input"];
};

/** select columns of table "current_ans_primary_name_v2" */
export enum CurrentAnsPrimaryNameV2SelectColumn {
  /** column name */
  Domain = "domain",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  RegisteredAddress = "registered_address",
  /** column name */
  Subdomain = "subdomain",
  /** column name */
  TokenName = "token_name",
  /** column name */
  TokenStandard = "token_standard",
}

/** input type for updating data in table "current_ans_primary_name_v2" */
export type CurrentAnsPrimaryNameV2SetInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentAnsPrimaryNameV2StddevFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentAnsPrimaryNameV2StddevPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentAnsPrimaryNameV2StddevSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_ans_primary_name_v2" */
export type CurrentAnsPrimaryNameV2StreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentAnsPrimaryNameV2StreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentAnsPrimaryNameV2StreamCursorValueInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentAnsPrimaryNameV2SumFields = {
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "current_ans_primary_name_v2" */
export enum CurrentAnsPrimaryNameV2UpdateColumn {
  /** column name */
  Domain = "domain",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  RegisteredAddress = "registered_address",
  /** column name */
  Subdomain = "subdomain",
  /** column name */
  TokenName = "token_name",
  /** column name */
  TokenStandard = "token_standard",
}

export type CurrentAnsPrimaryNameV2Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentAnsPrimaryNameV2IncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentAnsPrimaryNameV2SetInput>;
  /** filter the rows which have to be updated */
  where: CurrentAnsPrimaryNameV2BoolExp;
};

/** aggregate var_pop on columns */
export type CurrentAnsPrimaryNameV2VarPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentAnsPrimaryNameV2VarSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentAnsPrimaryNameV2VarianceFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_pop on columns */
export type CurrentAnsPrimaryNameVarPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentAnsPrimaryNameVarSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentAnsPrimaryNameVarianceFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "current_cedra_names" */
export type CurrentCedraNames = {
  domain?: Maybe<Scalars["String"]["output"]>;
  domain_expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  domain_with_suffix?: Maybe<Scalars["String"]["output"]>;
  expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  is_active?: Maybe<Scalars["Boolean"]["output"]>;
  /** An object relationship */
  is_domain_owner?: Maybe<CurrentCedraNames>;
  is_primary?: Maybe<Scalars["Boolean"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain?: Maybe<Scalars["String"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
  token_data_id?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
};

/** aggregated selection of "current_cedra_names" */
export type CurrentCedraNamesAggregate = {
  aggregate?: Maybe<CurrentCedraNamesAggregateFields>;
  nodes: Array<CurrentCedraNames>;
};

export type CurrentCedraNamesAggregateBoolExp = {
  bool_and?: InputMaybe<CurrentCedraNamesAggregateBoolExpBoolAnd>;
  bool_or?: InputMaybe<CurrentCedraNamesAggregateBoolExpBoolOr>;
  count?: InputMaybe<CurrentCedraNamesAggregateBoolExpCount>;
};

export type CurrentCedraNamesAggregateBoolExpBoolAnd = {
  arguments: CurrentCedraNamesSelectColumnCurrentCedraNamesAggregateBoolExpBoolAndArgumentsColumns;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
  filter?: InputMaybe<CurrentCedraNamesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type CurrentCedraNamesAggregateBoolExpBoolOr = {
  arguments: CurrentCedraNamesSelectColumnCurrentCedraNamesAggregateBoolExpBoolOrArgumentsColumns;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
  filter?: InputMaybe<CurrentCedraNamesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type CurrentCedraNamesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
  filter?: InputMaybe<CurrentCedraNamesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "current_cedra_names" */
export type CurrentCedraNamesAggregateFields = {
  avg?: Maybe<CurrentCedraNamesAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentCedraNamesMaxFields>;
  min?: Maybe<CurrentCedraNamesMinFields>;
  stddev?: Maybe<CurrentCedraNamesStddevFields>;
  stddev_pop?: Maybe<CurrentCedraNamesStddevPopFields>;
  stddev_samp?: Maybe<CurrentCedraNamesStddevSampFields>;
  sum?: Maybe<CurrentCedraNamesSumFields>;
  var_pop?: Maybe<CurrentCedraNamesVarPopFields>;
  var_samp?: Maybe<CurrentCedraNamesVarSampFields>;
  variance?: Maybe<CurrentCedraNamesVarianceFields>;
};

/** aggregate fields of "current_cedra_names" */
export type CurrentCedraNamesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** order by aggregate values of table "current_cedra_names" */
export type CurrentCedraNamesAggregateOrderBy = {
  avg?: InputMaybe<CurrentCedraNamesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<CurrentCedraNamesMaxOrderBy>;
  min?: InputMaybe<CurrentCedraNamesMinOrderBy>;
  stddev?: InputMaybe<CurrentCedraNamesStddevOrderBy>;
  stddev_pop?: InputMaybe<CurrentCedraNamesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<CurrentCedraNamesStddevSampOrderBy>;
  sum?: InputMaybe<CurrentCedraNamesSumOrderBy>;
  var_pop?: InputMaybe<CurrentCedraNamesVarPopOrderBy>;
  var_samp?: InputMaybe<CurrentCedraNamesVarSampOrderBy>;
  variance?: InputMaybe<CurrentCedraNamesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "current_cedra_names" */
export type CurrentCedraNamesArrRelInsertInput = {
  data: Array<CurrentCedraNamesInsertInput>;
};

/** aggregate avg on columns */
export type CurrentCedraNamesAvgFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};

/** order by avg() on columns of table "current_cedra_names" */
export type CurrentCedraNamesAvgOrderBy = {
  last_transaction_version?: InputMaybe<OrderBy>;
  subdomain_expiration_policy?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "current_cedra_names". All fields are combined with a logical 'AND'. */
export type CurrentCedraNamesBoolExp = {
  _and?: InputMaybe<Array<CurrentCedraNamesBoolExp>>;
  _not?: InputMaybe<CurrentCedraNamesBoolExp>;
  _or?: InputMaybe<Array<CurrentCedraNamesBoolExp>>;
  domain?: InputMaybe<StringComparisonExp>;
  domain_expiration_timestamp?: InputMaybe<TimestampComparisonExp>;
  domain_with_suffix?: InputMaybe<StringComparisonExp>;
  expiration_timestamp?: InputMaybe<TimestampComparisonExp>;
  is_active?: InputMaybe<BooleanComparisonExp>;
  is_domain_owner?: InputMaybe<CurrentCedraNamesBoolExp>;
  is_primary?: InputMaybe<BooleanComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  owner_address?: InputMaybe<StringComparisonExp>;
  registered_address?: InputMaybe<StringComparisonExp>;
  subdomain?: InputMaybe<StringComparisonExp>;
  subdomain_expiration_policy?: InputMaybe<BigintComparisonExp>;
  token_data_id?: InputMaybe<StringComparisonExp>;
  token_name?: InputMaybe<StringComparisonExp>;
  token_standard?: InputMaybe<StringComparisonExp>;
};

/** input type for inserting data into table "current_cedra_names" */
export type CurrentCedraNamesInsertInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  domain_expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  domain_with_suffix?: InputMaybe<Scalars["String"]["input"]>;
  expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_active?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_domain_owner?: InputMaybe<CurrentCedraNamesObjRelInsertInput>;
  is_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  subdomain_expiration_policy?: InputMaybe<Scalars["bigint"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type CurrentCedraNamesMaxFields = {
  domain?: Maybe<Scalars["String"]["output"]>;
  domain_expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  domain_with_suffix?: Maybe<Scalars["String"]["output"]>;
  expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain?: Maybe<Scalars["String"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
  token_data_id?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
};

/** order by max() on columns of table "current_cedra_names" */
export type CurrentCedraNamesMaxOrderBy = {
  domain?: InputMaybe<OrderBy>;
  domain_expiration_timestamp?: InputMaybe<OrderBy>;
  domain_with_suffix?: InputMaybe<OrderBy>;
  expiration_timestamp?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  owner_address?: InputMaybe<OrderBy>;
  registered_address?: InputMaybe<OrderBy>;
  subdomain?: InputMaybe<OrderBy>;
  subdomain_expiration_policy?: InputMaybe<OrderBy>;
  token_data_id?: InputMaybe<OrderBy>;
  token_name?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type CurrentCedraNamesMinFields = {
  domain?: Maybe<Scalars["String"]["output"]>;
  domain_expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  domain_with_suffix?: Maybe<Scalars["String"]["output"]>;
  expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  registered_address?: Maybe<Scalars["String"]["output"]>;
  subdomain?: Maybe<Scalars["String"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
  token_data_id?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
};

/** order by min() on columns of table "current_cedra_names" */
export type CurrentCedraNamesMinOrderBy = {
  domain?: InputMaybe<OrderBy>;
  domain_expiration_timestamp?: InputMaybe<OrderBy>;
  domain_with_suffix?: InputMaybe<OrderBy>;
  expiration_timestamp?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  owner_address?: InputMaybe<OrderBy>;
  registered_address?: InputMaybe<OrderBy>;
  subdomain?: InputMaybe<OrderBy>;
  subdomain_expiration_policy?: InputMaybe<OrderBy>;
  token_data_id?: InputMaybe<OrderBy>;
  token_name?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
};

/** input type for inserting object relation for remote table "current_cedra_names" */
export type CurrentCedraNamesObjRelInsertInput = {
  data: CurrentCedraNamesInsertInput;
};

/** Ordering options when selecting data from "current_cedra_names". */
export type CurrentCedraNamesOrderBy = {
  domain?: InputMaybe<OrderBy>;
  domain_expiration_timestamp?: InputMaybe<OrderBy>;
  domain_with_suffix?: InputMaybe<OrderBy>;
  expiration_timestamp?: InputMaybe<OrderBy>;
  is_active?: InputMaybe<OrderBy>;
  is_domain_owner?: InputMaybe<CurrentCedraNamesOrderBy>;
  is_primary?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  owner_address?: InputMaybe<OrderBy>;
  registered_address?: InputMaybe<OrderBy>;
  subdomain?: InputMaybe<OrderBy>;
  subdomain_expiration_policy?: InputMaybe<OrderBy>;
  token_data_id?: InputMaybe<OrderBy>;
  token_name?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
};

/** select columns of table "current_cedra_names" */
export enum CurrentCedraNamesSelectColumn {
  /** column name */
  Domain = "domain",
  /** column name */
  DomainExpirationTimestamp = "domain_expiration_timestamp",
  /** column name */
  DomainWithSuffix = "domain_with_suffix",
  /** column name */
  ExpirationTimestamp = "expiration_timestamp",
  /** column name */
  IsActive = "is_active",
  /** column name */
  IsPrimary = "is_primary",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  RegisteredAddress = "registered_address",
  /** column name */
  Subdomain = "subdomain",
  /** column name */
  SubdomainExpirationPolicy = "subdomain_expiration_policy",
  /** column name */
  TokenDataId = "token_data_id",
  /** column name */
  TokenName = "token_name",
  /** column name */
  TokenStandard = "token_standard",
}

/** select "current_cedra_names_aggregate_bool_exp_bool_and_arguments_columns" columns of table "current_cedra_names" */
export enum CurrentCedraNamesSelectColumnCurrentCedraNamesAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  IsActive = "is_active",
  /** column name */
  IsPrimary = "is_primary",
}

/** select "current_cedra_names_aggregate_bool_exp_bool_or_arguments_columns" columns of table "current_cedra_names" */
export enum CurrentCedraNamesSelectColumnCurrentCedraNamesAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  IsActive = "is_active",
  /** column name */
  IsPrimary = "is_primary",
}

/** aggregate stddev on columns */
export type CurrentCedraNamesStddevFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};

/** order by stddev() on columns of table "current_cedra_names" */
export type CurrentCedraNamesStddevOrderBy = {
  last_transaction_version?: InputMaybe<OrderBy>;
  subdomain_expiration_policy?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type CurrentCedraNamesStddevPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};

/** order by stddev_pop() on columns of table "current_cedra_names" */
export type CurrentCedraNamesStddevPopOrderBy = {
  last_transaction_version?: InputMaybe<OrderBy>;
  subdomain_expiration_policy?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type CurrentCedraNamesStddevSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};

/** order by stddev_samp() on columns of table "current_cedra_names" */
export type CurrentCedraNamesStddevSampOrderBy = {
  last_transaction_version?: InputMaybe<OrderBy>;
  subdomain_expiration_policy?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "current_cedra_names" */
export type CurrentCedraNamesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentCedraNamesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentCedraNamesStreamCursorValueInput = {
  domain?: InputMaybe<Scalars["String"]["input"]>;
  domain_expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  domain_with_suffix?: InputMaybe<Scalars["String"]["input"]>;
  expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_active?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  registered_address?: InputMaybe<Scalars["String"]["input"]>;
  subdomain?: InputMaybe<Scalars["String"]["input"]>;
  subdomain_expiration_policy?: InputMaybe<Scalars["bigint"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentCedraNamesSumFields = {
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
};

/** order by sum() on columns of table "current_cedra_names" */
export type CurrentCedraNamesSumOrderBy = {
  last_transaction_version?: InputMaybe<OrderBy>;
  subdomain_expiration_policy?: InputMaybe<OrderBy>;
};

/** aggregate var_pop on columns */
export type CurrentCedraNamesVarPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};

/** order by var_pop() on columns of table "current_cedra_names" */
export type CurrentCedraNamesVarPopOrderBy = {
  last_transaction_version?: InputMaybe<OrderBy>;
  subdomain_expiration_policy?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type CurrentCedraNamesVarSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};

/** order by var_samp() on columns of table "current_cedra_names" */
export type CurrentCedraNamesVarSampOrderBy = {
  last_transaction_version?: InputMaybe<OrderBy>;
  subdomain_expiration_policy?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type CurrentCedraNamesVarianceFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};

/** order by variance() on columns of table "current_cedra_names" */
export type CurrentCedraNamesVarianceOrderBy = {
  last_transaction_version?: InputMaybe<OrderBy>;
  subdomain_expiration_policy?: InputMaybe<OrderBy>;
};

/** columns and relationships of "current_coin_balances" */
export type CurrentCoinBalances = {
  amount: Scalars["numeric"]["output"];
  coin_type: Scalars["String"]["output"];
  coin_type_hash: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  last_transaction_timestamp: Scalars["timestamp"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  owner_address: Scalars["String"]["output"];
};

/** aggregated selection of "current_coin_balances" */
export type CurrentCoinBalancesAggregate = {
  aggregate?: Maybe<CurrentCoinBalancesAggregateFields>;
  nodes: Array<CurrentCoinBalances>;
};

/** aggregate fields of "current_coin_balances" */
export type CurrentCoinBalancesAggregateFields = {
  avg?: Maybe<CurrentCoinBalancesAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentCoinBalancesMaxFields>;
  min?: Maybe<CurrentCoinBalancesMinFields>;
  stddev?: Maybe<CurrentCoinBalancesStddevFields>;
  stddev_pop?: Maybe<CurrentCoinBalancesStddevPopFields>;
  stddev_samp?: Maybe<CurrentCoinBalancesStddevSampFields>;
  sum?: Maybe<CurrentCoinBalancesSumFields>;
  var_pop?: Maybe<CurrentCoinBalancesVarPopFields>;
  var_samp?: Maybe<CurrentCoinBalancesVarSampFields>;
  variance?: Maybe<CurrentCoinBalancesVarianceFields>;
};

/** aggregate fields of "current_coin_balances" */
export type CurrentCoinBalancesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentCoinBalancesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentCoinBalancesAvgFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_coin_balances". All fields are combined with a logical 'AND'. */
export type CurrentCoinBalancesBoolExp = {
  _and?: InputMaybe<Array<CurrentCoinBalancesBoolExp>>;
  _not?: InputMaybe<CurrentCoinBalancesBoolExp>;
  _or?: InputMaybe<Array<CurrentCoinBalancesBoolExp>>;
  amount?: InputMaybe<NumericComparisonExp>;
  coin_type?: InputMaybe<StringComparisonExp>;
  coin_type_hash?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  owner_address?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "current_coin_balances" */
export enum CurrentCoinBalancesConstraint {
  /** unique or primary key constraint on columns "coin_type_hash", "owner_address" */
  CurrentCoinBalancesPkey = "current_coin_balances_pkey",
}

/** input type for incrementing numeric columns in table "current_coin_balances" */
export type CurrentCoinBalancesIncInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "current_coin_balances" */
export type CurrentCoinBalancesInsertInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  coin_type?: InputMaybe<Scalars["String"]["input"]>;
  coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type CurrentCoinBalancesMaxFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  coin_type?: Maybe<Scalars["String"]["output"]>;
  coin_type_hash?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentCoinBalancesMinFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  coin_type?: Maybe<Scalars["String"]["output"]>;
  coin_type_hash?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "current_coin_balances" */
export type CurrentCoinBalancesMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentCoinBalances>;
};

/** on_conflict condition type for table "current_coin_balances" */
export type CurrentCoinBalancesOnConflict = {
  constraint: CurrentCoinBalancesConstraint;
  update_columns?: Array<CurrentCoinBalancesUpdateColumn>;
  where?: InputMaybe<CurrentCoinBalancesBoolExp>;
};

/** Ordering options when selecting data from "current_coin_balances". */
export type CurrentCoinBalancesOrderBy = {
  amount?: InputMaybe<OrderBy>;
  coin_type?: InputMaybe<OrderBy>;
  coin_type_hash?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  last_transaction_timestamp?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  owner_address?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: current_coin_balances */
export type CurrentCoinBalancesPkColumnsInput = {
  coin_type_hash: Scalars["String"]["input"];
  owner_address: Scalars["String"]["input"];
};

/** select columns of table "current_coin_balances" */
export enum CurrentCoinBalancesSelectColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  CoinType = "coin_type",
  /** column name */
  CoinTypeHash = "coin_type_hash",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  OwnerAddress = "owner_address",
}

/** input type for updating data in table "current_coin_balances" */
export type CurrentCoinBalancesSetInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  coin_type?: InputMaybe<Scalars["String"]["input"]>;
  coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentCoinBalancesStddevFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentCoinBalancesStddevPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentCoinBalancesStddevSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_coin_balances" */
export type CurrentCoinBalancesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentCoinBalancesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentCoinBalancesStreamCursorValueInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  coin_type?: InputMaybe<Scalars["String"]["input"]>;
  coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentCoinBalancesSumFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "current_coin_balances" */
export enum CurrentCoinBalancesUpdateColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  CoinType = "coin_type",
  /** column name */
  CoinTypeHash = "coin_type_hash",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  OwnerAddress = "owner_address",
}

export type CurrentCoinBalancesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentCoinBalancesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentCoinBalancesSetInput>;
  /** filter the rows which have to be updated */
  where: CurrentCoinBalancesBoolExp;
};

/** aggregate var_pop on columns */
export type CurrentCoinBalancesVarPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentCoinBalancesVarSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentCoinBalancesVarianceFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "current_collection_datas" */
export type CurrentCollectionDatas = {
  collection_data_id_hash: Scalars["String"]["output"];
  collection_name: Scalars["String"]["output"];
  creator_address: Scalars["String"]["output"];
  description: Scalars["String"]["output"];
  description_mutable: Scalars["Boolean"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  last_transaction_timestamp: Scalars["timestamp"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  maximum: Scalars["numeric"]["output"];
  maximum_mutable: Scalars["Boolean"]["output"];
  metadata_uri: Scalars["String"]["output"];
  supply: Scalars["numeric"]["output"];
  table_handle: Scalars["String"]["output"];
  uri_mutable: Scalars["Boolean"]["output"];
};

/** aggregated selection of "current_collection_datas" */
export type CurrentCollectionDatasAggregate = {
  aggregate?: Maybe<CurrentCollectionDatasAggregateFields>;
  nodes: Array<CurrentCollectionDatas>;
};

/** aggregate fields of "current_collection_datas" */
export type CurrentCollectionDatasAggregateFields = {
  avg?: Maybe<CurrentCollectionDatasAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentCollectionDatasMaxFields>;
  min?: Maybe<CurrentCollectionDatasMinFields>;
  stddev?: Maybe<CurrentCollectionDatasStddevFields>;
  stddev_pop?: Maybe<CurrentCollectionDatasStddevPopFields>;
  stddev_samp?: Maybe<CurrentCollectionDatasStddevSampFields>;
  sum?: Maybe<CurrentCollectionDatasSumFields>;
  var_pop?: Maybe<CurrentCollectionDatasVarPopFields>;
  var_samp?: Maybe<CurrentCollectionDatasVarSampFields>;
  variance?: Maybe<CurrentCollectionDatasVarianceFields>;
};

/** aggregate fields of "current_collection_datas" */
export type CurrentCollectionDatasAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentCollectionDatasSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentCollectionDatasAvgFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_collection_datas". All fields are combined with a logical 'AND'. */
export type CurrentCollectionDatasBoolExp = {
  _and?: InputMaybe<Array<CurrentCollectionDatasBoolExp>>;
  _not?: InputMaybe<CurrentCollectionDatasBoolExp>;
  _or?: InputMaybe<Array<CurrentCollectionDatasBoolExp>>;
  collection_data_id_hash?: InputMaybe<StringComparisonExp>;
  collection_name?: InputMaybe<StringComparisonExp>;
  creator_address?: InputMaybe<StringComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  description_mutable?: InputMaybe<BooleanComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  maximum?: InputMaybe<NumericComparisonExp>;
  maximum_mutable?: InputMaybe<BooleanComparisonExp>;
  metadata_uri?: InputMaybe<StringComparisonExp>;
  supply?: InputMaybe<NumericComparisonExp>;
  table_handle?: InputMaybe<StringComparisonExp>;
  uri_mutable?: InputMaybe<BooleanComparisonExp>;
};

/** unique or primary key constraints on table "current_collection_datas" */
export enum CurrentCollectionDatasConstraint {
  /** unique or primary key constraint on columns "collection_data_id_hash" */
  CurrentCollectionDatasPkey = "current_collection_datas_pkey",
}

/** input type for incrementing numeric columns in table "current_collection_datas" */
export type CurrentCollectionDatasIncInput = {
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
};

/** input type for inserting data into table "current_collection_datas" */
export type CurrentCollectionDatasInsertInput = {
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate max on columns */
export type CurrentCollectionDatasMaxFields = {
  collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  description?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  maximum?: Maybe<Scalars["numeric"]["output"]>;
  metadata_uri?: Maybe<Scalars["String"]["output"]>;
  supply?: Maybe<Scalars["numeric"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentCollectionDatasMinFields = {
  collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  description?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  maximum?: Maybe<Scalars["numeric"]["output"]>;
  metadata_uri?: Maybe<Scalars["String"]["output"]>;
  supply?: Maybe<Scalars["numeric"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "current_collection_datas" */
export type CurrentCollectionDatasMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentCollectionDatas>;
};

/** on_conflict condition type for table "current_collection_datas" */
export type CurrentCollectionDatasOnConflict = {
  constraint: CurrentCollectionDatasConstraint;
  update_columns?: Array<CurrentCollectionDatasUpdateColumn>;
  where?: InputMaybe<CurrentCollectionDatasBoolExp>;
};

/** Ordering options when selecting data from "current_collection_datas". */
export type CurrentCollectionDatasOrderBy = {
  collection_data_id_hash?: InputMaybe<OrderBy>;
  collection_name?: InputMaybe<OrderBy>;
  creator_address?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  description_mutable?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  last_transaction_timestamp?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  maximum?: InputMaybe<OrderBy>;
  maximum_mutable?: InputMaybe<OrderBy>;
  metadata_uri?: InputMaybe<OrderBy>;
  supply?: InputMaybe<OrderBy>;
  table_handle?: InputMaybe<OrderBy>;
  uri_mutable?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: current_collection_datas */
export type CurrentCollectionDatasPkColumnsInput = {
  collection_data_id_hash: Scalars["String"]["input"];
};

/** select columns of table "current_collection_datas" */
export enum CurrentCollectionDatasSelectColumn {
  /** column name */
  CollectionDataIdHash = "collection_data_id_hash",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  Description = "description",
  /** column name */
  DescriptionMutable = "description_mutable",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  Maximum = "maximum",
  /** column name */
  MaximumMutable = "maximum_mutable",
  /** column name */
  MetadataUri = "metadata_uri",
  /** column name */
  Supply = "supply",
  /** column name */
  TableHandle = "table_handle",
  /** column name */
  UriMutable = "uri_mutable",
}

/** input type for updating data in table "current_collection_datas" */
export type CurrentCollectionDatasSetInput = {
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentCollectionDatasStddevFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentCollectionDatasStddevPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentCollectionDatasStddevSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_collection_datas" */
export type CurrentCollectionDatasStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentCollectionDatasStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentCollectionDatasStreamCursorValueInput = {
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentCollectionDatasSumFields = {
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  maximum?: Maybe<Scalars["numeric"]["output"]>;
  supply?: Maybe<Scalars["numeric"]["output"]>;
};

/** update columns of table "current_collection_datas" */
export enum CurrentCollectionDatasUpdateColumn {
  /** column name */
  CollectionDataIdHash = "collection_data_id_hash",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  Description = "description",
  /** column name */
  DescriptionMutable = "description_mutable",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  Maximum = "maximum",
  /** column name */
  MaximumMutable = "maximum_mutable",
  /** column name */
  MetadataUri = "metadata_uri",
  /** column name */
  Supply = "supply",
  /** column name */
  TableHandle = "table_handle",
  /** column name */
  UriMutable = "uri_mutable",
}

export type CurrentCollectionDatasUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentCollectionDatasIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentCollectionDatasSetInput>;
  /** filter the rows which have to be updated */
  where: CurrentCollectionDatasBoolExp;
};

/** aggregate var_pop on columns */
export type CurrentCollectionDatasVarPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentCollectionDatasVarSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentCollectionDatasVarianceFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "current_collection_ownership_v2_view" */
export type CurrentCollectionOwnershipV2View = {
  collection_id?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  collection_uri?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  /** An object relationship */
  current_collection?: Maybe<CurrentCollectionsV2>;
  distinct_tokens?: Maybe<Scalars["bigint"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  single_token_uri?: Maybe<Scalars["String"]["output"]>;
};

/** aggregated selection of "current_collection_ownership_v2_view" */
export type CurrentCollectionOwnershipV2ViewAggregate = {
  aggregate?: Maybe<CurrentCollectionOwnershipV2ViewAggregateFields>;
  nodes: Array<CurrentCollectionOwnershipV2View>;
};

/** aggregate fields of "current_collection_ownership_v2_view" */
export type CurrentCollectionOwnershipV2ViewAggregateFields = {
  avg?: Maybe<CurrentCollectionOwnershipV2ViewAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentCollectionOwnershipV2ViewMaxFields>;
  min?: Maybe<CurrentCollectionOwnershipV2ViewMinFields>;
  stddev?: Maybe<CurrentCollectionOwnershipV2ViewStddevFields>;
  stddev_pop?: Maybe<CurrentCollectionOwnershipV2ViewStddevPopFields>;
  stddev_samp?: Maybe<CurrentCollectionOwnershipV2ViewStddevSampFields>;
  sum?: Maybe<CurrentCollectionOwnershipV2ViewSumFields>;
  var_pop?: Maybe<CurrentCollectionOwnershipV2ViewVarPopFields>;
  var_samp?: Maybe<CurrentCollectionOwnershipV2ViewVarSampFields>;
  variance?: Maybe<CurrentCollectionOwnershipV2ViewVarianceFields>;
};

/** aggregate fields of "current_collection_ownership_v2_view" */
export type CurrentCollectionOwnershipV2ViewAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentCollectionOwnershipV2ViewAvgFields = {
  distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_collection_ownership_v2_view". All fields are combined with a logical 'AND'. */
export type CurrentCollectionOwnershipV2ViewBoolExp = {
  _and?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewBoolExp>>;
  _not?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;
  _or?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewBoolExp>>;
  collection_id?: InputMaybe<StringComparisonExp>;
  collection_name?: InputMaybe<StringComparisonExp>;
  collection_uri?: InputMaybe<StringComparisonExp>;
  creator_address?: InputMaybe<StringComparisonExp>;
  current_collection?: InputMaybe<CurrentCollectionsV2BoolExp>;
  distinct_tokens?: InputMaybe<BigintComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  owner_address?: InputMaybe<StringComparisonExp>;
  single_token_uri?: InputMaybe<StringComparisonExp>;
};

/** aggregate max on columns */
export type CurrentCollectionOwnershipV2ViewMaxFields = {
  collection_id?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  collection_uri?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  distinct_tokens?: Maybe<Scalars["bigint"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  single_token_uri?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentCollectionOwnershipV2ViewMinFields = {
  collection_id?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  collection_uri?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  distinct_tokens?: Maybe<Scalars["bigint"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  single_token_uri?: Maybe<Scalars["String"]["output"]>;
};

/** Ordering options when selecting data from "current_collection_ownership_v2_view". */
export type CurrentCollectionOwnershipV2ViewOrderBy = {
  collection_id?: InputMaybe<OrderBy>;
  collection_name?: InputMaybe<OrderBy>;
  collection_uri?: InputMaybe<OrderBy>;
  creator_address?: InputMaybe<OrderBy>;
  current_collection?: InputMaybe<CurrentCollectionsV2OrderBy>;
  distinct_tokens?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  owner_address?: InputMaybe<OrderBy>;
  single_token_uri?: InputMaybe<OrderBy>;
};

/** select columns of table "current_collection_ownership_v2_view" */
export enum CurrentCollectionOwnershipV2ViewSelectColumn {
  /** column name */
  CollectionId = "collection_id",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CollectionUri = "collection_uri",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  DistinctTokens = "distinct_tokens",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  SingleTokenUri = "single_token_uri",
}

/** aggregate stddev on columns */
export type CurrentCollectionOwnershipV2ViewStddevFields = {
  distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentCollectionOwnershipV2ViewStddevPopFields = {
  distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentCollectionOwnershipV2ViewStddevSampFields = {
  distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_collection_ownership_v2_view" */
export type CurrentCollectionOwnershipV2ViewStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentCollectionOwnershipV2ViewStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentCollectionOwnershipV2ViewStreamCursorValueInput = {
  collection_id?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  collection_uri?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  distinct_tokens?: InputMaybe<Scalars["bigint"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  single_token_uri?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentCollectionOwnershipV2ViewSumFields = {
  distinct_tokens?: Maybe<Scalars["bigint"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate var_pop on columns */
export type CurrentCollectionOwnershipV2ViewVarPopFields = {
  distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentCollectionOwnershipV2ViewVarSampFields = {
  distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentCollectionOwnershipV2ViewVarianceFields = {
  distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "current_collection_ownership_view" */
export type CurrentCollectionOwnershipView = {
  collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  distinct_tokens?: Maybe<Scalars["bigint"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
};

/** aggregated selection of "current_collection_ownership_view" */
export type CurrentCollectionOwnershipViewAggregate = {
  aggregate?: Maybe<CurrentCollectionOwnershipViewAggregateFields>;
  nodes: Array<CurrentCollectionOwnershipView>;
};

/** aggregate fields of "current_collection_ownership_view" */
export type CurrentCollectionOwnershipViewAggregateFields = {
  avg?: Maybe<CurrentCollectionOwnershipViewAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentCollectionOwnershipViewMaxFields>;
  min?: Maybe<CurrentCollectionOwnershipViewMinFields>;
  stddev?: Maybe<CurrentCollectionOwnershipViewStddevFields>;
  stddev_pop?: Maybe<CurrentCollectionOwnershipViewStddevPopFields>;
  stddev_samp?: Maybe<CurrentCollectionOwnershipViewStddevSampFields>;
  sum?: Maybe<CurrentCollectionOwnershipViewSumFields>;
  var_pop?: Maybe<CurrentCollectionOwnershipViewVarPopFields>;
  var_samp?: Maybe<CurrentCollectionOwnershipViewVarSampFields>;
  variance?: Maybe<CurrentCollectionOwnershipViewVarianceFields>;
};

/** aggregate fields of "current_collection_ownership_view" */
export type CurrentCollectionOwnershipViewAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentCollectionOwnershipViewSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentCollectionOwnershipViewAvgFields = {
  distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_collection_ownership_view". All fields are combined with a logical 'AND'. */
export type CurrentCollectionOwnershipViewBoolExp = {
  _and?: InputMaybe<Array<CurrentCollectionOwnershipViewBoolExp>>;
  _not?: InputMaybe<CurrentCollectionOwnershipViewBoolExp>;
  _or?: InputMaybe<Array<CurrentCollectionOwnershipViewBoolExp>>;
  collection_data_id_hash?: InputMaybe<StringComparisonExp>;
  collection_name?: InputMaybe<StringComparisonExp>;
  creator_address?: InputMaybe<StringComparisonExp>;
  distinct_tokens?: InputMaybe<BigintComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  owner_address?: InputMaybe<StringComparisonExp>;
};

/** aggregate max on columns */
export type CurrentCollectionOwnershipViewMaxFields = {
  collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  distinct_tokens?: Maybe<Scalars["bigint"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentCollectionOwnershipViewMinFields = {
  collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  distinct_tokens?: Maybe<Scalars["bigint"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
};

/** Ordering options when selecting data from "current_collection_ownership_view". */
export type CurrentCollectionOwnershipViewOrderBy = {
  collection_data_id_hash?: InputMaybe<OrderBy>;
  collection_name?: InputMaybe<OrderBy>;
  creator_address?: InputMaybe<OrderBy>;
  distinct_tokens?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  owner_address?: InputMaybe<OrderBy>;
};

/** select columns of table "current_collection_ownership_view" */
export enum CurrentCollectionOwnershipViewSelectColumn {
  /** column name */
  CollectionDataIdHash = "collection_data_id_hash",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  DistinctTokens = "distinct_tokens",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  OwnerAddress = "owner_address",
}

/** aggregate stddev on columns */
export type CurrentCollectionOwnershipViewStddevFields = {
  distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentCollectionOwnershipViewStddevPopFields = {
  distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentCollectionOwnershipViewStddevSampFields = {
  distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_collection_ownership_view" */
export type CurrentCollectionOwnershipViewStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentCollectionOwnershipViewStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentCollectionOwnershipViewStreamCursorValueInput = {
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  distinct_tokens?: InputMaybe<Scalars["bigint"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentCollectionOwnershipViewSumFields = {
  distinct_tokens?: Maybe<Scalars["bigint"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate var_pop on columns */
export type CurrentCollectionOwnershipViewVarPopFields = {
  distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentCollectionOwnershipViewVarSampFields = {
  distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentCollectionOwnershipViewVarianceFields = {
  distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "current_collections_v2" */
export type CurrentCollectionsV2 = {
  /** An object relationship */
  cdn_asset_uris?: Maybe<NftMetadataCrawlerParsedAssetUris>;
  collection_id: Scalars["String"]["output"];
  collection_name: Scalars["String"]["output"];
  collection_properties?: Maybe<Scalars["jsonb"]["output"]>;
  creator_address: Scalars["String"]["output"];
  current_supply: Scalars["numeric"]["output"];
  description: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  last_transaction_timestamp: Scalars["timestamp"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  max_supply?: Maybe<Scalars["numeric"]["output"]>;
  mutable_description?: Maybe<Scalars["Boolean"]["output"]>;
  mutable_uri?: Maybe<Scalars["Boolean"]["output"]>;
  table_handle_v1?: Maybe<Scalars["String"]["output"]>;
  token_standard: Scalars["String"]["output"];
  total_minted_v2?: Maybe<Scalars["numeric"]["output"]>;
  uri: Scalars["String"]["output"];
};

/** columns and relationships of "current_collections_v2" */
export type CurrentCollectionsV2CollectionPropertiesArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregated selection of "current_collections_v2" */
export type CurrentCollectionsV2Aggregate = {
  aggregate?: Maybe<CurrentCollectionsV2AggregateFields>;
  nodes: Array<CurrentCollectionsV2>;
};

/** aggregate fields of "current_collections_v2" */
export type CurrentCollectionsV2AggregateFields = {
  avg?: Maybe<CurrentCollectionsV2AvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentCollectionsV2MaxFields>;
  min?: Maybe<CurrentCollectionsV2MinFields>;
  stddev?: Maybe<CurrentCollectionsV2StddevFields>;
  stddev_pop?: Maybe<CurrentCollectionsV2StddevPopFields>;
  stddev_samp?: Maybe<CurrentCollectionsV2StddevSampFields>;
  sum?: Maybe<CurrentCollectionsV2SumFields>;
  var_pop?: Maybe<CurrentCollectionsV2VarPopFields>;
  var_samp?: Maybe<CurrentCollectionsV2VarSampFields>;
  variance?: Maybe<CurrentCollectionsV2VarianceFields>;
};

/** aggregate fields of "current_collections_v2" */
export type CurrentCollectionsV2AggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentCollectionsV2SelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type CurrentCollectionsV2AppendInput = {
  collection_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentCollectionsV2AvgFields = {
  current_supply?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  max_supply?: Maybe<Scalars["Float"]["output"]>;
  total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_collections_v2". All fields are combined with a logical 'AND'. */
export type CurrentCollectionsV2BoolExp = {
  _and?: InputMaybe<Array<CurrentCollectionsV2BoolExp>>;
  _not?: InputMaybe<CurrentCollectionsV2BoolExp>;
  _or?: InputMaybe<Array<CurrentCollectionsV2BoolExp>>;
  cdn_asset_uris?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;
  collection_id?: InputMaybe<StringComparisonExp>;
  collection_name?: InputMaybe<StringComparisonExp>;
  collection_properties?: InputMaybe<JsonbComparisonExp>;
  creator_address?: InputMaybe<StringComparisonExp>;
  current_supply?: InputMaybe<NumericComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  max_supply?: InputMaybe<NumericComparisonExp>;
  mutable_description?: InputMaybe<BooleanComparisonExp>;
  mutable_uri?: InputMaybe<BooleanComparisonExp>;
  table_handle_v1?: InputMaybe<StringComparisonExp>;
  token_standard?: InputMaybe<StringComparisonExp>;
  total_minted_v2?: InputMaybe<NumericComparisonExp>;
  uri?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "current_collections_v2" */
export enum CurrentCollectionsV2Constraint {
  /** unique or primary key constraint on columns "collection_id" */
  CurrentCollectionsV2Pkey = "current_collections_v2_pkey",
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type CurrentCollectionsV2DeleteAtPathInput = {
  collection_properties?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type CurrentCollectionsV2DeleteElemInput = {
  collection_properties?: InputMaybe<Scalars["Int"]["input"]>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type CurrentCollectionsV2DeleteKeyInput = {
  collection_properties?: InputMaybe<Scalars["String"]["input"]>;
};

/** input type for incrementing numeric columns in table "current_collections_v2" */
export type CurrentCollectionsV2IncInput = {
  current_supply?: InputMaybe<Scalars["numeric"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  max_supply?: InputMaybe<Scalars["numeric"]["input"]>;
  total_minted_v2?: InputMaybe<Scalars["numeric"]["input"]>;
};

/** input type for inserting data into table "current_collections_v2" */
export type CurrentCollectionsV2InsertInput = {
  cdn_asset_uris?: InputMaybe<NftMetadataCrawlerParsedAssetUrisObjRelInsertInput>;
  collection_id?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  collection_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  current_supply?: InputMaybe<Scalars["numeric"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  max_supply?: InputMaybe<Scalars["numeric"]["input"]>;
  mutable_description?: InputMaybe<Scalars["Boolean"]["input"]>;
  mutable_uri?: InputMaybe<Scalars["Boolean"]["input"]>;
  table_handle_v1?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  total_minted_v2?: InputMaybe<Scalars["numeric"]["input"]>;
  uri?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type CurrentCollectionsV2MaxFields = {
  collection_id?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  current_supply?: Maybe<Scalars["numeric"]["output"]>;
  description?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  max_supply?: Maybe<Scalars["numeric"]["output"]>;
  table_handle_v1?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
  total_minted_v2?: Maybe<Scalars["numeric"]["output"]>;
  uri?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentCollectionsV2MinFields = {
  collection_id?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  current_supply?: Maybe<Scalars["numeric"]["output"]>;
  description?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  max_supply?: Maybe<Scalars["numeric"]["output"]>;
  table_handle_v1?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
  total_minted_v2?: Maybe<Scalars["numeric"]["output"]>;
  uri?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "current_collections_v2" */
export type CurrentCollectionsV2MutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentCollectionsV2>;
};

/** input type for inserting object relation for remote table "current_collections_v2" */
export type CurrentCollectionsV2ObjRelInsertInput = {
  data: CurrentCollectionsV2InsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<CurrentCollectionsV2OnConflict>;
};

/** on_conflict condition type for table "current_collections_v2" */
export type CurrentCollectionsV2OnConflict = {
  constraint: CurrentCollectionsV2Constraint;
  update_columns?: Array<CurrentCollectionsV2UpdateColumn>;
  where?: InputMaybe<CurrentCollectionsV2BoolExp>;
};

/** Ordering options when selecting data from "current_collections_v2". */
export type CurrentCollectionsV2OrderBy = {
  cdn_asset_uris?: InputMaybe<NftMetadataCrawlerParsedAssetUrisOrderBy>;
  collection_id?: InputMaybe<OrderBy>;
  collection_name?: InputMaybe<OrderBy>;
  collection_properties?: InputMaybe<OrderBy>;
  creator_address?: InputMaybe<OrderBy>;
  current_supply?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  last_transaction_timestamp?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  max_supply?: InputMaybe<OrderBy>;
  mutable_description?: InputMaybe<OrderBy>;
  mutable_uri?: InputMaybe<OrderBy>;
  table_handle_v1?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
  total_minted_v2?: InputMaybe<OrderBy>;
  uri?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: current_collections_v2 */
export type CurrentCollectionsV2PkColumnsInput = {
  collection_id: Scalars["String"]["input"];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type CurrentCollectionsV2PrependInput = {
  collection_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** select columns of table "current_collections_v2" */
export enum CurrentCollectionsV2SelectColumn {
  /** column name */
  CollectionId = "collection_id",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CollectionProperties = "collection_properties",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  CurrentSupply = "current_supply",
  /** column name */
  Description = "description",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  MaxSupply = "max_supply",
  /** column name */
  MutableDescription = "mutable_description",
  /** column name */
  MutableUri = "mutable_uri",
  /** column name */
  TableHandleV1 = "table_handle_v1",
  /** column name */
  TokenStandard = "token_standard",
  /** column name */
  TotalMintedV2 = "total_minted_v2",
  /** column name */
  Uri = "uri",
}

/** input type for updating data in table "current_collections_v2" */
export type CurrentCollectionsV2SetInput = {
  collection_id?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  collection_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  current_supply?: InputMaybe<Scalars["numeric"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  max_supply?: InputMaybe<Scalars["numeric"]["input"]>;
  mutable_description?: InputMaybe<Scalars["Boolean"]["input"]>;
  mutable_uri?: InputMaybe<Scalars["Boolean"]["input"]>;
  table_handle_v1?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  total_minted_v2?: InputMaybe<Scalars["numeric"]["input"]>;
  uri?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentCollectionsV2StddevFields = {
  current_supply?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  max_supply?: Maybe<Scalars["Float"]["output"]>;
  total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentCollectionsV2StddevPopFields = {
  current_supply?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  max_supply?: Maybe<Scalars["Float"]["output"]>;
  total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentCollectionsV2StddevSampFields = {
  current_supply?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  max_supply?: Maybe<Scalars["Float"]["output"]>;
  total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_collections_v2" */
export type CurrentCollectionsV2StreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentCollectionsV2StreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentCollectionsV2StreamCursorValueInput = {
  collection_id?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  collection_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  current_supply?: InputMaybe<Scalars["numeric"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  max_supply?: InputMaybe<Scalars["numeric"]["input"]>;
  mutable_description?: InputMaybe<Scalars["Boolean"]["input"]>;
  mutable_uri?: InputMaybe<Scalars["Boolean"]["input"]>;
  table_handle_v1?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  total_minted_v2?: InputMaybe<Scalars["numeric"]["input"]>;
  uri?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentCollectionsV2SumFields = {
  current_supply?: Maybe<Scalars["numeric"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  max_supply?: Maybe<Scalars["numeric"]["output"]>;
  total_minted_v2?: Maybe<Scalars["numeric"]["output"]>;
};

/** update columns of table "current_collections_v2" */
export enum CurrentCollectionsV2UpdateColumn {
  /** column name */
  CollectionId = "collection_id",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CollectionProperties = "collection_properties",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  CurrentSupply = "current_supply",
  /** column name */
  Description = "description",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  MaxSupply = "max_supply",
  /** column name */
  MutableDescription = "mutable_description",
  /** column name */
  MutableUri = "mutable_uri",
  /** column name */
  TableHandleV1 = "table_handle_v1",
  /** column name */
  TokenStandard = "token_standard",
  /** column name */
  TotalMintedV2 = "total_minted_v2",
  /** column name */
  Uri = "uri",
}

export type CurrentCollectionsV2Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<CurrentCollectionsV2AppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<CurrentCollectionsV2DeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<CurrentCollectionsV2DeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<CurrentCollectionsV2DeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentCollectionsV2IncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<CurrentCollectionsV2PrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentCollectionsV2SetInput>;
  /** filter the rows which have to be updated */
  where: CurrentCollectionsV2BoolExp;
};

/** aggregate var_pop on columns */
export type CurrentCollectionsV2VarPopFields = {
  current_supply?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  max_supply?: Maybe<Scalars["Float"]["output"]>;
  total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentCollectionsV2VarSampFields = {
  current_supply?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  max_supply?: Maybe<Scalars["Float"]["output"]>;
  total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentCollectionsV2VarianceFields = {
  current_supply?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  max_supply?: Maybe<Scalars["Float"]["output"]>;
  total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "current_delegated_staking_pool_balances" */
export type CurrentDelegatedStakingPoolBalances = {
  active_table_handle: Scalars["String"]["output"];
  inactive_table_handle: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  operator_commission_percentage: Scalars["numeric"]["output"];
  staking_pool_address: Scalars["String"]["output"];
  total_coins: Scalars["numeric"]["output"];
  total_shares: Scalars["numeric"]["output"];
};

/** aggregated selection of "current_delegated_staking_pool_balances" */
export type CurrentDelegatedStakingPoolBalancesAggregate = {
  aggregate?: Maybe<CurrentDelegatedStakingPoolBalancesAggregateFields>;
  nodes: Array<CurrentDelegatedStakingPoolBalances>;
};

/** aggregate fields of "current_delegated_staking_pool_balances" */
export type CurrentDelegatedStakingPoolBalancesAggregateFields = {
  avg?: Maybe<CurrentDelegatedStakingPoolBalancesAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentDelegatedStakingPoolBalancesMaxFields>;
  min?: Maybe<CurrentDelegatedStakingPoolBalancesMinFields>;
  stddev?: Maybe<CurrentDelegatedStakingPoolBalancesStddevFields>;
  stddev_pop?: Maybe<CurrentDelegatedStakingPoolBalancesStddevPopFields>;
  stddev_samp?: Maybe<CurrentDelegatedStakingPoolBalancesStddevSampFields>;
  sum?: Maybe<CurrentDelegatedStakingPoolBalancesSumFields>;
  var_pop?: Maybe<CurrentDelegatedStakingPoolBalancesVarPopFields>;
  var_samp?: Maybe<CurrentDelegatedStakingPoolBalancesVarSampFields>;
  variance?: Maybe<CurrentDelegatedStakingPoolBalancesVarianceFields>;
};

/** aggregate fields of "current_delegated_staking_pool_balances" */
export type CurrentDelegatedStakingPoolBalancesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentDelegatedStakingPoolBalancesAvgFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
  total_coins?: Maybe<Scalars["Float"]["output"]>;
  total_shares?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_delegated_staking_pool_balances". All fields are combined with a logical 'AND'. */
export type CurrentDelegatedStakingPoolBalancesBoolExp = {
  _and?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesBoolExp>>;
  _not?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;
  _or?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesBoolExp>>;
  active_table_handle?: InputMaybe<StringComparisonExp>;
  inactive_table_handle?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  operator_commission_percentage?: InputMaybe<NumericComparisonExp>;
  staking_pool_address?: InputMaybe<StringComparisonExp>;
  total_coins?: InputMaybe<NumericComparisonExp>;
  total_shares?: InputMaybe<NumericComparisonExp>;
};

/** unique or primary key constraints on table "current_delegated_staking_pool_balances" */
export enum CurrentDelegatedStakingPoolBalancesConstraint {
  /** unique or primary key constraint on columns "staking_pool_address" */
  CurrentDelegatedStakingPoolBalancesPkey = "current_delegated_staking_pool_balances_pkey",
}

/** input type for incrementing numeric columns in table "current_delegated_staking_pool_balances" */
export type CurrentDelegatedStakingPoolBalancesIncInput = {
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  operator_commission_percentage?: InputMaybe<Scalars["numeric"]["input"]>;
  total_coins?: InputMaybe<Scalars["numeric"]["input"]>;
  total_shares?: InputMaybe<Scalars["numeric"]["input"]>;
};

/** input type for inserting data into table "current_delegated_staking_pool_balances" */
export type CurrentDelegatedStakingPoolBalancesInsertInput = {
  active_table_handle?: InputMaybe<Scalars["String"]["input"]>;
  inactive_table_handle?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  operator_commission_percentage?: InputMaybe<Scalars["numeric"]["input"]>;
  staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
  total_coins?: InputMaybe<Scalars["numeric"]["input"]>;
  total_shares?: InputMaybe<Scalars["numeric"]["input"]>;
};

/** aggregate max on columns */
export type CurrentDelegatedStakingPoolBalancesMaxFields = {
  active_table_handle?: Maybe<Scalars["String"]["output"]>;
  inactive_table_handle?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  operator_commission_percentage?: Maybe<Scalars["numeric"]["output"]>;
  staking_pool_address?: Maybe<Scalars["String"]["output"]>;
  total_coins?: Maybe<Scalars["numeric"]["output"]>;
  total_shares?: Maybe<Scalars["numeric"]["output"]>;
};

/** aggregate min on columns */
export type CurrentDelegatedStakingPoolBalancesMinFields = {
  active_table_handle?: Maybe<Scalars["String"]["output"]>;
  inactive_table_handle?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  operator_commission_percentage?: Maybe<Scalars["numeric"]["output"]>;
  staking_pool_address?: Maybe<Scalars["String"]["output"]>;
  total_coins?: Maybe<Scalars["numeric"]["output"]>;
  total_shares?: Maybe<Scalars["numeric"]["output"]>;
};

/** response of any mutation on the table "current_delegated_staking_pool_balances" */
export type CurrentDelegatedStakingPoolBalancesMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentDelegatedStakingPoolBalances>;
};

/** input type for inserting object relation for remote table "current_delegated_staking_pool_balances" */
export type CurrentDelegatedStakingPoolBalancesObjRelInsertInput = {
  data: CurrentDelegatedStakingPoolBalancesInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<CurrentDelegatedStakingPoolBalancesOnConflict>;
};

/** on_conflict condition type for table "current_delegated_staking_pool_balances" */
export type CurrentDelegatedStakingPoolBalancesOnConflict = {
  constraint: CurrentDelegatedStakingPoolBalancesConstraint;
  update_columns?: Array<CurrentDelegatedStakingPoolBalancesUpdateColumn>;
  where?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;
};

/** Ordering options when selecting data from "current_delegated_staking_pool_balances". */
export type CurrentDelegatedStakingPoolBalancesOrderBy = {
  active_table_handle?: InputMaybe<OrderBy>;
  inactive_table_handle?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  operator_commission_percentage?: InputMaybe<OrderBy>;
  staking_pool_address?: InputMaybe<OrderBy>;
  total_coins?: InputMaybe<OrderBy>;
  total_shares?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: current_delegated_staking_pool_balances */
export type CurrentDelegatedStakingPoolBalancesPkColumnsInput = {
  staking_pool_address: Scalars["String"]["input"];
};

/** select columns of table "current_delegated_staking_pool_balances" */
export enum CurrentDelegatedStakingPoolBalancesSelectColumn {
  /** column name */
  ActiveTableHandle = "active_table_handle",
  /** column name */
  InactiveTableHandle = "inactive_table_handle",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  OperatorCommissionPercentage = "operator_commission_percentage",
  /** column name */
  StakingPoolAddress = "staking_pool_address",
  /** column name */
  TotalCoins = "total_coins",
  /** column name */
  TotalShares = "total_shares",
}

/** input type for updating data in table "current_delegated_staking_pool_balances" */
export type CurrentDelegatedStakingPoolBalancesSetInput = {
  active_table_handle?: InputMaybe<Scalars["String"]["input"]>;
  inactive_table_handle?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  operator_commission_percentage?: InputMaybe<Scalars["numeric"]["input"]>;
  staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
  total_coins?: InputMaybe<Scalars["numeric"]["input"]>;
  total_shares?: InputMaybe<Scalars["numeric"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentDelegatedStakingPoolBalancesStddevFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
  total_coins?: Maybe<Scalars["Float"]["output"]>;
  total_shares?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentDelegatedStakingPoolBalancesStddevPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
  total_coins?: Maybe<Scalars["Float"]["output"]>;
  total_shares?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentDelegatedStakingPoolBalancesStddevSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
  total_coins?: Maybe<Scalars["Float"]["output"]>;
  total_shares?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_delegated_staking_pool_balances" */
export type CurrentDelegatedStakingPoolBalancesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentDelegatedStakingPoolBalancesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentDelegatedStakingPoolBalancesStreamCursorValueInput = {
  active_table_handle?: InputMaybe<Scalars["String"]["input"]>;
  inactive_table_handle?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  operator_commission_percentage?: InputMaybe<Scalars["numeric"]["input"]>;
  staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
  total_coins?: InputMaybe<Scalars["numeric"]["input"]>;
  total_shares?: InputMaybe<Scalars["numeric"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentDelegatedStakingPoolBalancesSumFields = {
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  operator_commission_percentage?: Maybe<Scalars["numeric"]["output"]>;
  total_coins?: Maybe<Scalars["numeric"]["output"]>;
  total_shares?: Maybe<Scalars["numeric"]["output"]>;
};

/** update columns of table "current_delegated_staking_pool_balances" */
export enum CurrentDelegatedStakingPoolBalancesUpdateColumn {
  /** column name */
  ActiveTableHandle = "active_table_handle",
  /** column name */
  InactiveTableHandle = "inactive_table_handle",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  OperatorCommissionPercentage = "operator_commission_percentage",
  /** column name */
  StakingPoolAddress = "staking_pool_address",
  /** column name */
  TotalCoins = "total_coins",
  /** column name */
  TotalShares = "total_shares",
}

export type CurrentDelegatedStakingPoolBalancesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentDelegatedStakingPoolBalancesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentDelegatedStakingPoolBalancesSetInput>;
  /** filter the rows which have to be updated */
  where: CurrentDelegatedStakingPoolBalancesBoolExp;
};

/** aggregate var_pop on columns */
export type CurrentDelegatedStakingPoolBalancesVarPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
  total_coins?: Maybe<Scalars["Float"]["output"]>;
  total_shares?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentDelegatedStakingPoolBalancesVarSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
  total_coins?: Maybe<Scalars["Float"]["output"]>;
  total_shares?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentDelegatedStakingPoolBalancesVarianceFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
  total_coins?: Maybe<Scalars["Float"]["output"]>;
  total_shares?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "current_delegated_voter" */
export type CurrentDelegatedVoter = {
  delegation_pool_address: Scalars["String"]["output"];
  delegator_address: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  last_transaction_timestamp: Scalars["timestamp"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  pending_voter?: Maybe<Scalars["String"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
  voter?: Maybe<Scalars["String"]["output"]>;
};

/** aggregated selection of "current_delegated_voter" */
export type CurrentDelegatedVoterAggregate = {
  aggregate?: Maybe<CurrentDelegatedVoterAggregateFields>;
  nodes: Array<CurrentDelegatedVoter>;
};

/** aggregate fields of "current_delegated_voter" */
export type CurrentDelegatedVoterAggregateFields = {
  avg?: Maybe<CurrentDelegatedVoterAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentDelegatedVoterMaxFields>;
  min?: Maybe<CurrentDelegatedVoterMinFields>;
  stddev?: Maybe<CurrentDelegatedVoterStddevFields>;
  stddev_pop?: Maybe<CurrentDelegatedVoterStddevPopFields>;
  stddev_samp?: Maybe<CurrentDelegatedVoterStddevSampFields>;
  sum?: Maybe<CurrentDelegatedVoterSumFields>;
  var_pop?: Maybe<CurrentDelegatedVoterVarPopFields>;
  var_samp?: Maybe<CurrentDelegatedVoterVarSampFields>;
  variance?: Maybe<CurrentDelegatedVoterVarianceFields>;
};

/** aggregate fields of "current_delegated_voter" */
export type CurrentDelegatedVoterAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentDelegatedVoterSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentDelegatedVoterAvgFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_delegated_voter". All fields are combined with a logical 'AND'. */
export type CurrentDelegatedVoterBoolExp = {
  _and?: InputMaybe<Array<CurrentDelegatedVoterBoolExp>>;
  _not?: InputMaybe<CurrentDelegatedVoterBoolExp>;
  _or?: InputMaybe<Array<CurrentDelegatedVoterBoolExp>>;
  delegation_pool_address?: InputMaybe<StringComparisonExp>;
  delegator_address?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  pending_voter?: InputMaybe<StringComparisonExp>;
  table_handle?: InputMaybe<StringComparisonExp>;
  voter?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "current_delegated_voter" */
export enum CurrentDelegatedVoterConstraint {
  /** unique or primary key constraint on columns "delegator_address", "delegation_pool_address" */
  CurrentDelegatedVoterPkey = "current_delegated_voter_pkey",
}

/** input type for incrementing numeric columns in table "current_delegated_voter" */
export type CurrentDelegatedVoterIncInput = {
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "current_delegated_voter" */
export type CurrentDelegatedVoterInsertInput = {
  delegation_pool_address?: InputMaybe<Scalars["String"]["input"]>;
  delegator_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  pending_voter?: InputMaybe<Scalars["String"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  voter?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type CurrentDelegatedVoterMaxFields = {
  delegation_pool_address?: Maybe<Scalars["String"]["output"]>;
  delegator_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  pending_voter?: Maybe<Scalars["String"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
  voter?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentDelegatedVoterMinFields = {
  delegation_pool_address?: Maybe<Scalars["String"]["output"]>;
  delegator_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  pending_voter?: Maybe<Scalars["String"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
  voter?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "current_delegated_voter" */
export type CurrentDelegatedVoterMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentDelegatedVoter>;
};

/** on_conflict condition type for table "current_delegated_voter" */
export type CurrentDelegatedVoterOnConflict = {
  constraint: CurrentDelegatedVoterConstraint;
  update_columns?: Array<CurrentDelegatedVoterUpdateColumn>;
  where?: InputMaybe<CurrentDelegatedVoterBoolExp>;
};

/** Ordering options when selecting data from "current_delegated_voter". */
export type CurrentDelegatedVoterOrderBy = {
  delegation_pool_address?: InputMaybe<OrderBy>;
  delegator_address?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  last_transaction_timestamp?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  pending_voter?: InputMaybe<OrderBy>;
  table_handle?: InputMaybe<OrderBy>;
  voter?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: current_delegated_voter */
export type CurrentDelegatedVoterPkColumnsInput = {
  delegation_pool_address: Scalars["String"]["input"];
  delegator_address: Scalars["String"]["input"];
};

/** select columns of table "current_delegated_voter" */
export enum CurrentDelegatedVoterSelectColumn {
  /** column name */
  DelegationPoolAddress = "delegation_pool_address",
  /** column name */
  DelegatorAddress = "delegator_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  PendingVoter = "pending_voter",
  /** column name */
  TableHandle = "table_handle",
  /** column name */
  Voter = "voter",
}

/** input type for updating data in table "current_delegated_voter" */
export type CurrentDelegatedVoterSetInput = {
  delegation_pool_address?: InputMaybe<Scalars["String"]["input"]>;
  delegator_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  pending_voter?: InputMaybe<Scalars["String"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  voter?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentDelegatedVoterStddevFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentDelegatedVoterStddevPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentDelegatedVoterStddevSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_delegated_voter" */
export type CurrentDelegatedVoterStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentDelegatedVoterStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentDelegatedVoterStreamCursorValueInput = {
  delegation_pool_address?: InputMaybe<Scalars["String"]["input"]>;
  delegator_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  pending_voter?: InputMaybe<Scalars["String"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  voter?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentDelegatedVoterSumFields = {
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "current_delegated_voter" */
export enum CurrentDelegatedVoterUpdateColumn {
  /** column name */
  DelegationPoolAddress = "delegation_pool_address",
  /** column name */
  DelegatorAddress = "delegator_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  PendingVoter = "pending_voter",
  /** column name */
  TableHandle = "table_handle",
  /** column name */
  Voter = "voter",
}

export type CurrentDelegatedVoterUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentDelegatedVoterIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentDelegatedVoterSetInput>;
  /** filter the rows which have to be updated */
  where: CurrentDelegatedVoterBoolExp;
};

/** aggregate var_pop on columns */
export type CurrentDelegatedVoterVarPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentDelegatedVoterVarSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentDelegatedVoterVarianceFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "current_delegator_balances" */
export type CurrentDelegatorBalances = {
  /** An object relationship */
  current_pool_balance?: Maybe<CurrentDelegatedStakingPoolBalances>;
  delegator_address: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  parent_table_handle: Scalars["String"]["output"];
  pool_address: Scalars["String"]["output"];
  pool_type: Scalars["String"]["output"];
  shares: Scalars["numeric"]["output"];
  /** An object relationship */
  staking_pool_metadata?: Maybe<CurrentStakingPoolVoter>;
  table_handle: Scalars["String"]["output"];
};

/** aggregated selection of "current_delegator_balances" */
export type CurrentDelegatorBalancesAggregate = {
  aggregate?: Maybe<CurrentDelegatorBalancesAggregateFields>;
  nodes: Array<CurrentDelegatorBalances>;
};

/** aggregate fields of "current_delegator_balances" */
export type CurrentDelegatorBalancesAggregateFields = {
  avg?: Maybe<CurrentDelegatorBalancesAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentDelegatorBalancesMaxFields>;
  min?: Maybe<CurrentDelegatorBalancesMinFields>;
  stddev?: Maybe<CurrentDelegatorBalancesStddevFields>;
  stddev_pop?: Maybe<CurrentDelegatorBalancesStddevPopFields>;
  stddev_samp?: Maybe<CurrentDelegatorBalancesStddevSampFields>;
  sum?: Maybe<CurrentDelegatorBalancesSumFields>;
  var_pop?: Maybe<CurrentDelegatorBalancesVarPopFields>;
  var_samp?: Maybe<CurrentDelegatorBalancesVarSampFields>;
  variance?: Maybe<CurrentDelegatorBalancesVarianceFields>;
};

/** aggregate fields of "current_delegator_balances" */
export type CurrentDelegatorBalancesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentDelegatorBalancesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentDelegatorBalancesAvgFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  shares?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_delegator_balances". All fields are combined with a logical 'AND'. */
export type CurrentDelegatorBalancesBoolExp = {
  _and?: InputMaybe<Array<CurrentDelegatorBalancesBoolExp>>;
  _not?: InputMaybe<CurrentDelegatorBalancesBoolExp>;
  _or?: InputMaybe<Array<CurrentDelegatorBalancesBoolExp>>;
  current_pool_balance?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;
  delegator_address?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  parent_table_handle?: InputMaybe<StringComparisonExp>;
  pool_address?: InputMaybe<StringComparisonExp>;
  pool_type?: InputMaybe<StringComparisonExp>;
  shares?: InputMaybe<NumericComparisonExp>;
  staking_pool_metadata?: InputMaybe<CurrentStakingPoolVoterBoolExp>;
  table_handle?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "current_delegator_balances" */
export enum CurrentDelegatorBalancesConstraint {
  /** unique or primary key constraint on columns "delegator_address", "pool_address", "pool_type", "table_handle" */
  CurrentDelegatorBalancesPkey = "current_delegator_balances_pkey",
}

/** input type for incrementing numeric columns in table "current_delegator_balances" */
export type CurrentDelegatorBalancesIncInput = {
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  shares?: InputMaybe<Scalars["numeric"]["input"]>;
};

/** input type for inserting data into table "current_delegator_balances" */
export type CurrentDelegatorBalancesInsertInput = {
  current_pool_balance?: InputMaybe<CurrentDelegatedStakingPoolBalancesObjRelInsertInput>;
  delegator_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  parent_table_handle?: InputMaybe<Scalars["String"]["input"]>;
  pool_address?: InputMaybe<Scalars["String"]["input"]>;
  pool_type?: InputMaybe<Scalars["String"]["input"]>;
  shares?: InputMaybe<Scalars["numeric"]["input"]>;
  staking_pool_metadata?: InputMaybe<CurrentStakingPoolVoterObjRelInsertInput>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type CurrentDelegatorBalancesMaxFields = {
  delegator_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  parent_table_handle?: Maybe<Scalars["String"]["output"]>;
  pool_address?: Maybe<Scalars["String"]["output"]>;
  pool_type?: Maybe<Scalars["String"]["output"]>;
  shares?: Maybe<Scalars["numeric"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentDelegatorBalancesMinFields = {
  delegator_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  parent_table_handle?: Maybe<Scalars["String"]["output"]>;
  pool_address?: Maybe<Scalars["String"]["output"]>;
  pool_type?: Maybe<Scalars["String"]["output"]>;
  shares?: Maybe<Scalars["numeric"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "current_delegator_balances" */
export type CurrentDelegatorBalancesMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentDelegatorBalances>;
};

/** on_conflict condition type for table "current_delegator_balances" */
export type CurrentDelegatorBalancesOnConflict = {
  constraint: CurrentDelegatorBalancesConstraint;
  update_columns?: Array<CurrentDelegatorBalancesUpdateColumn>;
  where?: InputMaybe<CurrentDelegatorBalancesBoolExp>;
};

/** Ordering options when selecting data from "current_delegator_balances". */
export type CurrentDelegatorBalancesOrderBy = {
  current_pool_balance?: InputMaybe<CurrentDelegatedStakingPoolBalancesOrderBy>;
  delegator_address?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  parent_table_handle?: InputMaybe<OrderBy>;
  pool_address?: InputMaybe<OrderBy>;
  pool_type?: InputMaybe<OrderBy>;
  shares?: InputMaybe<OrderBy>;
  staking_pool_metadata?: InputMaybe<CurrentStakingPoolVoterOrderBy>;
  table_handle?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: current_delegator_balances */
export type CurrentDelegatorBalancesPkColumnsInput = {
  delegator_address: Scalars["String"]["input"];
  pool_address: Scalars["String"]["input"];
  pool_type: Scalars["String"]["input"];
  table_handle: Scalars["String"]["input"];
};

/** select columns of table "current_delegator_balances" */
export enum CurrentDelegatorBalancesSelectColumn {
  /** column name */
  DelegatorAddress = "delegator_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  ParentTableHandle = "parent_table_handle",
  /** column name */
  PoolAddress = "pool_address",
  /** column name */
  PoolType = "pool_type",
  /** column name */
  Shares = "shares",
  /** column name */
  TableHandle = "table_handle",
}

/** input type for updating data in table "current_delegator_balances" */
export type CurrentDelegatorBalancesSetInput = {
  delegator_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  parent_table_handle?: InputMaybe<Scalars["String"]["input"]>;
  pool_address?: InputMaybe<Scalars["String"]["input"]>;
  pool_type?: InputMaybe<Scalars["String"]["input"]>;
  shares?: InputMaybe<Scalars["numeric"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentDelegatorBalancesStddevFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  shares?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentDelegatorBalancesStddevPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  shares?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentDelegatorBalancesStddevSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  shares?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_delegator_balances" */
export type CurrentDelegatorBalancesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentDelegatorBalancesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentDelegatorBalancesStreamCursorValueInput = {
  delegator_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  parent_table_handle?: InputMaybe<Scalars["String"]["input"]>;
  pool_address?: InputMaybe<Scalars["String"]["input"]>;
  pool_type?: InputMaybe<Scalars["String"]["input"]>;
  shares?: InputMaybe<Scalars["numeric"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentDelegatorBalancesSumFields = {
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  shares?: Maybe<Scalars["numeric"]["output"]>;
};

/** update columns of table "current_delegator_balances" */
export enum CurrentDelegatorBalancesUpdateColumn {
  /** column name */
  DelegatorAddress = "delegator_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  ParentTableHandle = "parent_table_handle",
  /** column name */
  PoolAddress = "pool_address",
  /** column name */
  PoolType = "pool_type",
  /** column name */
  Shares = "shares",
  /** column name */
  TableHandle = "table_handle",
}

export type CurrentDelegatorBalancesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentDelegatorBalancesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentDelegatorBalancesSetInput>;
  /** filter the rows which have to be updated */
  where: CurrentDelegatorBalancesBoolExp;
};

/** aggregate var_pop on columns */
export type CurrentDelegatorBalancesVarPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  shares?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentDelegatorBalancesVarSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  shares?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentDelegatorBalancesVarianceFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  shares?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "current_fungible_asset_balances_legacy" */
export type CurrentFungibleAssetBalances = {
  amount: Scalars["numeric"]["output"];
  asset_type: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  is_frozen: Scalars["Boolean"]["output"];
  is_primary: Scalars["Boolean"]["output"];
  last_transaction_timestamp: Scalars["timestamp"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  /** An object relationship */
  metadata?: Maybe<FungibleAssetMetadata>;
  owner_address: Scalars["String"]["output"];
  storage_id: Scalars["String"]["output"];
  token_standard: Scalars["String"]["output"];
};

/** aggregated selection of "current_fungible_asset_balances_legacy" */
export type CurrentFungibleAssetBalancesAggregate = {
  aggregate?: Maybe<CurrentFungibleAssetBalancesAggregateFields>;
  nodes: Array<CurrentFungibleAssetBalances>;
};

/** aggregate fields of "current_fungible_asset_balances_legacy" */
export type CurrentFungibleAssetBalancesAggregateFields = {
  avg?: Maybe<CurrentFungibleAssetBalancesAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentFungibleAssetBalancesMaxFields>;
  min?: Maybe<CurrentFungibleAssetBalancesMinFields>;
  stddev?: Maybe<CurrentFungibleAssetBalancesStddevFields>;
  stddev_pop?: Maybe<CurrentFungibleAssetBalancesStddevPopFields>;
  stddev_samp?: Maybe<CurrentFungibleAssetBalancesStddevSampFields>;
  sum?: Maybe<CurrentFungibleAssetBalancesSumFields>;
  var_pop?: Maybe<CurrentFungibleAssetBalancesVarPopFields>;
  var_samp?: Maybe<CurrentFungibleAssetBalancesVarSampFields>;
  variance?: Maybe<CurrentFungibleAssetBalancesVarianceFields>;
};

/** aggregate fields of "current_fungible_asset_balances_legacy" */
export type CurrentFungibleAssetBalancesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentFungibleAssetBalancesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentFungibleAssetBalancesAvgFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_fungible_asset_balances_legacy". All fields are combined with a logical 'AND'. */
export type CurrentFungibleAssetBalancesBoolExp = {
  _and?: InputMaybe<Array<CurrentFungibleAssetBalancesBoolExp>>;
  _not?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;
  _or?: InputMaybe<Array<CurrentFungibleAssetBalancesBoolExp>>;
  amount?: InputMaybe<NumericComparisonExp>;
  asset_type?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_frozen?: InputMaybe<BooleanComparisonExp>;
  is_primary?: InputMaybe<BooleanComparisonExp>;
  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  metadata?: InputMaybe<FungibleAssetMetadataBoolExp>;
  owner_address?: InputMaybe<StringComparisonExp>;
  storage_id?: InputMaybe<StringComparisonExp>;
  token_standard?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "current_fungible_asset_balances_legacy" */
export enum CurrentFungibleAssetBalancesConstraint {
  /** unique or primary key constraint on columns "storage_id" */
  CurrentFungibleAssetBalancesPkey = "current_fungible_asset_balances_pkey",
}

/** input type for incrementing numeric columns in table "current_fungible_asset_balances_legacy" */
export type CurrentFungibleAssetBalancesIncInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "current_fungible_asset_balances_legacy" */
export type CurrentFungibleAssetBalancesInsertInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  asset_type?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  metadata?: InputMaybe<FungibleAssetMetadataObjRelInsertInput>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  storage_id?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type CurrentFungibleAssetBalancesMaxFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  asset_type?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  storage_id?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentFungibleAssetBalancesMinFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  asset_type?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  storage_id?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "current_fungible_asset_balances_legacy" */
export type CurrentFungibleAssetBalancesMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentFungibleAssetBalances>;
};

/** columns and relationships of "current_fungible_asset_balances" */
export type CurrentFungibleAssetBalancesNew = {
  amount: Scalars["numeric"]["output"];
  amount_v1?: Maybe<Scalars["numeric"]["output"]>;
  amount_v2?: Maybe<Scalars["numeric"]["output"]>;
  asset_type: Scalars["String"]["output"];
  asset_type_v1?: Maybe<Scalars["String"]["output"]>;
  asset_type_v2?: Maybe<Scalars["String"]["output"]>;
  inserted_at: Scalars["timestamp"]["output"];
  is_frozen: Scalars["Boolean"]["output"];
  is_primary: Scalars["Boolean"]["output"];
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp_v1?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp_v2?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  last_transaction_version_v1?: Maybe<Scalars["bigint"]["output"]>;
  last_transaction_version_v2?: Maybe<Scalars["bigint"]["output"]>;
  /** An object relationship */
  metadata?: Maybe<FungibleAssetMetadata>;
  owner_address: Scalars["String"]["output"];
  storage_id: Scalars["String"]["output"];
  token_standard: Scalars["String"]["output"];
};

/** aggregated selection of "current_fungible_asset_balances" */
export type CurrentFungibleAssetBalancesNewAggregate = {
  aggregate?: Maybe<CurrentFungibleAssetBalancesNewAggregateFields>;
  nodes: Array<CurrentFungibleAssetBalancesNew>;
};

/** aggregate fields of "current_fungible_asset_balances" */
export type CurrentFungibleAssetBalancesNewAggregateFields = {
  avg?: Maybe<CurrentFungibleAssetBalancesNewAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentFungibleAssetBalancesNewMaxFields>;
  min?: Maybe<CurrentFungibleAssetBalancesNewMinFields>;
  stddev?: Maybe<CurrentFungibleAssetBalancesNewStddevFields>;
  stddev_pop?: Maybe<CurrentFungibleAssetBalancesNewStddevPopFields>;
  stddev_samp?: Maybe<CurrentFungibleAssetBalancesNewStddevSampFields>;
  sum?: Maybe<CurrentFungibleAssetBalancesNewSumFields>;
  var_pop?: Maybe<CurrentFungibleAssetBalancesNewVarPopFields>;
  var_samp?: Maybe<CurrentFungibleAssetBalancesNewVarSampFields>;
  variance?: Maybe<CurrentFungibleAssetBalancesNewVarianceFields>;
};

/** aggregate fields of "current_fungible_asset_balances" */
export type CurrentFungibleAssetBalancesNewAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentFungibleAssetBalancesNewSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentFungibleAssetBalancesNewAvgFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  amount_v1?: Maybe<Scalars["Float"]["output"]>;
  amount_v2?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version_v1?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version_v2?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_fungible_asset_balances". All fields are combined with a logical 'AND'. */
export type CurrentFungibleAssetBalancesNewBoolExp = {
  _and?: InputMaybe<Array<CurrentFungibleAssetBalancesNewBoolExp>>;
  _not?: InputMaybe<CurrentFungibleAssetBalancesNewBoolExp>;
  _or?: InputMaybe<Array<CurrentFungibleAssetBalancesNewBoolExp>>;
  amount?: InputMaybe<NumericComparisonExp>;
  amount_v1?: InputMaybe<NumericComparisonExp>;
  amount_v2?: InputMaybe<NumericComparisonExp>;
  asset_type?: InputMaybe<StringComparisonExp>;
  asset_type_v1?: InputMaybe<StringComparisonExp>;
  asset_type_v2?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_frozen?: InputMaybe<BooleanComparisonExp>;
  is_primary?: InputMaybe<BooleanComparisonExp>;
  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  last_transaction_timestamp_v1?: InputMaybe<TimestampComparisonExp>;
  last_transaction_timestamp_v2?: InputMaybe<TimestampComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  last_transaction_version_v1?: InputMaybe<BigintComparisonExp>;
  last_transaction_version_v2?: InputMaybe<BigintComparisonExp>;
  metadata?: InputMaybe<FungibleAssetMetadataBoolExp>;
  owner_address?: InputMaybe<StringComparisonExp>;
  storage_id?: InputMaybe<StringComparisonExp>;
  token_standard?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "current_fungible_asset_balances" */
export enum CurrentFungibleAssetBalancesNewConstraint {
  /** unique or primary key constraint on columns "storage_id" */
  CurrentUnifiedFungibleAssetBalancesPkey = "current_unified_fungible_asset_balances_pkey",
}

/** input type for incrementing numeric columns in table "current_fungible_asset_balances" */
export type CurrentFungibleAssetBalancesNewIncInput = {
  amount_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  amount_v2?: InputMaybe<Scalars["numeric"]["input"]>;
  last_transaction_version_v1?: InputMaybe<Scalars["bigint"]["input"]>;
  last_transaction_version_v2?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "current_fungible_asset_balances" */
export type CurrentFungibleAssetBalancesNewInsertInput = {
  amount_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  amount_v2?: InputMaybe<Scalars["numeric"]["input"]>;
  asset_type_v1?: InputMaybe<Scalars["String"]["input"]>;
  asset_type_v2?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_timestamp_v1?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp_v2?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version_v1?: InputMaybe<Scalars["bigint"]["input"]>;
  last_transaction_version_v2?: InputMaybe<Scalars["bigint"]["input"]>;
  metadata?: InputMaybe<FungibleAssetMetadataObjRelInsertInput>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  storage_id?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type CurrentFungibleAssetBalancesNewMaxFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  amount_v1?: Maybe<Scalars["numeric"]["output"]>;
  amount_v2?: Maybe<Scalars["numeric"]["output"]>;
  asset_type?: Maybe<Scalars["String"]["output"]>;
  asset_type_v1?: Maybe<Scalars["String"]["output"]>;
  asset_type_v2?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp_v1?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp_v2?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  last_transaction_version_v1?: Maybe<Scalars["bigint"]["output"]>;
  last_transaction_version_v2?: Maybe<Scalars["bigint"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  storage_id?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentFungibleAssetBalancesNewMinFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  amount_v1?: Maybe<Scalars["numeric"]["output"]>;
  amount_v2?: Maybe<Scalars["numeric"]["output"]>;
  asset_type?: Maybe<Scalars["String"]["output"]>;
  asset_type_v1?: Maybe<Scalars["String"]["output"]>;
  asset_type_v2?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp_v1?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp_v2?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  last_transaction_version_v1?: Maybe<Scalars["bigint"]["output"]>;
  last_transaction_version_v2?: Maybe<Scalars["bigint"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  storage_id?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "current_fungible_asset_balances" */
export type CurrentFungibleAssetBalancesNewMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentFungibleAssetBalancesNew>;
};

/** on_conflict condition type for table "current_fungible_asset_balances" */
export type CurrentFungibleAssetBalancesNewOnConflict = {
  constraint: CurrentFungibleAssetBalancesNewConstraint;
  update_columns?: Array<CurrentFungibleAssetBalancesNewUpdateColumn>;
  where?: InputMaybe<CurrentFungibleAssetBalancesNewBoolExp>;
};

/** Ordering options when selecting data from "current_fungible_asset_balances". */
export type CurrentFungibleAssetBalancesNewOrderBy = {
  amount?: InputMaybe<OrderBy>;
  amount_v1?: InputMaybe<OrderBy>;
  amount_v2?: InputMaybe<OrderBy>;
  asset_type?: InputMaybe<OrderBy>;
  asset_type_v1?: InputMaybe<OrderBy>;
  asset_type_v2?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_frozen?: InputMaybe<OrderBy>;
  is_primary?: InputMaybe<OrderBy>;
  last_transaction_timestamp?: InputMaybe<OrderBy>;
  last_transaction_timestamp_v1?: InputMaybe<OrderBy>;
  last_transaction_timestamp_v2?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  last_transaction_version_v1?: InputMaybe<OrderBy>;
  last_transaction_version_v2?: InputMaybe<OrderBy>;
  metadata?: InputMaybe<FungibleAssetMetadataOrderBy>;
  owner_address?: InputMaybe<OrderBy>;
  storage_id?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: current_fungible_asset_balances */
export type CurrentFungibleAssetBalancesNewPkColumnsInput = {
  storage_id: Scalars["String"]["input"];
};

/** select columns of table "current_fungible_asset_balances" */
export enum CurrentFungibleAssetBalancesNewSelectColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  AmountV1 = "amount_v1",
  /** column name */
  AmountV2 = "amount_v2",
  /** column name */
  AssetType = "asset_type",
  /** column name */
  AssetTypeV1 = "asset_type_v1",
  /** column name */
  AssetTypeV2 = "asset_type_v2",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsFrozen = "is_frozen",
  /** column name */
  IsPrimary = "is_primary",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionTimestampV1 = "last_transaction_timestamp_v1",
  /** column name */
  LastTransactionTimestampV2 = "last_transaction_timestamp_v2",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  LastTransactionVersionV1 = "last_transaction_version_v1",
  /** column name */
  LastTransactionVersionV2 = "last_transaction_version_v2",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  StorageId = "storage_id",
  /** column name */
  TokenStandard = "token_standard",
}

/** input type for updating data in table "current_fungible_asset_balances" */
export type CurrentFungibleAssetBalancesNewSetInput = {
  amount_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  amount_v2?: InputMaybe<Scalars["numeric"]["input"]>;
  asset_type_v1?: InputMaybe<Scalars["String"]["input"]>;
  asset_type_v2?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_timestamp_v1?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp_v2?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version_v1?: InputMaybe<Scalars["bigint"]["input"]>;
  last_transaction_version_v2?: InputMaybe<Scalars["bigint"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  storage_id?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentFungibleAssetBalancesNewStddevFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  amount_v1?: Maybe<Scalars["Float"]["output"]>;
  amount_v2?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version_v1?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version_v2?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentFungibleAssetBalancesNewStddevPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  amount_v1?: Maybe<Scalars["Float"]["output"]>;
  amount_v2?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version_v1?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version_v2?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentFungibleAssetBalancesNewStddevSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  amount_v1?: Maybe<Scalars["Float"]["output"]>;
  amount_v2?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version_v1?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version_v2?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_fungible_asset_balances_new" */
export type CurrentFungibleAssetBalancesNewStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentFungibleAssetBalancesNewStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentFungibleAssetBalancesNewStreamCursorValueInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  amount_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  amount_v2?: InputMaybe<Scalars["numeric"]["input"]>;
  asset_type?: InputMaybe<Scalars["String"]["input"]>;
  asset_type_v1?: InputMaybe<Scalars["String"]["input"]>;
  asset_type_v2?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp_v1?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp_v2?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  last_transaction_version_v1?: InputMaybe<Scalars["bigint"]["input"]>;
  last_transaction_version_v2?: InputMaybe<Scalars["bigint"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  storage_id?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentFungibleAssetBalancesNewSumFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  amount_v1?: Maybe<Scalars["numeric"]["output"]>;
  amount_v2?: Maybe<Scalars["numeric"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  last_transaction_version_v1?: Maybe<Scalars["bigint"]["output"]>;
  last_transaction_version_v2?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "current_fungible_asset_balances" */
export enum CurrentFungibleAssetBalancesNewUpdateColumn {
  /** column name */
  AmountV1 = "amount_v1",
  /** column name */
  AmountV2 = "amount_v2",
  /** column name */
  AssetTypeV1 = "asset_type_v1",
  /** column name */
  AssetTypeV2 = "asset_type_v2",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsFrozen = "is_frozen",
  /** column name */
  IsPrimary = "is_primary",
  /** column name */
  LastTransactionTimestampV1 = "last_transaction_timestamp_v1",
  /** column name */
  LastTransactionTimestampV2 = "last_transaction_timestamp_v2",
  /** column name */
  LastTransactionVersionV1 = "last_transaction_version_v1",
  /** column name */
  LastTransactionVersionV2 = "last_transaction_version_v2",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  StorageId = "storage_id",
}

export type CurrentFungibleAssetBalancesNewUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentFungibleAssetBalancesNewIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentFungibleAssetBalancesNewSetInput>;
  /** filter the rows which have to be updated */
  where: CurrentFungibleAssetBalancesNewBoolExp;
};

/** aggregate var_pop on columns */
export type CurrentFungibleAssetBalancesNewVarPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  amount_v1?: Maybe<Scalars["Float"]["output"]>;
  amount_v2?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version_v1?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version_v2?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentFungibleAssetBalancesNewVarSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  amount_v1?: Maybe<Scalars["Float"]["output"]>;
  amount_v2?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version_v1?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version_v2?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentFungibleAssetBalancesNewVarianceFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  amount_v1?: Maybe<Scalars["Float"]["output"]>;
  amount_v2?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version_v1?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version_v2?: Maybe<Scalars["Float"]["output"]>;
};

/** on_conflict condition type for table "current_fungible_asset_balances_legacy" */
export type CurrentFungibleAssetBalancesOnConflict = {
  constraint: CurrentFungibleAssetBalancesConstraint;
  update_columns?: Array<CurrentFungibleAssetBalancesUpdateColumn>;
  where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;
};

/** Ordering options when selecting data from "current_fungible_asset_balances_legacy". */
export type CurrentFungibleAssetBalancesOrderBy = {
  amount?: InputMaybe<OrderBy>;
  asset_type?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_frozen?: InputMaybe<OrderBy>;
  is_primary?: InputMaybe<OrderBy>;
  last_transaction_timestamp?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  metadata?: InputMaybe<FungibleAssetMetadataOrderBy>;
  owner_address?: InputMaybe<OrderBy>;
  storage_id?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: current_fungible_asset_balances_legacy */
export type CurrentFungibleAssetBalancesPkColumnsInput = {
  storage_id: Scalars["String"]["input"];
};

/** select columns of table "current_fungible_asset_balances_legacy" */
export enum CurrentFungibleAssetBalancesSelectColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  AssetType = "asset_type",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsFrozen = "is_frozen",
  /** column name */
  IsPrimary = "is_primary",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  StorageId = "storage_id",
  /** column name */
  TokenStandard = "token_standard",
}

/** input type for updating data in table "current_fungible_asset_balances_legacy" */
export type CurrentFungibleAssetBalancesSetInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  asset_type?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  storage_id?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentFungibleAssetBalancesStddevFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentFungibleAssetBalancesStddevPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentFungibleAssetBalancesStddevSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_fungible_asset_balances" */
export type CurrentFungibleAssetBalancesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentFungibleAssetBalancesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentFungibleAssetBalancesStreamCursorValueInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  asset_type?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  storage_id?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentFungibleAssetBalancesSumFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "current_fungible_asset_balances_legacy" */
export enum CurrentFungibleAssetBalancesUpdateColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  AssetType = "asset_type",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsFrozen = "is_frozen",
  /** column name */
  IsPrimary = "is_primary",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  StorageId = "storage_id",
  /** column name */
  TokenStandard = "token_standard",
}

export type CurrentFungibleAssetBalancesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentFungibleAssetBalancesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentFungibleAssetBalancesSetInput>;
  /** filter the rows which have to be updated */
  where: CurrentFungibleAssetBalancesBoolExp;
};

/** aggregate var_pop on columns */
export type CurrentFungibleAssetBalancesVarPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentFungibleAssetBalancesVarSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentFungibleAssetBalancesVarianceFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "current_objects" */
export type CurrentObjects = {
  allow_ungated_transfer: Scalars["Boolean"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  is_deleted: Scalars["Boolean"]["output"];
  last_guid_creation_num: Scalars["numeric"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  object_address: Scalars["String"]["output"];
  owner_address: Scalars["String"]["output"];
  state_key_hash: Scalars["String"]["output"];
  untransferrable: Scalars["Boolean"]["output"];
};

/** aggregated selection of "current_objects" */
export type CurrentObjectsAggregate = {
  aggregate?: Maybe<CurrentObjectsAggregateFields>;
  nodes: Array<CurrentObjects>;
};

/** aggregate fields of "current_objects" */
export type CurrentObjectsAggregateFields = {
  avg?: Maybe<CurrentObjectsAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentObjectsMaxFields>;
  min?: Maybe<CurrentObjectsMinFields>;
  stddev?: Maybe<CurrentObjectsStddevFields>;
  stddev_pop?: Maybe<CurrentObjectsStddevPopFields>;
  stddev_samp?: Maybe<CurrentObjectsStddevSampFields>;
  sum?: Maybe<CurrentObjectsSumFields>;
  var_pop?: Maybe<CurrentObjectsVarPopFields>;
  var_samp?: Maybe<CurrentObjectsVarSampFields>;
  variance?: Maybe<CurrentObjectsVarianceFields>;
};

/** aggregate fields of "current_objects" */
export type CurrentObjectsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentObjectsSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentObjectsAvgFields = {
  last_guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_objects". All fields are combined with a logical 'AND'. */
export type CurrentObjectsBoolExp = {
  _and?: InputMaybe<Array<CurrentObjectsBoolExp>>;
  _not?: InputMaybe<CurrentObjectsBoolExp>;
  _or?: InputMaybe<Array<CurrentObjectsBoolExp>>;
  allow_ungated_transfer?: InputMaybe<BooleanComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_deleted?: InputMaybe<BooleanComparisonExp>;
  last_guid_creation_num?: InputMaybe<NumericComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  object_address?: InputMaybe<StringComparisonExp>;
  owner_address?: InputMaybe<StringComparisonExp>;
  state_key_hash?: InputMaybe<StringComparisonExp>;
  untransferrable?: InputMaybe<BooleanComparisonExp>;
};

/** unique or primary key constraints on table "current_objects" */
export enum CurrentObjectsConstraint {
  /** unique or primary key constraint on columns "object_address" */
  CurrentObjectsPkey = "current_objects_pkey",
}

/** input type for incrementing numeric columns in table "current_objects" */
export type CurrentObjectsIncInput = {
  last_guid_creation_num?: InputMaybe<Scalars["numeric"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "current_objects" */
export type CurrentObjectsInsertInput = {
  allow_ungated_transfer?: InputMaybe<Scalars["Boolean"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_guid_creation_num?: InputMaybe<Scalars["numeric"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  object_address?: InputMaybe<Scalars["String"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
  untransferrable?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate max on columns */
export type CurrentObjectsMaxFields = {
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_guid_creation_num?: Maybe<Scalars["numeric"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  object_address?: Maybe<Scalars["String"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  state_key_hash?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentObjectsMinFields = {
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_guid_creation_num?: Maybe<Scalars["numeric"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  object_address?: Maybe<Scalars["String"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  state_key_hash?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "current_objects" */
export type CurrentObjectsMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentObjects>;
};

/** on_conflict condition type for table "current_objects" */
export type CurrentObjectsOnConflict = {
  constraint: CurrentObjectsConstraint;
  update_columns?: Array<CurrentObjectsUpdateColumn>;
  where?: InputMaybe<CurrentObjectsBoolExp>;
};

/** Ordering options when selecting data from "current_objects". */
export type CurrentObjectsOrderBy = {
  allow_ungated_transfer?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_deleted?: InputMaybe<OrderBy>;
  last_guid_creation_num?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  object_address?: InputMaybe<OrderBy>;
  owner_address?: InputMaybe<OrderBy>;
  state_key_hash?: InputMaybe<OrderBy>;
  untransferrable?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: current_objects */
export type CurrentObjectsPkColumnsInput = {
  object_address: Scalars["String"]["input"];
};

/** select columns of table "current_objects" */
export enum CurrentObjectsSelectColumn {
  /** column name */
  AllowUngatedTransfer = "allow_ungated_transfer",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  LastGuidCreationNum = "last_guid_creation_num",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  ObjectAddress = "object_address",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  StateKeyHash = "state_key_hash",
  /** column name */
  Untransferrable = "untransferrable",
}

/** input type for updating data in table "current_objects" */
export type CurrentObjectsSetInput = {
  allow_ungated_transfer?: InputMaybe<Scalars["Boolean"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_guid_creation_num?: InputMaybe<Scalars["numeric"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  object_address?: InputMaybe<Scalars["String"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
  untransferrable?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentObjectsStddevFields = {
  last_guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentObjectsStddevPopFields = {
  last_guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentObjectsStddevSampFields = {
  last_guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_objects" */
export type CurrentObjectsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentObjectsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentObjectsStreamCursorValueInput = {
  allow_ungated_transfer?: InputMaybe<Scalars["Boolean"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_guid_creation_num?: InputMaybe<Scalars["numeric"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  object_address?: InputMaybe<Scalars["String"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
  untransferrable?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentObjectsSumFields = {
  last_guid_creation_num?: Maybe<Scalars["numeric"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "current_objects" */
export enum CurrentObjectsUpdateColumn {
  /** column name */
  AllowUngatedTransfer = "allow_ungated_transfer",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  LastGuidCreationNum = "last_guid_creation_num",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  ObjectAddress = "object_address",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  StateKeyHash = "state_key_hash",
  /** column name */
  Untransferrable = "untransferrable",
}

export type CurrentObjectsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentObjectsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentObjectsSetInput>;
  /** filter the rows which have to be updated */
  where: CurrentObjectsBoolExp;
};

/** aggregate var_pop on columns */
export type CurrentObjectsVarPopFields = {
  last_guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentObjectsVarSampFields = {
  last_guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentObjectsVarianceFields = {
  last_guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "current_staking_pool_voter" */
export type CurrentStakingPoolVoter = {
  inserted_at: Scalars["timestamp"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  operator_address: Scalars["String"]["output"];
  /** An array relationship */
  operator_cedra_name: Array<CurrentCedraNames>;
  /** An aggregate relationship */
  operator_cedra_name_aggregate: CurrentCedraNamesAggregate;
  staking_pool_address: Scalars["String"]["output"];
  voter_address: Scalars["String"]["output"];
};

/** columns and relationships of "current_staking_pool_voter" */
export type CurrentStakingPoolVoterOperatorCedraNameArgs = {
  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
  where?: InputMaybe<CurrentCedraNamesBoolExp>;
};

/** columns and relationships of "current_staking_pool_voter" */
export type CurrentStakingPoolVoterOperatorCedraNameAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
  where?: InputMaybe<CurrentCedraNamesBoolExp>;
};

/** aggregated selection of "current_staking_pool_voter" */
export type CurrentStakingPoolVoterAggregate = {
  aggregate?: Maybe<CurrentStakingPoolVoterAggregateFields>;
  nodes: Array<CurrentStakingPoolVoter>;
};

/** aggregate fields of "current_staking_pool_voter" */
export type CurrentStakingPoolVoterAggregateFields = {
  avg?: Maybe<CurrentStakingPoolVoterAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentStakingPoolVoterMaxFields>;
  min?: Maybe<CurrentStakingPoolVoterMinFields>;
  stddev?: Maybe<CurrentStakingPoolVoterStddevFields>;
  stddev_pop?: Maybe<CurrentStakingPoolVoterStddevPopFields>;
  stddev_samp?: Maybe<CurrentStakingPoolVoterStddevSampFields>;
  sum?: Maybe<CurrentStakingPoolVoterSumFields>;
  var_pop?: Maybe<CurrentStakingPoolVoterVarPopFields>;
  var_samp?: Maybe<CurrentStakingPoolVoterVarSampFields>;
  variance?: Maybe<CurrentStakingPoolVoterVarianceFields>;
};

/** aggregate fields of "current_staking_pool_voter" */
export type CurrentStakingPoolVoterAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentStakingPoolVoterSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentStakingPoolVoterAvgFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_staking_pool_voter". All fields are combined with a logical 'AND'. */
export type CurrentStakingPoolVoterBoolExp = {
  _and?: InputMaybe<Array<CurrentStakingPoolVoterBoolExp>>;
  _not?: InputMaybe<CurrentStakingPoolVoterBoolExp>;
  _or?: InputMaybe<Array<CurrentStakingPoolVoterBoolExp>>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  operator_address?: InputMaybe<StringComparisonExp>;
  operator_cedra_name?: InputMaybe<CurrentCedraNamesBoolExp>;
  operator_cedra_name_aggregate?: InputMaybe<CurrentCedraNamesAggregateBoolExp>;
  staking_pool_address?: InputMaybe<StringComparisonExp>;
  voter_address?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "current_staking_pool_voter" */
export enum CurrentStakingPoolVoterConstraint {
  /** unique or primary key constraint on columns "staking_pool_address" */
  CurrentStakingPoolVoterPkey = "current_staking_pool_voter_pkey",
}

/** input type for incrementing numeric columns in table "current_staking_pool_voter" */
export type CurrentStakingPoolVoterIncInput = {
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "current_staking_pool_voter" */
export type CurrentStakingPoolVoterInsertInput = {
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  operator_address?: InputMaybe<Scalars["String"]["input"]>;
  operator_cedra_name?: InputMaybe<CurrentCedraNamesArrRelInsertInput>;
  staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
  voter_address?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type CurrentStakingPoolVoterMaxFields = {
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  operator_address?: Maybe<Scalars["String"]["output"]>;
  staking_pool_address?: Maybe<Scalars["String"]["output"]>;
  voter_address?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentStakingPoolVoterMinFields = {
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  operator_address?: Maybe<Scalars["String"]["output"]>;
  staking_pool_address?: Maybe<Scalars["String"]["output"]>;
  voter_address?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "current_staking_pool_voter" */
export type CurrentStakingPoolVoterMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentStakingPoolVoter>;
};

/** input type for inserting object relation for remote table "current_staking_pool_voter" */
export type CurrentStakingPoolVoterObjRelInsertInput = {
  data: CurrentStakingPoolVoterInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<CurrentStakingPoolVoterOnConflict>;
};

/** on_conflict condition type for table "current_staking_pool_voter" */
export type CurrentStakingPoolVoterOnConflict = {
  constraint: CurrentStakingPoolVoterConstraint;
  update_columns?: Array<CurrentStakingPoolVoterUpdateColumn>;
  where?: InputMaybe<CurrentStakingPoolVoterBoolExp>;
};

/** Ordering options when selecting data from "current_staking_pool_voter". */
export type CurrentStakingPoolVoterOrderBy = {
  inserted_at?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  operator_address?: InputMaybe<OrderBy>;
  operator_cedra_name_aggregate?: InputMaybe<CurrentCedraNamesAggregateOrderBy>;
  staking_pool_address?: InputMaybe<OrderBy>;
  voter_address?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: current_staking_pool_voter */
export type CurrentStakingPoolVoterPkColumnsInput = {
  staking_pool_address: Scalars["String"]["input"];
};

/** select columns of table "current_staking_pool_voter" */
export enum CurrentStakingPoolVoterSelectColumn {
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  OperatorAddress = "operator_address",
  /** column name */
  StakingPoolAddress = "staking_pool_address",
  /** column name */
  VoterAddress = "voter_address",
}

/** input type for updating data in table "current_staking_pool_voter" */
export type CurrentStakingPoolVoterSetInput = {
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  operator_address?: InputMaybe<Scalars["String"]["input"]>;
  staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
  voter_address?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentStakingPoolVoterStddevFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentStakingPoolVoterStddevPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentStakingPoolVoterStddevSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_staking_pool_voter" */
export type CurrentStakingPoolVoterStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentStakingPoolVoterStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentStakingPoolVoterStreamCursorValueInput = {
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  operator_address?: InputMaybe<Scalars["String"]["input"]>;
  staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
  voter_address?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentStakingPoolVoterSumFields = {
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "current_staking_pool_voter" */
export enum CurrentStakingPoolVoterUpdateColumn {
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  OperatorAddress = "operator_address",
  /** column name */
  StakingPoolAddress = "staking_pool_address",
  /** column name */
  VoterAddress = "voter_address",
}

export type CurrentStakingPoolVoterUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentStakingPoolVoterIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentStakingPoolVoterSetInput>;
  /** filter the rows which have to be updated */
  where: CurrentStakingPoolVoterBoolExp;
};

/** aggregate var_pop on columns */
export type CurrentStakingPoolVoterVarPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentStakingPoolVoterVarSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentStakingPoolVoterVarianceFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "current_table_items" */
export type CurrentTableItems = {
  decoded_key: Scalars["jsonb"]["output"];
  decoded_value?: Maybe<Scalars["jsonb"]["output"]>;
  inserted_at: Scalars["timestamp"]["output"];
  is_deleted: Scalars["Boolean"]["output"];
  key: Scalars["String"]["output"];
  key_hash: Scalars["String"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  table_handle: Scalars["String"]["output"];
};

/** columns and relationships of "current_table_items" */
export type CurrentTableItemsDecodedKeyArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** columns and relationships of "current_table_items" */
export type CurrentTableItemsDecodedValueArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregated selection of "current_table_items" */
export type CurrentTableItemsAggregate = {
  aggregate?: Maybe<CurrentTableItemsAggregateFields>;
  nodes: Array<CurrentTableItems>;
};

/** aggregate fields of "current_table_items" */
export type CurrentTableItemsAggregateFields = {
  avg?: Maybe<CurrentTableItemsAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentTableItemsMaxFields>;
  min?: Maybe<CurrentTableItemsMinFields>;
  stddev?: Maybe<CurrentTableItemsStddevFields>;
  stddev_pop?: Maybe<CurrentTableItemsStddevPopFields>;
  stddev_samp?: Maybe<CurrentTableItemsStddevSampFields>;
  sum?: Maybe<CurrentTableItemsSumFields>;
  var_pop?: Maybe<CurrentTableItemsVarPopFields>;
  var_samp?: Maybe<CurrentTableItemsVarSampFields>;
  variance?: Maybe<CurrentTableItemsVarianceFields>;
};

/** aggregate fields of "current_table_items" */
export type CurrentTableItemsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentTableItemsSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type CurrentTableItemsAppendInput = {
  decoded_key?: InputMaybe<Scalars["jsonb"]["input"]>;
  decoded_value?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentTableItemsAvgFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_table_items". All fields are combined with a logical 'AND'. */
export type CurrentTableItemsBoolExp = {
  _and?: InputMaybe<Array<CurrentTableItemsBoolExp>>;
  _not?: InputMaybe<CurrentTableItemsBoolExp>;
  _or?: InputMaybe<Array<CurrentTableItemsBoolExp>>;
  decoded_key?: InputMaybe<JsonbComparisonExp>;
  decoded_value?: InputMaybe<JsonbComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_deleted?: InputMaybe<BooleanComparisonExp>;
  key?: InputMaybe<StringComparisonExp>;
  key_hash?: InputMaybe<StringComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  table_handle?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "current_table_items" */
export enum CurrentTableItemsConstraint {
  /** unique or primary key constraint on columns "key_hash", "table_handle" */
  CurrentTableItemsPkey = "current_table_items_pkey",
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type CurrentTableItemsDeleteAtPathInput = {
  decoded_key?: InputMaybe<Array<Scalars["String"]["input"]>>;
  decoded_value?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type CurrentTableItemsDeleteElemInput = {
  decoded_key?: InputMaybe<Scalars["Int"]["input"]>;
  decoded_value?: InputMaybe<Scalars["Int"]["input"]>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type CurrentTableItemsDeleteKeyInput = {
  decoded_key?: InputMaybe<Scalars["String"]["input"]>;
  decoded_value?: InputMaybe<Scalars["String"]["input"]>;
};

/** input type for incrementing numeric columns in table "current_table_items" */
export type CurrentTableItemsIncInput = {
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "current_table_items" */
export type CurrentTableItemsInsertInput = {
  decoded_key?: InputMaybe<Scalars["jsonb"]["input"]>;
  decoded_value?: InputMaybe<Scalars["jsonb"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  key?: InputMaybe<Scalars["String"]["input"]>;
  key_hash?: InputMaybe<Scalars["String"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type CurrentTableItemsMaxFields = {
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  key?: Maybe<Scalars["String"]["output"]>;
  key_hash?: Maybe<Scalars["String"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentTableItemsMinFields = {
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  key?: Maybe<Scalars["String"]["output"]>;
  key_hash?: Maybe<Scalars["String"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "current_table_items" */
export type CurrentTableItemsMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentTableItems>;
};

/** on_conflict condition type for table "current_table_items" */
export type CurrentTableItemsOnConflict = {
  constraint: CurrentTableItemsConstraint;
  update_columns?: Array<CurrentTableItemsUpdateColumn>;
  where?: InputMaybe<CurrentTableItemsBoolExp>;
};

/** Ordering options when selecting data from "current_table_items". */
export type CurrentTableItemsOrderBy = {
  decoded_key?: InputMaybe<OrderBy>;
  decoded_value?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_deleted?: InputMaybe<OrderBy>;
  key?: InputMaybe<OrderBy>;
  key_hash?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  table_handle?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: current_table_items */
export type CurrentTableItemsPkColumnsInput = {
  key_hash: Scalars["String"]["input"];
  table_handle: Scalars["String"]["input"];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type CurrentTableItemsPrependInput = {
  decoded_key?: InputMaybe<Scalars["jsonb"]["input"]>;
  decoded_value?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** select columns of table "current_table_items" */
export enum CurrentTableItemsSelectColumn {
  /** column name */
  DecodedKey = "decoded_key",
  /** column name */
  DecodedValue = "decoded_value",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  Key = "key",
  /** column name */
  KeyHash = "key_hash",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  TableHandle = "table_handle",
}

/** input type for updating data in table "current_table_items" */
export type CurrentTableItemsSetInput = {
  decoded_key?: InputMaybe<Scalars["jsonb"]["input"]>;
  decoded_value?: InputMaybe<Scalars["jsonb"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  key?: InputMaybe<Scalars["String"]["input"]>;
  key_hash?: InputMaybe<Scalars["String"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentTableItemsStddevFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentTableItemsStddevPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentTableItemsStddevSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_table_items" */
export type CurrentTableItemsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentTableItemsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentTableItemsStreamCursorValueInput = {
  decoded_key?: InputMaybe<Scalars["jsonb"]["input"]>;
  decoded_value?: InputMaybe<Scalars["jsonb"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  key?: InputMaybe<Scalars["String"]["input"]>;
  key_hash?: InputMaybe<Scalars["String"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentTableItemsSumFields = {
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "current_table_items" */
export enum CurrentTableItemsUpdateColumn {
  /** column name */
  DecodedKey = "decoded_key",
  /** column name */
  DecodedValue = "decoded_value",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  Key = "key",
  /** column name */
  KeyHash = "key_hash",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  TableHandle = "table_handle",
}

export type CurrentTableItemsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<CurrentTableItemsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<CurrentTableItemsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<CurrentTableItemsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<CurrentTableItemsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentTableItemsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<CurrentTableItemsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentTableItemsSetInput>;
  /** filter the rows which have to be updated */
  where: CurrentTableItemsBoolExp;
};

/** aggregate var_pop on columns */
export type CurrentTableItemsVarPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentTableItemsVarSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentTableItemsVarianceFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "current_table_items_view" */
export type CurrentTableItemsView = {
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  is_deleted?: Maybe<Scalars["Boolean"]["output"]>;
  json_decoded_key?: Maybe<Scalars["String"]["output"]>;
  json_decoded_value?: Maybe<Scalars["String"]["output"]>;
  key?: Maybe<Scalars["String"]["output"]>;
  key_hash?: Maybe<Scalars["String"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
};

/** aggregated selection of "current_table_items_view" */
export type CurrentTableItemsViewAggregate = {
  aggregate?: Maybe<CurrentTableItemsViewAggregateFields>;
  nodes: Array<CurrentTableItemsView>;
};

/** aggregate fields of "current_table_items_view" */
export type CurrentTableItemsViewAggregateFields = {
  avg?: Maybe<CurrentTableItemsViewAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentTableItemsViewMaxFields>;
  min?: Maybe<CurrentTableItemsViewMinFields>;
  stddev?: Maybe<CurrentTableItemsViewStddevFields>;
  stddev_pop?: Maybe<CurrentTableItemsViewStddevPopFields>;
  stddev_samp?: Maybe<CurrentTableItemsViewStddevSampFields>;
  sum?: Maybe<CurrentTableItemsViewSumFields>;
  var_pop?: Maybe<CurrentTableItemsViewVarPopFields>;
  var_samp?: Maybe<CurrentTableItemsViewVarSampFields>;
  variance?: Maybe<CurrentTableItemsViewVarianceFields>;
};

/** aggregate fields of "current_table_items_view" */
export type CurrentTableItemsViewAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentTableItemsViewSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentTableItemsViewAvgFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_table_items_view". All fields are combined with a logical 'AND'. */
export type CurrentTableItemsViewBoolExp = {
  _and?: InputMaybe<Array<CurrentTableItemsViewBoolExp>>;
  _not?: InputMaybe<CurrentTableItemsViewBoolExp>;
  _or?: InputMaybe<Array<CurrentTableItemsViewBoolExp>>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_deleted?: InputMaybe<BooleanComparisonExp>;
  json_decoded_key?: InputMaybe<StringComparisonExp>;
  json_decoded_value?: InputMaybe<StringComparisonExp>;
  key?: InputMaybe<StringComparisonExp>;
  key_hash?: InputMaybe<StringComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  table_handle?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "current_table_items_view" */
export type CurrentTableItemsViewIncInput = {
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "current_table_items_view" */
export type CurrentTableItemsViewInsertInput = {
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  json_decoded_key?: InputMaybe<Scalars["String"]["input"]>;
  json_decoded_value?: InputMaybe<Scalars["String"]["input"]>;
  key?: InputMaybe<Scalars["String"]["input"]>;
  key_hash?: InputMaybe<Scalars["String"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type CurrentTableItemsViewMaxFields = {
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  json_decoded_key?: Maybe<Scalars["String"]["output"]>;
  json_decoded_value?: Maybe<Scalars["String"]["output"]>;
  key?: Maybe<Scalars["String"]["output"]>;
  key_hash?: Maybe<Scalars["String"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentTableItemsViewMinFields = {
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  json_decoded_key?: Maybe<Scalars["String"]["output"]>;
  json_decoded_value?: Maybe<Scalars["String"]["output"]>;
  key?: Maybe<Scalars["String"]["output"]>;
  key_hash?: Maybe<Scalars["String"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "current_table_items_view" */
export type CurrentTableItemsViewMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentTableItemsView>;
};

/** Ordering options when selecting data from "current_table_items_view". */
export type CurrentTableItemsViewOrderBy = {
  inserted_at?: InputMaybe<OrderBy>;
  is_deleted?: InputMaybe<OrderBy>;
  json_decoded_key?: InputMaybe<OrderBy>;
  json_decoded_value?: InputMaybe<OrderBy>;
  key?: InputMaybe<OrderBy>;
  key_hash?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  table_handle?: InputMaybe<OrderBy>;
};

/** select columns of table "current_table_items_view" */
export enum CurrentTableItemsViewSelectColumn {
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  JsonDecodedKey = "json_decoded_key",
  /** column name */
  JsonDecodedValue = "json_decoded_value",
  /** column name */
  Key = "key",
  /** column name */
  KeyHash = "key_hash",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  TableHandle = "table_handle",
}

/** input type for updating data in table "current_table_items_view" */
export type CurrentTableItemsViewSetInput = {
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  json_decoded_key?: InputMaybe<Scalars["String"]["input"]>;
  json_decoded_value?: InputMaybe<Scalars["String"]["input"]>;
  key?: InputMaybe<Scalars["String"]["input"]>;
  key_hash?: InputMaybe<Scalars["String"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentTableItemsViewStddevFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentTableItemsViewStddevPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentTableItemsViewStddevSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_table_items_view" */
export type CurrentTableItemsViewStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentTableItemsViewStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentTableItemsViewStreamCursorValueInput = {
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  json_decoded_key?: InputMaybe<Scalars["String"]["input"]>;
  json_decoded_value?: InputMaybe<Scalars["String"]["input"]>;
  key?: InputMaybe<Scalars["String"]["input"]>;
  key_hash?: InputMaybe<Scalars["String"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentTableItemsViewSumFields = {
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

export type CurrentTableItemsViewUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentTableItemsViewIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentTableItemsViewSetInput>;
  /** filter the rows which have to be updated */
  where: CurrentTableItemsViewBoolExp;
};

/** aggregate var_pop on columns */
export type CurrentTableItemsViewVarPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentTableItemsViewVarSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentTableItemsViewVarianceFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "current_token_datas" */
export type CurrentTokenDatas = {
  collection_data_id_hash: Scalars["String"]["output"];
  collection_name: Scalars["String"]["output"];
  creator_address: Scalars["String"]["output"];
  default_properties: Scalars["jsonb"]["output"];
  description: Scalars["String"]["output"];
  description_mutable: Scalars["Boolean"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  largest_property_version: Scalars["numeric"]["output"];
  last_transaction_timestamp: Scalars["timestamp"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  maximum: Scalars["numeric"]["output"];
  maximum_mutable: Scalars["Boolean"]["output"];
  metadata_uri: Scalars["String"]["output"];
  name: Scalars["String"]["output"];
  payee_address: Scalars["String"]["output"];
  properties_mutable: Scalars["Boolean"]["output"];
  royalty_mutable: Scalars["Boolean"]["output"];
  royalty_points_denominator: Scalars["numeric"]["output"];
  royalty_points_numerator: Scalars["numeric"]["output"];
  supply: Scalars["numeric"]["output"];
  token_data_id_hash: Scalars["String"]["output"];
  uri_mutable: Scalars["Boolean"]["output"];
};

/** columns and relationships of "current_token_datas" */
export type CurrentTokenDatasDefaultPropertiesArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregated selection of "current_token_datas" */
export type CurrentTokenDatasAggregate = {
  aggregate?: Maybe<CurrentTokenDatasAggregateFields>;
  nodes: Array<CurrentTokenDatas>;
};

/** aggregate fields of "current_token_datas" */
export type CurrentTokenDatasAggregateFields = {
  avg?: Maybe<CurrentTokenDatasAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentTokenDatasMaxFields>;
  min?: Maybe<CurrentTokenDatasMinFields>;
  stddev?: Maybe<CurrentTokenDatasStddevFields>;
  stddev_pop?: Maybe<CurrentTokenDatasStddevPopFields>;
  stddev_samp?: Maybe<CurrentTokenDatasStddevSampFields>;
  sum?: Maybe<CurrentTokenDatasSumFields>;
  var_pop?: Maybe<CurrentTokenDatasVarPopFields>;
  var_samp?: Maybe<CurrentTokenDatasVarSampFields>;
  variance?: Maybe<CurrentTokenDatasVarianceFields>;
};

/** aggregate fields of "current_token_datas" */
export type CurrentTokenDatasAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentTokenDatasSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type CurrentTokenDatasAppendInput = {
  default_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentTokenDatasAvgFields = {
  largest_property_version?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_token_datas". All fields are combined with a logical 'AND'. */
export type CurrentTokenDatasBoolExp = {
  _and?: InputMaybe<Array<CurrentTokenDatasBoolExp>>;
  _not?: InputMaybe<CurrentTokenDatasBoolExp>;
  _or?: InputMaybe<Array<CurrentTokenDatasBoolExp>>;
  collection_data_id_hash?: InputMaybe<StringComparisonExp>;
  collection_name?: InputMaybe<StringComparisonExp>;
  creator_address?: InputMaybe<StringComparisonExp>;
  default_properties?: InputMaybe<JsonbComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  description_mutable?: InputMaybe<BooleanComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  largest_property_version?: InputMaybe<NumericComparisonExp>;
  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  maximum?: InputMaybe<NumericComparisonExp>;
  maximum_mutable?: InputMaybe<BooleanComparisonExp>;
  metadata_uri?: InputMaybe<StringComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  payee_address?: InputMaybe<StringComparisonExp>;
  properties_mutable?: InputMaybe<BooleanComparisonExp>;
  royalty_mutable?: InputMaybe<BooleanComparisonExp>;
  royalty_points_denominator?: InputMaybe<NumericComparisonExp>;
  royalty_points_numerator?: InputMaybe<NumericComparisonExp>;
  supply?: InputMaybe<NumericComparisonExp>;
  token_data_id_hash?: InputMaybe<StringComparisonExp>;
  uri_mutable?: InputMaybe<BooleanComparisonExp>;
};

/** unique or primary key constraints on table "current_token_datas" */
export enum CurrentTokenDatasConstraint {
  /** unique or primary key constraint on columns "token_data_id_hash" */
  CurrentTokenDatasPkey = "current_token_datas_pkey",
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type CurrentTokenDatasDeleteAtPathInput = {
  default_properties?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type CurrentTokenDatasDeleteElemInput = {
  default_properties?: InputMaybe<Scalars["Int"]["input"]>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type CurrentTokenDatasDeleteKeyInput = {
  default_properties?: InputMaybe<Scalars["String"]["input"]>;
};

/** input type for incrementing numeric columns in table "current_token_datas" */
export type CurrentTokenDatasIncInput = {
  largest_property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
  royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
};

/** input type for inserting data into table "current_token_datas" */
export type CurrentTokenDatasInsertInput = {
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  default_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  largest_property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  payee_address?: InputMaybe<Scalars["String"]["input"]>;
  properties_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  royalty_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
  royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate max on columns */
export type CurrentTokenDatasMaxFields = {
  collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  description?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  largest_property_version?: Maybe<Scalars["numeric"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  maximum?: Maybe<Scalars["numeric"]["output"]>;
  metadata_uri?: Maybe<Scalars["String"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  payee_address?: Maybe<Scalars["String"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["numeric"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["numeric"]["output"]>;
  supply?: Maybe<Scalars["numeric"]["output"]>;
  token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentTokenDatasMinFields = {
  collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  description?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  largest_property_version?: Maybe<Scalars["numeric"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  maximum?: Maybe<Scalars["numeric"]["output"]>;
  metadata_uri?: Maybe<Scalars["String"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  payee_address?: Maybe<Scalars["String"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["numeric"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["numeric"]["output"]>;
  supply?: Maybe<Scalars["numeric"]["output"]>;
  token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "current_token_datas" */
export type CurrentTokenDatasMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentTokenDatas>;
};

/** on_conflict condition type for table "current_token_datas" */
export type CurrentTokenDatasOnConflict = {
  constraint: CurrentTokenDatasConstraint;
  update_columns?: Array<CurrentTokenDatasUpdateColumn>;
  where?: InputMaybe<CurrentTokenDatasBoolExp>;
};

/** Ordering options when selecting data from "current_token_datas". */
export type CurrentTokenDatasOrderBy = {
  collection_data_id_hash?: InputMaybe<OrderBy>;
  collection_name?: InputMaybe<OrderBy>;
  creator_address?: InputMaybe<OrderBy>;
  default_properties?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  description_mutable?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  largest_property_version?: InputMaybe<OrderBy>;
  last_transaction_timestamp?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  maximum?: InputMaybe<OrderBy>;
  maximum_mutable?: InputMaybe<OrderBy>;
  metadata_uri?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  payee_address?: InputMaybe<OrderBy>;
  properties_mutable?: InputMaybe<OrderBy>;
  royalty_mutable?: InputMaybe<OrderBy>;
  royalty_points_denominator?: InputMaybe<OrderBy>;
  royalty_points_numerator?: InputMaybe<OrderBy>;
  supply?: InputMaybe<OrderBy>;
  token_data_id_hash?: InputMaybe<OrderBy>;
  uri_mutable?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: current_token_datas */
export type CurrentTokenDatasPkColumnsInput = {
  token_data_id_hash: Scalars["String"]["input"];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type CurrentTokenDatasPrependInput = {
  default_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** select columns of table "current_token_datas" */
export enum CurrentTokenDatasSelectColumn {
  /** column name */
  CollectionDataIdHash = "collection_data_id_hash",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  DefaultProperties = "default_properties",
  /** column name */
  Description = "description",
  /** column name */
  DescriptionMutable = "description_mutable",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LargestPropertyVersion = "largest_property_version",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  Maximum = "maximum",
  /** column name */
  MaximumMutable = "maximum_mutable",
  /** column name */
  MetadataUri = "metadata_uri",
  /** column name */
  Name = "name",
  /** column name */
  PayeeAddress = "payee_address",
  /** column name */
  PropertiesMutable = "properties_mutable",
  /** column name */
  RoyaltyMutable = "royalty_mutable",
  /** column name */
  RoyaltyPointsDenominator = "royalty_points_denominator",
  /** column name */
  RoyaltyPointsNumerator = "royalty_points_numerator",
  /** column name */
  Supply = "supply",
  /** column name */
  TokenDataIdHash = "token_data_id_hash",
  /** column name */
  UriMutable = "uri_mutable",
}

/** input type for updating data in table "current_token_datas" */
export type CurrentTokenDatasSetInput = {
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  default_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  largest_property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  payee_address?: InputMaybe<Scalars["String"]["input"]>;
  properties_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  royalty_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
  royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentTokenDatasStddevFields = {
  largest_property_version?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentTokenDatasStddevPopFields = {
  largest_property_version?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentTokenDatasStddevSampFields = {
  largest_property_version?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_token_datas" */
export type CurrentTokenDatasStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentTokenDatasStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentTokenDatasStreamCursorValueInput = {
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  default_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  largest_property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  payee_address?: InputMaybe<Scalars["String"]["input"]>;
  properties_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  royalty_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
  royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentTokenDatasSumFields = {
  largest_property_version?: Maybe<Scalars["numeric"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  maximum?: Maybe<Scalars["numeric"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["numeric"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["numeric"]["output"]>;
  supply?: Maybe<Scalars["numeric"]["output"]>;
};

/** update columns of table "current_token_datas" */
export enum CurrentTokenDatasUpdateColumn {
  /** column name */
  CollectionDataIdHash = "collection_data_id_hash",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  DefaultProperties = "default_properties",
  /** column name */
  Description = "description",
  /** column name */
  DescriptionMutable = "description_mutable",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LargestPropertyVersion = "largest_property_version",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  Maximum = "maximum",
  /** column name */
  MaximumMutable = "maximum_mutable",
  /** column name */
  MetadataUri = "metadata_uri",
  /** column name */
  Name = "name",
  /** column name */
  PayeeAddress = "payee_address",
  /** column name */
  PropertiesMutable = "properties_mutable",
  /** column name */
  RoyaltyMutable = "royalty_mutable",
  /** column name */
  RoyaltyPointsDenominator = "royalty_points_denominator",
  /** column name */
  RoyaltyPointsNumerator = "royalty_points_numerator",
  /** column name */
  Supply = "supply",
  /** column name */
  TokenDataIdHash = "token_data_id_hash",
  /** column name */
  UriMutable = "uri_mutable",
}

export type CurrentTokenDatasUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<CurrentTokenDatasAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<CurrentTokenDatasDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<CurrentTokenDatasDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<CurrentTokenDatasDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentTokenDatasIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<CurrentTokenDatasPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentTokenDatasSetInput>;
  /** filter the rows which have to be updated */
  where: CurrentTokenDatasBoolExp;
};

/** columns and relationships of "current_token_datas_v2" */
export type CurrentTokenDatasV2 = {
  /** An object relationship */
  cdn_asset_uris?: Maybe<NftMetadataCrawlerParsedAssetUris>;
  /** An object relationship */
  cedra_name?: Maybe<CurrentCedraNames>;
  collection_id: Scalars["String"]["output"];
  /** An object relationship */
  current_collection?: Maybe<CurrentCollectionsV2>;
  /** An object relationship */
  current_royalty_v1?: Maybe<CurrentTokenRoyaltyV1>;
  /** An array relationship */
  current_token_ownerships: Array<CurrentTokenOwnershipsV2>;
  /** An aggregate relationship */
  current_token_ownerships_aggregate: CurrentTokenOwnershipsV2Aggregate;
  decimals?: Maybe<Scalars["bigint"]["output"]>;
  description: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  is_deleted_v2?: Maybe<Scalars["Boolean"]["output"]>;
  is_fungible_v2?: Maybe<Scalars["Boolean"]["output"]>;
  largest_property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
  last_transaction_timestamp: Scalars["timestamp"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  maximum?: Maybe<Scalars["numeric"]["output"]>;
  supply?: Maybe<Scalars["numeric"]["output"]>;
  token_data_id: Scalars["String"]["output"];
  token_name: Scalars["String"]["output"];
  token_properties: Scalars["jsonb"]["output"];
  token_standard: Scalars["String"]["output"];
  token_uri: Scalars["String"]["output"];
};

/** columns and relationships of "current_token_datas_v2" */
export type CurrentTokenDatasV2CurrentTokenOwnershipsArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;
  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
};

/** columns and relationships of "current_token_datas_v2" */
export type CurrentTokenDatasV2CurrentTokenOwnershipsAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;
  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
};

/** columns and relationships of "current_token_datas_v2" */
export type CurrentTokenDatasV2TokenPropertiesArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregated selection of "current_token_datas_v2" */
export type CurrentTokenDatasV2Aggregate = {
  aggregate?: Maybe<CurrentTokenDatasV2AggregateFields>;
  nodes: Array<CurrentTokenDatasV2>;
};

/** aggregate fields of "current_token_datas_v2" */
export type CurrentTokenDatasV2AggregateFields = {
  avg?: Maybe<CurrentTokenDatasV2AvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentTokenDatasV2MaxFields>;
  min?: Maybe<CurrentTokenDatasV2MinFields>;
  stddev?: Maybe<CurrentTokenDatasV2StddevFields>;
  stddev_pop?: Maybe<CurrentTokenDatasV2StddevPopFields>;
  stddev_samp?: Maybe<CurrentTokenDatasV2StddevSampFields>;
  sum?: Maybe<CurrentTokenDatasV2SumFields>;
  var_pop?: Maybe<CurrentTokenDatasV2VarPopFields>;
  var_samp?: Maybe<CurrentTokenDatasV2VarSampFields>;
  variance?: Maybe<CurrentTokenDatasV2VarianceFields>;
};

/** aggregate fields of "current_token_datas_v2" */
export type CurrentTokenDatasV2AggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentTokenDatasV2SelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type CurrentTokenDatasV2AppendInput = {
  token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentTokenDatasV2AvgFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_token_datas_v2". All fields are combined with a logical 'AND'. */
export type CurrentTokenDatasV2BoolExp = {
  _and?: InputMaybe<Array<CurrentTokenDatasV2BoolExp>>;
  _not?: InputMaybe<CurrentTokenDatasV2BoolExp>;
  _or?: InputMaybe<Array<CurrentTokenDatasV2BoolExp>>;
  cdn_asset_uris?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;
  cedra_name?: InputMaybe<CurrentCedraNamesBoolExp>;
  collection_id?: InputMaybe<StringComparisonExp>;
  current_collection?: InputMaybe<CurrentCollectionsV2BoolExp>;
  current_royalty_v1?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;
  current_token_ownerships?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
  current_token_ownerships_aggregate?: InputMaybe<CurrentTokenOwnershipsV2AggregateBoolExp>;
  decimals?: InputMaybe<BigintComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_deleted_v2?: InputMaybe<BooleanComparisonExp>;
  is_fungible_v2?: InputMaybe<BooleanComparisonExp>;
  largest_property_version_v1?: InputMaybe<NumericComparisonExp>;
  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  maximum?: InputMaybe<NumericComparisonExp>;
  supply?: InputMaybe<NumericComparisonExp>;
  token_data_id?: InputMaybe<StringComparisonExp>;
  token_name?: InputMaybe<StringComparisonExp>;
  token_properties?: InputMaybe<JsonbComparisonExp>;
  token_standard?: InputMaybe<StringComparisonExp>;
  token_uri?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "current_token_datas_v2" */
export enum CurrentTokenDatasV2Constraint {
  /** unique or primary key constraint on columns "token_data_id" */
  CurrentTokenDatasV2Pkey = "current_token_datas_v2_pkey",
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type CurrentTokenDatasV2DeleteAtPathInput = {
  token_properties?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type CurrentTokenDatasV2DeleteElemInput = {
  token_properties?: InputMaybe<Scalars["Int"]["input"]>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type CurrentTokenDatasV2DeleteKeyInput = {
  token_properties?: InputMaybe<Scalars["String"]["input"]>;
};

/** input type for incrementing numeric columns in table "current_token_datas_v2" */
export type CurrentTokenDatasV2IncInput = {
  decimals?: InputMaybe<Scalars["bigint"]["input"]>;
  largest_property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
};

/** input type for inserting data into table "current_token_datas_v2" */
export type CurrentTokenDatasV2InsertInput = {
  cdn_asset_uris?: InputMaybe<NftMetadataCrawlerParsedAssetUrisObjRelInsertInput>;
  cedra_name?: InputMaybe<CurrentCedraNamesObjRelInsertInput>;
  collection_id?: InputMaybe<Scalars["String"]["input"]>;
  current_collection?: InputMaybe<CurrentCollectionsV2ObjRelInsertInput>;
  current_royalty_v1?: InputMaybe<CurrentTokenRoyaltyV1ObjRelInsertInput>;
  current_token_ownerships?: InputMaybe<CurrentTokenOwnershipsV2ArrRelInsertInput>;
  decimals?: InputMaybe<Scalars["bigint"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  largest_property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  token_uri?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type CurrentTokenDatasV2MaxFields = {
  collection_id?: Maybe<Scalars["String"]["output"]>;
  decimals?: Maybe<Scalars["bigint"]["output"]>;
  description?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  largest_property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  maximum?: Maybe<Scalars["numeric"]["output"]>;
  supply?: Maybe<Scalars["numeric"]["output"]>;
  token_data_id?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
  token_uri?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentTokenDatasV2MinFields = {
  collection_id?: Maybe<Scalars["String"]["output"]>;
  decimals?: Maybe<Scalars["bigint"]["output"]>;
  description?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  largest_property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  maximum?: Maybe<Scalars["numeric"]["output"]>;
  supply?: Maybe<Scalars["numeric"]["output"]>;
  token_data_id?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
  token_uri?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "current_token_datas_v2" */
export type CurrentTokenDatasV2MutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentTokenDatasV2>;
};

/** input type for inserting object relation for remote table "current_token_datas_v2" */
export type CurrentTokenDatasV2ObjRelInsertInput = {
  data: CurrentTokenDatasV2InsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<CurrentTokenDatasV2OnConflict>;
};

/** on_conflict condition type for table "current_token_datas_v2" */
export type CurrentTokenDatasV2OnConflict = {
  constraint: CurrentTokenDatasV2Constraint;
  update_columns?: Array<CurrentTokenDatasV2UpdateColumn>;
  where?: InputMaybe<CurrentTokenDatasV2BoolExp>;
};

/** Ordering options when selecting data from "current_token_datas_v2". */
export type CurrentTokenDatasV2OrderBy = {
  cdn_asset_uris?: InputMaybe<NftMetadataCrawlerParsedAssetUrisOrderBy>;
  cedra_name?: InputMaybe<CurrentCedraNamesOrderBy>;
  collection_id?: InputMaybe<OrderBy>;
  current_collection?: InputMaybe<CurrentCollectionsV2OrderBy>;
  current_royalty_v1?: InputMaybe<CurrentTokenRoyaltyV1OrderBy>;
  current_token_ownerships_aggregate?: InputMaybe<CurrentTokenOwnershipsV2AggregateOrderBy>;
  decimals?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_deleted_v2?: InputMaybe<OrderBy>;
  is_fungible_v2?: InputMaybe<OrderBy>;
  largest_property_version_v1?: InputMaybe<OrderBy>;
  last_transaction_timestamp?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  maximum?: InputMaybe<OrderBy>;
  supply?: InputMaybe<OrderBy>;
  token_data_id?: InputMaybe<OrderBy>;
  token_name?: InputMaybe<OrderBy>;
  token_properties?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
  token_uri?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: current_token_datas_v2 */
export type CurrentTokenDatasV2PkColumnsInput = {
  token_data_id: Scalars["String"]["input"];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type CurrentTokenDatasV2PrependInput = {
  token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** select columns of table "current_token_datas_v2" */
export enum CurrentTokenDatasV2SelectColumn {
  /** column name */
  CollectionId = "collection_id",
  /** column name */
  Decimals = "decimals",
  /** column name */
  Description = "description",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeletedV2 = "is_deleted_v2",
  /** column name */
  IsFungibleV2 = "is_fungible_v2",
  /** column name */
  LargestPropertyVersionV1 = "largest_property_version_v1",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  Maximum = "maximum",
  /** column name */
  Supply = "supply",
  /** column name */
  TokenDataId = "token_data_id",
  /** column name */
  TokenName = "token_name",
  /** column name */
  TokenProperties = "token_properties",
  /** column name */
  TokenStandard = "token_standard",
  /** column name */
  TokenUri = "token_uri",
}

/** input type for updating data in table "current_token_datas_v2" */
export type CurrentTokenDatasV2SetInput = {
  collection_id?: InputMaybe<Scalars["String"]["input"]>;
  decimals?: InputMaybe<Scalars["bigint"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  largest_property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  token_uri?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentTokenDatasV2StddevFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentTokenDatasV2StddevPopFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentTokenDatasV2StddevSampFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_token_datas_v2" */
export type CurrentTokenDatasV2StreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentTokenDatasV2StreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentTokenDatasV2StreamCursorValueInput = {
  collection_id?: InputMaybe<Scalars["String"]["input"]>;
  decimals?: InputMaybe<Scalars["bigint"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  largest_property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  token_uri?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentTokenDatasV2SumFields = {
  decimals?: Maybe<Scalars["bigint"]["output"]>;
  largest_property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  maximum?: Maybe<Scalars["numeric"]["output"]>;
  supply?: Maybe<Scalars["numeric"]["output"]>;
};

/** update columns of table "current_token_datas_v2" */
export enum CurrentTokenDatasV2UpdateColumn {
  /** column name */
  CollectionId = "collection_id",
  /** column name */
  Decimals = "decimals",
  /** column name */
  Description = "description",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeletedV2 = "is_deleted_v2",
  /** column name */
  IsFungibleV2 = "is_fungible_v2",
  /** column name */
  LargestPropertyVersionV1 = "largest_property_version_v1",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  Maximum = "maximum",
  /** column name */
  Supply = "supply",
  /** column name */
  TokenDataId = "token_data_id",
  /** column name */
  TokenName = "token_name",
  /** column name */
  TokenProperties = "token_properties",
  /** column name */
  TokenStandard = "token_standard",
  /** column name */
  TokenUri = "token_uri",
}

export type CurrentTokenDatasV2Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<CurrentTokenDatasV2AppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<CurrentTokenDatasV2DeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<CurrentTokenDatasV2DeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<CurrentTokenDatasV2DeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentTokenDatasV2IncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<CurrentTokenDatasV2PrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentTokenDatasV2SetInput>;
  /** filter the rows which have to be updated */
  where: CurrentTokenDatasV2BoolExp;
};

/** aggregate var_pop on columns */
export type CurrentTokenDatasV2VarPopFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentTokenDatasV2VarSampFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentTokenDatasV2VarianceFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_pop on columns */
export type CurrentTokenDatasVarPopFields = {
  largest_property_version?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentTokenDatasVarSampFields = {
  largest_property_version?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentTokenDatasVarianceFields = {
  largest_property_version?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "current_token_ownerships" */
export type CurrentTokenOwnerships = {
  amount: Scalars["numeric"]["output"];
  collection_data_id_hash: Scalars["String"]["output"];
  collection_name: Scalars["String"]["output"];
  creator_address: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  last_transaction_timestamp: Scalars["timestamp"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  name: Scalars["String"]["output"];
  owner_address: Scalars["String"]["output"];
  property_version: Scalars["numeric"]["output"];
  table_type: Scalars["String"]["output"];
  token_data_id_hash: Scalars["String"]["output"];
  token_properties: Scalars["jsonb"]["output"];
};

/** columns and relationships of "current_token_ownerships" */
export type CurrentTokenOwnershipsTokenPropertiesArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregated selection of "current_token_ownerships" */
export type CurrentTokenOwnershipsAggregate = {
  aggregate?: Maybe<CurrentTokenOwnershipsAggregateFields>;
  nodes: Array<CurrentTokenOwnerships>;
};

/** aggregate fields of "current_token_ownerships" */
export type CurrentTokenOwnershipsAggregateFields = {
  avg?: Maybe<CurrentTokenOwnershipsAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentTokenOwnershipsMaxFields>;
  min?: Maybe<CurrentTokenOwnershipsMinFields>;
  stddev?: Maybe<CurrentTokenOwnershipsStddevFields>;
  stddev_pop?: Maybe<CurrentTokenOwnershipsStddevPopFields>;
  stddev_samp?: Maybe<CurrentTokenOwnershipsStddevSampFields>;
  sum?: Maybe<CurrentTokenOwnershipsSumFields>;
  var_pop?: Maybe<CurrentTokenOwnershipsVarPopFields>;
  var_samp?: Maybe<CurrentTokenOwnershipsVarSampFields>;
  variance?: Maybe<CurrentTokenOwnershipsVarianceFields>;
};

/** aggregate fields of "current_token_ownerships" */
export type CurrentTokenOwnershipsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type CurrentTokenOwnershipsAppendInput = {
  token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentTokenOwnershipsAvgFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_token_ownerships". All fields are combined with a logical 'AND'. */
export type CurrentTokenOwnershipsBoolExp = {
  _and?: InputMaybe<Array<CurrentTokenOwnershipsBoolExp>>;
  _not?: InputMaybe<CurrentTokenOwnershipsBoolExp>;
  _or?: InputMaybe<Array<CurrentTokenOwnershipsBoolExp>>;
  amount?: InputMaybe<NumericComparisonExp>;
  collection_data_id_hash?: InputMaybe<StringComparisonExp>;
  collection_name?: InputMaybe<StringComparisonExp>;
  creator_address?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  owner_address?: InputMaybe<StringComparisonExp>;
  property_version?: InputMaybe<NumericComparisonExp>;
  table_type?: InputMaybe<StringComparisonExp>;
  token_data_id_hash?: InputMaybe<StringComparisonExp>;
  token_properties?: InputMaybe<JsonbComparisonExp>;
};

/** unique or primary key constraints on table "current_token_ownerships" */
export enum CurrentTokenOwnershipsConstraint {
  /** unique or primary key constraint on columns "owner_address", "property_version", "token_data_id_hash" */
  CurrentTokenOwnershipsPkey = "current_token_ownerships_pkey",
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type CurrentTokenOwnershipsDeleteAtPathInput = {
  token_properties?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type CurrentTokenOwnershipsDeleteElemInput = {
  token_properties?: InputMaybe<Scalars["Int"]["input"]>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type CurrentTokenOwnershipsDeleteKeyInput = {
  token_properties?: InputMaybe<Scalars["String"]["input"]>;
};

/** input type for incrementing numeric columns in table "current_token_ownerships" */
export type CurrentTokenOwnershipsIncInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  property_version?: InputMaybe<Scalars["numeric"]["input"]>;
};

/** input type for inserting data into table "current_token_ownerships" */
export type CurrentTokenOwnershipsInsertInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  table_type?: InputMaybe<Scalars["String"]["input"]>;
  token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** aggregate max on columns */
export type CurrentTokenOwnershipsMaxFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  property_version?: Maybe<Scalars["numeric"]["output"]>;
  table_type?: Maybe<Scalars["String"]["output"]>;
  token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentTokenOwnershipsMinFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  property_version?: Maybe<Scalars["numeric"]["output"]>;
  table_type?: Maybe<Scalars["String"]["output"]>;
  token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "current_token_ownerships" */
export type CurrentTokenOwnershipsMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentTokenOwnerships>;
};

/** on_conflict condition type for table "current_token_ownerships" */
export type CurrentTokenOwnershipsOnConflict = {
  constraint: CurrentTokenOwnershipsConstraint;
  update_columns?: Array<CurrentTokenOwnershipsUpdateColumn>;
  where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;
};

/** Ordering options when selecting data from "current_token_ownerships". */
export type CurrentTokenOwnershipsOrderBy = {
  amount?: InputMaybe<OrderBy>;
  collection_data_id_hash?: InputMaybe<OrderBy>;
  collection_name?: InputMaybe<OrderBy>;
  creator_address?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  last_transaction_timestamp?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  owner_address?: InputMaybe<OrderBy>;
  property_version?: InputMaybe<OrderBy>;
  table_type?: InputMaybe<OrderBy>;
  token_data_id_hash?: InputMaybe<OrderBy>;
  token_properties?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: current_token_ownerships */
export type CurrentTokenOwnershipsPkColumnsInput = {
  owner_address: Scalars["String"]["input"];
  property_version: Scalars["numeric"]["input"];
  token_data_id_hash: Scalars["String"]["input"];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type CurrentTokenOwnershipsPrependInput = {
  token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** select columns of table "current_token_ownerships" */
export enum CurrentTokenOwnershipsSelectColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  CollectionDataIdHash = "collection_data_id_hash",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  Name = "name",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  PropertyVersion = "property_version",
  /** column name */
  TableType = "table_type",
  /** column name */
  TokenDataIdHash = "token_data_id_hash",
  /** column name */
  TokenProperties = "token_properties",
}

/** input type for updating data in table "current_token_ownerships" */
export type CurrentTokenOwnershipsSetInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  table_type?: InputMaybe<Scalars["String"]["input"]>;
  token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentTokenOwnershipsStddevFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentTokenOwnershipsStddevPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentTokenOwnershipsStddevSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_token_ownerships" */
export type CurrentTokenOwnershipsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentTokenOwnershipsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentTokenOwnershipsStreamCursorValueInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  table_type?: InputMaybe<Scalars["String"]["input"]>;
  token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentTokenOwnershipsSumFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  property_version?: Maybe<Scalars["numeric"]["output"]>;
};

/** update columns of table "current_token_ownerships" */
export enum CurrentTokenOwnershipsUpdateColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  CollectionDataIdHash = "collection_data_id_hash",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  Name = "name",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  PropertyVersion = "property_version",
  /** column name */
  TableType = "table_type",
  /** column name */
  TokenDataIdHash = "token_data_id_hash",
  /** column name */
  TokenProperties = "token_properties",
}

export type CurrentTokenOwnershipsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<CurrentTokenOwnershipsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<CurrentTokenOwnershipsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<CurrentTokenOwnershipsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<CurrentTokenOwnershipsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentTokenOwnershipsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<CurrentTokenOwnershipsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentTokenOwnershipsSetInput>;
  /** filter the rows which have to be updated */
  where: CurrentTokenOwnershipsBoolExp;
};

/** columns and relationships of "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2 = {
  amount: Scalars["numeric"]["output"];
  /** An array relationship */
  composed_nfts: Array<CurrentTokenOwnershipsV2>;
  /** An aggregate relationship */
  composed_nfts_aggregate: CurrentTokenOwnershipsV2Aggregate;
  /** An object relationship */
  current_token_data?: Maybe<CurrentTokenDatasV2>;
  inserted_at: Scalars["timestamp"]["output"];
  is_fungible_v2?: Maybe<Scalars["Boolean"]["output"]>;
  is_soulbound_v2?: Maybe<Scalars["Boolean"]["output"]>;
  last_transaction_timestamp: Scalars["timestamp"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  non_transferrable_by_owner?: Maybe<Scalars["Boolean"]["output"]>;
  owner_address: Scalars["String"]["output"];
  property_version_v1: Scalars["numeric"]["output"];
  storage_id: Scalars["String"]["output"];
  table_type_v1?: Maybe<Scalars["String"]["output"]>;
  token_data_id: Scalars["String"]["output"];
  token_properties_mutated_v1?: Maybe<Scalars["jsonb"]["output"]>;
  token_standard: Scalars["String"]["output"];
};

/** columns and relationships of "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2ComposedNftsArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;
  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
};

/** columns and relationships of "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2ComposedNftsAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;
  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
};

/** columns and relationships of "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2TokenPropertiesMutatedV1Args = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregated selection of "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2Aggregate = {
  aggregate?: Maybe<CurrentTokenOwnershipsV2AggregateFields>;
  nodes: Array<CurrentTokenOwnershipsV2>;
};

export type CurrentTokenOwnershipsV2AggregateBoolExp = {
  bool_and?: InputMaybe<CurrentTokenOwnershipsV2AggregateBoolExpBoolAnd>;
  bool_or?: InputMaybe<CurrentTokenOwnershipsV2AggregateBoolExpBoolOr>;
  count?: InputMaybe<CurrentTokenOwnershipsV2AggregateBoolExpCount>;
};

export type CurrentTokenOwnershipsV2AggregateBoolExpBoolAnd = {
  arguments: CurrentTokenOwnershipsV2SelectColumnCurrentTokenOwnershipsV2AggregateBoolExpBoolAndArgumentsColumns;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
  filter?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
  predicate: BooleanComparisonExp;
};

export type CurrentTokenOwnershipsV2AggregateBoolExpBoolOr = {
  arguments: CurrentTokenOwnershipsV2SelectColumnCurrentTokenOwnershipsV2AggregateBoolExpBoolOrArgumentsColumns;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
  filter?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
  predicate: BooleanComparisonExp;
};

export type CurrentTokenOwnershipsV2AggregateBoolExpCount = {
  arguments?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
  filter?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2AggregateFields = {
  avg?: Maybe<CurrentTokenOwnershipsV2AvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentTokenOwnershipsV2MaxFields>;
  min?: Maybe<CurrentTokenOwnershipsV2MinFields>;
  stddev?: Maybe<CurrentTokenOwnershipsV2StddevFields>;
  stddev_pop?: Maybe<CurrentTokenOwnershipsV2StddevPopFields>;
  stddev_samp?: Maybe<CurrentTokenOwnershipsV2StddevSampFields>;
  sum?: Maybe<CurrentTokenOwnershipsV2SumFields>;
  var_pop?: Maybe<CurrentTokenOwnershipsV2VarPopFields>;
  var_samp?: Maybe<CurrentTokenOwnershipsV2VarSampFields>;
  variance?: Maybe<CurrentTokenOwnershipsV2VarianceFields>;
};

/** aggregate fields of "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2AggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** order by aggregate values of table "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2AggregateOrderBy = {
  avg?: InputMaybe<CurrentTokenOwnershipsV2AvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<CurrentTokenOwnershipsV2MaxOrderBy>;
  min?: InputMaybe<CurrentTokenOwnershipsV2MinOrderBy>;
  stddev?: InputMaybe<CurrentTokenOwnershipsV2StddevOrderBy>;
  stddev_pop?: InputMaybe<CurrentTokenOwnershipsV2StddevPopOrderBy>;
  stddev_samp?: InputMaybe<CurrentTokenOwnershipsV2StddevSampOrderBy>;
  sum?: InputMaybe<CurrentTokenOwnershipsV2SumOrderBy>;
  var_pop?: InputMaybe<CurrentTokenOwnershipsV2VarPopOrderBy>;
  var_samp?: InputMaybe<CurrentTokenOwnershipsV2VarSampOrderBy>;
  variance?: InputMaybe<CurrentTokenOwnershipsV2VarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type CurrentTokenOwnershipsV2AppendInput = {
  token_properties_mutated_v1?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** input type for inserting array relation for remote table "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2ArrRelInsertInput = {
  data: Array<CurrentTokenOwnershipsV2InsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<CurrentTokenOwnershipsV2OnConflict>;
};

/** aggregate avg on columns */
export type CurrentTokenOwnershipsV2AvgFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  property_version_v1?: Maybe<Scalars["Float"]["output"]>;
};

/** order by avg() on columns of table "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2AvgOrderBy = {
  amount?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "current_token_ownerships_v2". All fields are combined with a logical 'AND'. */
export type CurrentTokenOwnershipsV2BoolExp = {
  _and?: InputMaybe<Array<CurrentTokenOwnershipsV2BoolExp>>;
  _not?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
  _or?: InputMaybe<Array<CurrentTokenOwnershipsV2BoolExp>>;
  amount?: InputMaybe<NumericComparisonExp>;
  composed_nfts?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
  composed_nfts_aggregate?: InputMaybe<CurrentTokenOwnershipsV2AggregateBoolExp>;
  current_token_data?: InputMaybe<CurrentTokenDatasV2BoolExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_fungible_v2?: InputMaybe<BooleanComparisonExp>;
  is_soulbound_v2?: InputMaybe<BooleanComparisonExp>;
  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  non_transferrable_by_owner?: InputMaybe<BooleanComparisonExp>;
  owner_address?: InputMaybe<StringComparisonExp>;
  property_version_v1?: InputMaybe<NumericComparisonExp>;
  storage_id?: InputMaybe<StringComparisonExp>;
  table_type_v1?: InputMaybe<StringComparisonExp>;
  token_data_id?: InputMaybe<StringComparisonExp>;
  token_properties_mutated_v1?: InputMaybe<JsonbComparisonExp>;
  token_standard?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "current_token_ownerships_v2" */
export enum CurrentTokenOwnershipsV2Constraint {
  /** unique or primary key constraint on columns "owner_address", "property_version_v1", "storage_id", "token_data_id" */
  CurrentTokenOwnershipsV2Pkey = "current_token_ownerships_v2_pkey",
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type CurrentTokenOwnershipsV2DeleteAtPathInput = {
  token_properties_mutated_v1?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type CurrentTokenOwnershipsV2DeleteElemInput = {
  token_properties_mutated_v1?: InputMaybe<Scalars["Int"]["input"]>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type CurrentTokenOwnershipsV2DeleteKeyInput = {
  token_properties_mutated_v1?: InputMaybe<Scalars["String"]["input"]>;
};

/** input type for incrementing numeric columns in table "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2IncInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
};

/** input type for inserting data into table "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2InsertInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  composed_nfts?: InputMaybe<CurrentTokenOwnershipsV2ArrRelInsertInput>;
  current_token_data?: InputMaybe<CurrentTokenDatasV2ObjRelInsertInput>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_soulbound_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  non_transferrable_by_owner?: InputMaybe<Scalars["Boolean"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  storage_id?: InputMaybe<Scalars["String"]["input"]>;
  table_type_v1?: InputMaybe<Scalars["String"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
  token_properties_mutated_v1?: InputMaybe<Scalars["jsonb"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type CurrentTokenOwnershipsV2MaxFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
  storage_id?: Maybe<Scalars["String"]["output"]>;
  table_type_v1?: Maybe<Scalars["String"]["output"]>;
  token_data_id?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
};

/** order by max() on columns of table "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2MaxOrderBy = {
  amount?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  last_transaction_timestamp?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  owner_address?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
  storage_id?: InputMaybe<OrderBy>;
  table_type_v1?: InputMaybe<OrderBy>;
  token_data_id?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type CurrentTokenOwnershipsV2MinFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
  storage_id?: Maybe<Scalars["String"]["output"]>;
  table_type_v1?: Maybe<Scalars["String"]["output"]>;
  token_data_id?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
};

/** order by min() on columns of table "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2MinOrderBy = {
  amount?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  last_transaction_timestamp?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  owner_address?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
  storage_id?: InputMaybe<OrderBy>;
  table_type_v1?: InputMaybe<OrderBy>;
  token_data_id?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2MutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentTokenOwnershipsV2>;
};

/** on_conflict condition type for table "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2OnConflict = {
  constraint: CurrentTokenOwnershipsV2Constraint;
  update_columns?: Array<CurrentTokenOwnershipsV2UpdateColumn>;
  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
};

/** Ordering options when selecting data from "current_token_ownerships_v2". */
export type CurrentTokenOwnershipsV2OrderBy = {
  amount?: InputMaybe<OrderBy>;
  composed_nfts_aggregate?: InputMaybe<CurrentTokenOwnershipsV2AggregateOrderBy>;
  current_token_data?: InputMaybe<CurrentTokenDatasV2OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_fungible_v2?: InputMaybe<OrderBy>;
  is_soulbound_v2?: InputMaybe<OrderBy>;
  last_transaction_timestamp?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  non_transferrable_by_owner?: InputMaybe<OrderBy>;
  owner_address?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
  storage_id?: InputMaybe<OrderBy>;
  table_type_v1?: InputMaybe<OrderBy>;
  token_data_id?: InputMaybe<OrderBy>;
  token_properties_mutated_v1?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: current_token_ownerships_v2 */
export type CurrentTokenOwnershipsV2PkColumnsInput = {
  owner_address: Scalars["String"]["input"];
  property_version_v1: Scalars["numeric"]["input"];
  storage_id: Scalars["String"]["input"];
  token_data_id: Scalars["String"]["input"];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type CurrentTokenOwnershipsV2PrependInput = {
  token_properties_mutated_v1?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** select columns of table "current_token_ownerships_v2" */
export enum CurrentTokenOwnershipsV2SelectColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsFungibleV2 = "is_fungible_v2",
  /** column name */
  IsSoulboundV2 = "is_soulbound_v2",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  NonTransferrableByOwner = "non_transferrable_by_owner",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  PropertyVersionV1 = "property_version_v1",
  /** column name */
  StorageId = "storage_id",
  /** column name */
  TableTypeV1 = "table_type_v1",
  /** column name */
  TokenDataId = "token_data_id",
  /** column name */
  TokenPropertiesMutatedV1 = "token_properties_mutated_v1",
  /** column name */
  TokenStandard = "token_standard",
}

/** select "current_token_ownerships_v2_aggregate_bool_exp_bool_and_arguments_columns" columns of table "current_token_ownerships_v2" */
export enum CurrentTokenOwnershipsV2SelectColumnCurrentTokenOwnershipsV2AggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  IsFungibleV2 = "is_fungible_v2",
  /** column name */
  IsSoulboundV2 = "is_soulbound_v2",
  /** column name */
  NonTransferrableByOwner = "non_transferrable_by_owner",
}

/** select "current_token_ownerships_v2_aggregate_bool_exp_bool_or_arguments_columns" columns of table "current_token_ownerships_v2" */
export enum CurrentTokenOwnershipsV2SelectColumnCurrentTokenOwnershipsV2AggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  IsFungibleV2 = "is_fungible_v2",
  /** column name */
  IsSoulboundV2 = "is_soulbound_v2",
  /** column name */
  NonTransferrableByOwner = "non_transferrable_by_owner",
}

/** input type for updating data in table "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2SetInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_soulbound_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  non_transferrable_by_owner?: InputMaybe<Scalars["Boolean"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  storage_id?: InputMaybe<Scalars["String"]["input"]>;
  table_type_v1?: InputMaybe<Scalars["String"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
  token_properties_mutated_v1?: InputMaybe<Scalars["jsonb"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentTokenOwnershipsV2StddevFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  property_version_v1?: Maybe<Scalars["Float"]["output"]>;
};

/** order by stddev() on columns of table "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2StddevOrderBy = {
  amount?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type CurrentTokenOwnershipsV2StddevPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  property_version_v1?: Maybe<Scalars["Float"]["output"]>;
};

/** order by stddev_pop() on columns of table "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2StddevPopOrderBy = {
  amount?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type CurrentTokenOwnershipsV2StddevSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  property_version_v1?: Maybe<Scalars["Float"]["output"]>;
};

/** order by stddev_samp() on columns of table "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2StddevSampOrderBy = {
  amount?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2StreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentTokenOwnershipsV2StreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentTokenOwnershipsV2StreamCursorValueInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_soulbound_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  non_transferrable_by_owner?: InputMaybe<Scalars["Boolean"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  storage_id?: InputMaybe<Scalars["String"]["input"]>;
  table_type_v1?: InputMaybe<Scalars["String"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
  token_properties_mutated_v1?: InputMaybe<Scalars["jsonb"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentTokenOwnershipsV2SumFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
};

/** order by sum() on columns of table "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2SumOrderBy = {
  amount?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
};

/** update columns of table "current_token_ownerships_v2" */
export enum CurrentTokenOwnershipsV2UpdateColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsFungibleV2 = "is_fungible_v2",
  /** column name */
  IsSoulboundV2 = "is_soulbound_v2",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  NonTransferrableByOwner = "non_transferrable_by_owner",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  PropertyVersionV1 = "property_version_v1",
  /** column name */
  StorageId = "storage_id",
  /** column name */
  TableTypeV1 = "table_type_v1",
  /** column name */
  TokenDataId = "token_data_id",
  /** column name */
  TokenPropertiesMutatedV1 = "token_properties_mutated_v1",
  /** column name */
  TokenStandard = "token_standard",
}

export type CurrentTokenOwnershipsV2Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<CurrentTokenOwnershipsV2AppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<CurrentTokenOwnershipsV2DeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<CurrentTokenOwnershipsV2DeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<CurrentTokenOwnershipsV2DeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentTokenOwnershipsV2IncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<CurrentTokenOwnershipsV2PrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentTokenOwnershipsV2SetInput>;
  /** filter the rows which have to be updated */
  where: CurrentTokenOwnershipsV2BoolExp;
};

/** aggregate var_pop on columns */
export type CurrentTokenOwnershipsV2VarPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  property_version_v1?: Maybe<Scalars["Float"]["output"]>;
};

/** order by var_pop() on columns of table "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2VarPopOrderBy = {
  amount?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type CurrentTokenOwnershipsV2VarSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  property_version_v1?: Maybe<Scalars["Float"]["output"]>;
};

/** order by var_samp() on columns of table "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2VarSampOrderBy = {
  amount?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type CurrentTokenOwnershipsV2VarianceFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  property_version_v1?: Maybe<Scalars["Float"]["output"]>;
};

/** order by variance() on columns of table "current_token_ownerships_v2" */
export type CurrentTokenOwnershipsV2VarianceOrderBy = {
  amount?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
};

/** aggregate var_pop on columns */
export type CurrentTokenOwnershipsVarPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentTokenOwnershipsVarSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentTokenOwnershipsVarianceFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "current_token_pending_claims" */
export type CurrentTokenPendingClaims = {
  amount: Scalars["numeric"]["output"];
  collection_data_id_hash: Scalars["String"]["output"];
  collection_id: Scalars["String"]["output"];
  collection_name: Scalars["String"]["output"];
  creator_address: Scalars["String"]["output"];
  /** An object relationship */
  current_collection_v2?: Maybe<CurrentCollectionsV2>;
  /** An object relationship */
  current_token_data_v2?: Maybe<CurrentTokenDatasV2>;
  from_address: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  last_transaction_timestamp: Scalars["timestamp"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  name: Scalars["String"]["output"];
  property_version: Scalars["numeric"]["output"];
  table_handle: Scalars["String"]["output"];
  to_address: Scalars["String"]["output"];
  token_data_id: Scalars["String"]["output"];
  token_data_id_hash: Scalars["String"]["output"];
};

/** aggregated selection of "current_token_pending_claims" */
export type CurrentTokenPendingClaimsAggregate = {
  aggregate?: Maybe<CurrentTokenPendingClaimsAggregateFields>;
  nodes: Array<CurrentTokenPendingClaims>;
};

/** aggregate fields of "current_token_pending_claims" */
export type CurrentTokenPendingClaimsAggregateFields = {
  avg?: Maybe<CurrentTokenPendingClaimsAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentTokenPendingClaimsMaxFields>;
  min?: Maybe<CurrentTokenPendingClaimsMinFields>;
  stddev?: Maybe<CurrentTokenPendingClaimsStddevFields>;
  stddev_pop?: Maybe<CurrentTokenPendingClaimsStddevPopFields>;
  stddev_samp?: Maybe<CurrentTokenPendingClaimsStddevSampFields>;
  sum?: Maybe<CurrentTokenPendingClaimsSumFields>;
  var_pop?: Maybe<CurrentTokenPendingClaimsVarPopFields>;
  var_samp?: Maybe<CurrentTokenPendingClaimsVarSampFields>;
  variance?: Maybe<CurrentTokenPendingClaimsVarianceFields>;
};

/** aggregate fields of "current_token_pending_claims" */
export type CurrentTokenPendingClaimsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentTokenPendingClaimsSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentTokenPendingClaimsAvgFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_token_pending_claims". All fields are combined with a logical 'AND'. */
export type CurrentTokenPendingClaimsBoolExp = {
  _and?: InputMaybe<Array<CurrentTokenPendingClaimsBoolExp>>;
  _not?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;
  _or?: InputMaybe<Array<CurrentTokenPendingClaimsBoolExp>>;
  amount?: InputMaybe<NumericComparisonExp>;
  collection_data_id_hash?: InputMaybe<StringComparisonExp>;
  collection_id?: InputMaybe<StringComparisonExp>;
  collection_name?: InputMaybe<StringComparisonExp>;
  creator_address?: InputMaybe<StringComparisonExp>;
  current_collection_v2?: InputMaybe<CurrentCollectionsV2BoolExp>;
  current_token_data_v2?: InputMaybe<CurrentTokenDatasV2BoolExp>;
  from_address?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  property_version?: InputMaybe<NumericComparisonExp>;
  table_handle?: InputMaybe<StringComparisonExp>;
  to_address?: InputMaybe<StringComparisonExp>;
  token_data_id?: InputMaybe<StringComparisonExp>;
  token_data_id_hash?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "current_token_pending_claims" */
export enum CurrentTokenPendingClaimsConstraint {
  /** unique or primary key constraint on columns "to_address", "property_version", "from_address", "token_data_id_hash" */
  CurrentTokenPendingClaimsPkey = "current_token_pending_claims_pkey",
}

/** input type for incrementing numeric columns in table "current_token_pending_claims" */
export type CurrentTokenPendingClaimsIncInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  property_version?: InputMaybe<Scalars["numeric"]["input"]>;
};

/** input type for inserting data into table "current_token_pending_claims" */
export type CurrentTokenPendingClaimsInsertInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_id?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  current_collection_v2?: InputMaybe<CurrentCollectionsV2ObjRelInsertInput>;
  current_token_data_v2?: InputMaybe<CurrentTokenDatasV2ObjRelInsertInput>;
  from_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  to_address?: InputMaybe<Scalars["String"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
  token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type CurrentTokenPendingClaimsMaxFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  collection_id?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  from_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  property_version?: Maybe<Scalars["numeric"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
  to_address?: Maybe<Scalars["String"]["output"]>;
  token_data_id?: Maybe<Scalars["String"]["output"]>;
  token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentTokenPendingClaimsMinFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  collection_id?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  from_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  property_version?: Maybe<Scalars["numeric"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
  to_address?: Maybe<Scalars["String"]["output"]>;
  token_data_id?: Maybe<Scalars["String"]["output"]>;
  token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "current_token_pending_claims" */
export type CurrentTokenPendingClaimsMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentTokenPendingClaims>;
};

/** on_conflict condition type for table "current_token_pending_claims" */
export type CurrentTokenPendingClaimsOnConflict = {
  constraint: CurrentTokenPendingClaimsConstraint;
  update_columns?: Array<CurrentTokenPendingClaimsUpdateColumn>;
  where?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;
};

/** Ordering options when selecting data from "current_token_pending_claims". */
export type CurrentTokenPendingClaimsOrderBy = {
  amount?: InputMaybe<OrderBy>;
  collection_data_id_hash?: InputMaybe<OrderBy>;
  collection_id?: InputMaybe<OrderBy>;
  collection_name?: InputMaybe<OrderBy>;
  creator_address?: InputMaybe<OrderBy>;
  current_collection_v2?: InputMaybe<CurrentCollectionsV2OrderBy>;
  current_token_data_v2?: InputMaybe<CurrentTokenDatasV2OrderBy>;
  from_address?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  last_transaction_timestamp?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  property_version?: InputMaybe<OrderBy>;
  table_handle?: InputMaybe<OrderBy>;
  to_address?: InputMaybe<OrderBy>;
  token_data_id?: InputMaybe<OrderBy>;
  token_data_id_hash?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: current_token_pending_claims */
export type CurrentTokenPendingClaimsPkColumnsInput = {
  from_address: Scalars["String"]["input"];
  property_version: Scalars["numeric"]["input"];
  to_address: Scalars["String"]["input"];
  token_data_id_hash: Scalars["String"]["input"];
};

/** select columns of table "current_token_pending_claims" */
export enum CurrentTokenPendingClaimsSelectColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  CollectionDataIdHash = "collection_data_id_hash",
  /** column name */
  CollectionId = "collection_id",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  FromAddress = "from_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  Name = "name",
  /** column name */
  PropertyVersion = "property_version",
  /** column name */
  TableHandle = "table_handle",
  /** column name */
  ToAddress = "to_address",
  /** column name */
  TokenDataId = "token_data_id",
  /** column name */
  TokenDataIdHash = "token_data_id_hash",
}

/** input type for updating data in table "current_token_pending_claims" */
export type CurrentTokenPendingClaimsSetInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_id?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  from_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  to_address?: InputMaybe<Scalars["String"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
  token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentTokenPendingClaimsStddevFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentTokenPendingClaimsStddevPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentTokenPendingClaimsStddevSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_token_pending_claims" */
export type CurrentTokenPendingClaimsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentTokenPendingClaimsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentTokenPendingClaimsStreamCursorValueInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_id?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  from_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  to_address?: InputMaybe<Scalars["String"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
  token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentTokenPendingClaimsSumFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  property_version?: Maybe<Scalars["numeric"]["output"]>;
};

/** update columns of table "current_token_pending_claims" */
export enum CurrentTokenPendingClaimsUpdateColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  CollectionDataIdHash = "collection_data_id_hash",
  /** column name */
  CollectionId = "collection_id",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  FromAddress = "from_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  Name = "name",
  /** column name */
  PropertyVersion = "property_version",
  /** column name */
  TableHandle = "table_handle",
  /** column name */
  ToAddress = "to_address",
  /** column name */
  TokenDataId = "token_data_id",
  /** column name */
  TokenDataIdHash = "token_data_id_hash",
}

export type CurrentTokenPendingClaimsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentTokenPendingClaimsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentTokenPendingClaimsSetInput>;
  /** filter the rows which have to be updated */
  where: CurrentTokenPendingClaimsBoolExp;
};

/** aggregate var_pop on columns */
export type CurrentTokenPendingClaimsVarPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentTokenPendingClaimsVarSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentTokenPendingClaimsVarianceFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "current_token_royalty_v1" */
export type CurrentTokenRoyaltyV1 = {
  inserted_at: Scalars["timestamp"]["output"];
  last_transaction_timestamp: Scalars["timestamp"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  payee_address: Scalars["String"]["output"];
  royalty_points_denominator: Scalars["numeric"]["output"];
  royalty_points_numerator: Scalars["numeric"]["output"];
  token_data_id: Scalars["String"]["output"];
};

/** aggregated selection of "current_token_royalty_v1" */
export type CurrentTokenRoyaltyV1Aggregate = {
  aggregate?: Maybe<CurrentTokenRoyaltyV1AggregateFields>;
  nodes: Array<CurrentTokenRoyaltyV1>;
};

/** aggregate fields of "current_token_royalty_v1" */
export type CurrentTokenRoyaltyV1AggregateFields = {
  avg?: Maybe<CurrentTokenRoyaltyV1AvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentTokenRoyaltyV1MaxFields>;
  min?: Maybe<CurrentTokenRoyaltyV1MinFields>;
  stddev?: Maybe<CurrentTokenRoyaltyV1StddevFields>;
  stddev_pop?: Maybe<CurrentTokenRoyaltyV1StddevPopFields>;
  stddev_samp?: Maybe<CurrentTokenRoyaltyV1StddevSampFields>;
  sum?: Maybe<CurrentTokenRoyaltyV1SumFields>;
  var_pop?: Maybe<CurrentTokenRoyaltyV1VarPopFields>;
  var_samp?: Maybe<CurrentTokenRoyaltyV1VarSampFields>;
  variance?: Maybe<CurrentTokenRoyaltyV1VarianceFields>;
};

/** aggregate fields of "current_token_royalty_v1" */
export type CurrentTokenRoyaltyV1AggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentTokenRoyaltyV1SelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentTokenRoyaltyV1AvgFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_token_royalty_v1". All fields are combined with a logical 'AND'. */
export type CurrentTokenRoyaltyV1BoolExp = {
  _and?: InputMaybe<Array<CurrentTokenRoyaltyV1BoolExp>>;
  _not?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;
  _or?: InputMaybe<Array<CurrentTokenRoyaltyV1BoolExp>>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  payee_address?: InputMaybe<StringComparisonExp>;
  royalty_points_denominator?: InputMaybe<NumericComparisonExp>;
  royalty_points_numerator?: InputMaybe<NumericComparisonExp>;
  token_data_id?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "current_token_royalty_v1" */
export enum CurrentTokenRoyaltyV1Constraint {
  /** unique or primary key constraint on columns "token_data_id" */
  CurrentTokenRoyaltyV1Pkey = "current_token_royalty_v1_pkey",
}

/** input type for incrementing numeric columns in table "current_token_royalty_v1" */
export type CurrentTokenRoyaltyV1IncInput = {
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
  royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
};

/** input type for inserting data into table "current_token_royalty_v1" */
export type CurrentTokenRoyaltyV1InsertInput = {
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  payee_address?: InputMaybe<Scalars["String"]["input"]>;
  royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
  royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type CurrentTokenRoyaltyV1MaxFields = {
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  payee_address?: Maybe<Scalars["String"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["numeric"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["numeric"]["output"]>;
  token_data_id?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentTokenRoyaltyV1MinFields = {
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  payee_address?: Maybe<Scalars["String"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["numeric"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["numeric"]["output"]>;
  token_data_id?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "current_token_royalty_v1" */
export type CurrentTokenRoyaltyV1MutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentTokenRoyaltyV1>;
};

/** input type for inserting object relation for remote table "current_token_royalty_v1" */
export type CurrentTokenRoyaltyV1ObjRelInsertInput = {
  data: CurrentTokenRoyaltyV1InsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<CurrentTokenRoyaltyV1OnConflict>;
};

/** on_conflict condition type for table "current_token_royalty_v1" */
export type CurrentTokenRoyaltyV1OnConflict = {
  constraint: CurrentTokenRoyaltyV1Constraint;
  update_columns?: Array<CurrentTokenRoyaltyV1UpdateColumn>;
  where?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;
};

/** Ordering options when selecting data from "current_token_royalty_v1". */
export type CurrentTokenRoyaltyV1OrderBy = {
  inserted_at?: InputMaybe<OrderBy>;
  last_transaction_timestamp?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  payee_address?: InputMaybe<OrderBy>;
  royalty_points_denominator?: InputMaybe<OrderBy>;
  royalty_points_numerator?: InputMaybe<OrderBy>;
  token_data_id?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: current_token_royalty_v1 */
export type CurrentTokenRoyaltyV1PkColumnsInput = {
  token_data_id: Scalars["String"]["input"];
};

/** select columns of table "current_token_royalty_v1" */
export enum CurrentTokenRoyaltyV1SelectColumn {
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  PayeeAddress = "payee_address",
  /** column name */
  RoyaltyPointsDenominator = "royalty_points_denominator",
  /** column name */
  RoyaltyPointsNumerator = "royalty_points_numerator",
  /** column name */
  TokenDataId = "token_data_id",
}

/** input type for updating data in table "current_token_royalty_v1" */
export type CurrentTokenRoyaltyV1SetInput = {
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  payee_address?: InputMaybe<Scalars["String"]["input"]>;
  royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
  royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentTokenRoyaltyV1StddevFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentTokenRoyaltyV1StddevPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentTokenRoyaltyV1StddevSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_token_royalty_v1" */
export type CurrentTokenRoyaltyV1StreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentTokenRoyaltyV1StreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentTokenRoyaltyV1StreamCursorValueInput = {
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  payee_address?: InputMaybe<Scalars["String"]["input"]>;
  royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
  royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentTokenRoyaltyV1SumFields = {
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["numeric"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["numeric"]["output"]>;
};

/** update columns of table "current_token_royalty_v1" */
export enum CurrentTokenRoyaltyV1UpdateColumn {
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  PayeeAddress = "payee_address",
  /** column name */
  RoyaltyPointsDenominator = "royalty_points_denominator",
  /** column name */
  RoyaltyPointsNumerator = "royalty_points_numerator",
  /** column name */
  TokenDataId = "token_data_id",
}

export type CurrentTokenRoyaltyV1Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentTokenRoyaltyV1IncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentTokenRoyaltyV1SetInput>;
  /** filter the rows which have to be updated */
  where: CurrentTokenRoyaltyV1BoolExp;
};

/** aggregate var_pop on columns */
export type CurrentTokenRoyaltyV1VarPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentTokenRoyaltyV1VarSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentTokenRoyaltyV1VarianceFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "current_token_v2_metadata" */
export type CurrentTokenV2Metadata = {
  data: Scalars["jsonb"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  object_address: Scalars["String"]["output"];
  resource_type: Scalars["String"]["output"];
  state_key_hash: Scalars["String"]["output"];
};

/** columns and relationships of "current_token_v2_metadata" */
export type CurrentTokenV2MetadataDataArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregated selection of "current_token_v2_metadata" */
export type CurrentTokenV2MetadataAggregate = {
  aggregate?: Maybe<CurrentTokenV2MetadataAggregateFields>;
  nodes: Array<CurrentTokenV2Metadata>;
};

/** aggregate fields of "current_token_v2_metadata" */
export type CurrentTokenV2MetadataAggregateFields = {
  avg?: Maybe<CurrentTokenV2MetadataAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<CurrentTokenV2MetadataMaxFields>;
  min?: Maybe<CurrentTokenV2MetadataMinFields>;
  stddev?: Maybe<CurrentTokenV2MetadataStddevFields>;
  stddev_pop?: Maybe<CurrentTokenV2MetadataStddevPopFields>;
  stddev_samp?: Maybe<CurrentTokenV2MetadataStddevSampFields>;
  sum?: Maybe<CurrentTokenV2MetadataSumFields>;
  var_pop?: Maybe<CurrentTokenV2MetadataVarPopFields>;
  var_samp?: Maybe<CurrentTokenV2MetadataVarSampFields>;
  variance?: Maybe<CurrentTokenV2MetadataVarianceFields>;
};

/** aggregate fields of "current_token_v2_metadata" */
export type CurrentTokenV2MetadataAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentTokenV2MetadataSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type CurrentTokenV2MetadataAppendInput = {
  data?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** aggregate avg on columns */
export type CurrentTokenV2MetadataAvgFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "current_token_v2_metadata". All fields are combined with a logical 'AND'. */
export type CurrentTokenV2MetadataBoolExp = {
  _and?: InputMaybe<Array<CurrentTokenV2MetadataBoolExp>>;
  _not?: InputMaybe<CurrentTokenV2MetadataBoolExp>;
  _or?: InputMaybe<Array<CurrentTokenV2MetadataBoolExp>>;
  data?: InputMaybe<JsonbComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  object_address?: InputMaybe<StringComparisonExp>;
  resource_type?: InputMaybe<StringComparisonExp>;
  state_key_hash?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "current_token_v2_metadata" */
export enum CurrentTokenV2MetadataConstraint {
  /** unique or primary key constraint on columns "object_address", "resource_type" */
  CurrentTokenV2MetadataPkey = "current_token_v2_metadata_pkey",
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type CurrentTokenV2MetadataDeleteAtPathInput = {
  data?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type CurrentTokenV2MetadataDeleteElemInput = {
  data?: InputMaybe<Scalars["Int"]["input"]>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type CurrentTokenV2MetadataDeleteKeyInput = {
  data?: InputMaybe<Scalars["String"]["input"]>;
};

/** input type for incrementing numeric columns in table "current_token_v2_metadata" */
export type CurrentTokenV2MetadataIncInput = {
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "current_token_v2_metadata" */
export type CurrentTokenV2MetadataInsertInput = {
  data?: InputMaybe<Scalars["jsonb"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  object_address?: InputMaybe<Scalars["String"]["input"]>;
  resource_type?: InputMaybe<Scalars["String"]["input"]>;
  state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type CurrentTokenV2MetadataMaxFields = {
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  object_address?: Maybe<Scalars["String"]["output"]>;
  resource_type?: Maybe<Scalars["String"]["output"]>;
  state_key_hash?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type CurrentTokenV2MetadataMinFields = {
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  object_address?: Maybe<Scalars["String"]["output"]>;
  resource_type?: Maybe<Scalars["String"]["output"]>;
  state_key_hash?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "current_token_v2_metadata" */
export type CurrentTokenV2MetadataMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<CurrentTokenV2Metadata>;
};

/** on_conflict condition type for table "current_token_v2_metadata" */
export type CurrentTokenV2MetadataOnConflict = {
  constraint: CurrentTokenV2MetadataConstraint;
  update_columns?: Array<CurrentTokenV2MetadataUpdateColumn>;
  where?: InputMaybe<CurrentTokenV2MetadataBoolExp>;
};

/** Ordering options when selecting data from "current_token_v2_metadata". */
export type CurrentTokenV2MetadataOrderBy = {
  data?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  object_address?: InputMaybe<OrderBy>;
  resource_type?: InputMaybe<OrderBy>;
  state_key_hash?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: current_token_v2_metadata */
export type CurrentTokenV2MetadataPkColumnsInput = {
  object_address: Scalars["String"]["input"];
  resource_type: Scalars["String"]["input"];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type CurrentTokenV2MetadataPrependInput = {
  data?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** select columns of table "current_token_v2_metadata" */
export enum CurrentTokenV2MetadataSelectColumn {
  /** column name */
  Data = "data",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  ObjectAddress = "object_address",
  /** column name */
  ResourceType = "resource_type",
  /** column name */
  StateKeyHash = "state_key_hash",
}

/** input type for updating data in table "current_token_v2_metadata" */
export type CurrentTokenV2MetadataSetInput = {
  data?: InputMaybe<Scalars["jsonb"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  object_address?: InputMaybe<Scalars["String"]["input"]>;
  resource_type?: InputMaybe<Scalars["String"]["input"]>;
  state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type CurrentTokenV2MetadataStddevFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type CurrentTokenV2MetadataStddevPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type CurrentTokenV2MetadataStddevSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "current_token_v2_metadata" */
export type CurrentTokenV2MetadataStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: CurrentTokenV2MetadataStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentTokenV2MetadataStreamCursorValueInput = {
  data?: InputMaybe<Scalars["jsonb"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  object_address?: InputMaybe<Scalars["String"]["input"]>;
  resource_type?: InputMaybe<Scalars["String"]["input"]>;
  state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type CurrentTokenV2MetadataSumFields = {
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "current_token_v2_metadata" */
export enum CurrentTokenV2MetadataUpdateColumn {
  /** column name */
  Data = "data",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  ObjectAddress = "object_address",
  /** column name */
  ResourceType = "resource_type",
  /** column name */
  StateKeyHash = "state_key_hash",
}

export type CurrentTokenV2MetadataUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<CurrentTokenV2MetadataAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<CurrentTokenV2MetadataDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<CurrentTokenV2MetadataDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<CurrentTokenV2MetadataDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CurrentTokenV2MetadataIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<CurrentTokenV2MetadataPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CurrentTokenV2MetadataSetInput>;
  /** filter the rows which have to be updated */
  where: CurrentTokenV2MetadataBoolExp;
};

/** aggregate var_pop on columns */
export type CurrentTokenV2MetadataVarPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type CurrentTokenV2MetadataVarSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type CurrentTokenV2MetadataVarianceFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** ordering argument of a cursor */
export enum CursorOrdering {
  /** ascending ordering of the cursor */
  Asc = "ASC",
  /** descending ordering of the cursor */
  Desc = "DESC",
}

/** columns and relationships of "delegated_staking_activities" */
export type DelegatedStakingActivities = {
  amount: Scalars["numeric"]["output"];
  delegator_address: Scalars["String"]["output"];
  event_index: Scalars["bigint"]["output"];
  event_type: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  pool_address: Scalars["String"]["output"];
  transaction_version: Scalars["bigint"]["output"];
};

/** aggregated selection of "delegated_staking_activities" */
export type DelegatedStakingActivitiesAggregate = {
  aggregate?: Maybe<DelegatedStakingActivitiesAggregateFields>;
  nodes: Array<DelegatedStakingActivities>;
};

export type DelegatedStakingActivitiesAggregateBoolExp = {
  count?: InputMaybe<DelegatedStakingActivitiesAggregateBoolExpCount>;
};

export type DelegatedStakingActivitiesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
  filter?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "delegated_staking_activities" */
export type DelegatedStakingActivitiesAggregateFields = {
  avg?: Maybe<DelegatedStakingActivitiesAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<DelegatedStakingActivitiesMaxFields>;
  min?: Maybe<DelegatedStakingActivitiesMinFields>;
  stddev?: Maybe<DelegatedStakingActivitiesStddevFields>;
  stddev_pop?: Maybe<DelegatedStakingActivitiesStddevPopFields>;
  stddev_samp?: Maybe<DelegatedStakingActivitiesStddevSampFields>;
  sum?: Maybe<DelegatedStakingActivitiesSumFields>;
  var_pop?: Maybe<DelegatedStakingActivitiesVarPopFields>;
  var_samp?: Maybe<DelegatedStakingActivitiesVarSampFields>;
  variance?: Maybe<DelegatedStakingActivitiesVarianceFields>;
};

/** aggregate fields of "delegated_staking_activities" */
export type DelegatedStakingActivitiesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** order by aggregate values of table "delegated_staking_activities" */
export type DelegatedStakingActivitiesAggregateOrderBy = {
  avg?: InputMaybe<DelegatedStakingActivitiesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<DelegatedStakingActivitiesMaxOrderBy>;
  min?: InputMaybe<DelegatedStakingActivitiesMinOrderBy>;
  stddev?: InputMaybe<DelegatedStakingActivitiesStddevOrderBy>;
  stddev_pop?: InputMaybe<DelegatedStakingActivitiesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<DelegatedStakingActivitiesStddevSampOrderBy>;
  sum?: InputMaybe<DelegatedStakingActivitiesSumOrderBy>;
  var_pop?: InputMaybe<DelegatedStakingActivitiesVarPopOrderBy>;
  var_samp?: InputMaybe<DelegatedStakingActivitiesVarSampOrderBy>;
  variance?: InputMaybe<DelegatedStakingActivitiesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "delegated_staking_activities" */
export type DelegatedStakingActivitiesArrRelInsertInput = {
  data: Array<DelegatedStakingActivitiesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<DelegatedStakingActivitiesOnConflict>;
};

/** aggregate avg on columns */
export type DelegatedStakingActivitiesAvgFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** order by avg() on columns of table "delegated_staking_activities" */
export type DelegatedStakingActivitiesAvgOrderBy = {
  amount?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "delegated_staking_activities". All fields are combined with a logical 'AND'. */
export type DelegatedStakingActivitiesBoolExp = {
  _and?: InputMaybe<Array<DelegatedStakingActivitiesBoolExp>>;
  _not?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
  _or?: InputMaybe<Array<DelegatedStakingActivitiesBoolExp>>;
  amount?: InputMaybe<NumericComparisonExp>;
  delegator_address?: InputMaybe<StringComparisonExp>;
  event_index?: InputMaybe<BigintComparisonExp>;
  event_type?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  pool_address?: InputMaybe<StringComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "delegated_staking_activities" */
export enum DelegatedStakingActivitiesConstraint {
  /** unique or primary key constraint on columns "event_index", "transaction_version" */
  DelegatedStakingActivitiesPkey = "delegated_staking_activities_pkey",
}

/** input type for incrementing numeric columns in table "delegated_staking_activities" */
export type DelegatedStakingActivitiesIncInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "delegated_staking_activities" */
export type DelegatedStakingActivitiesInsertInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  delegator_address?: InputMaybe<Scalars["String"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  event_type?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  pool_address?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type DelegatedStakingActivitiesMaxFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  delegator_address?: Maybe<Scalars["String"]["output"]>;
  event_index?: Maybe<Scalars["bigint"]["output"]>;
  event_type?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  pool_address?: Maybe<Scalars["String"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** order by max() on columns of table "delegated_staking_activities" */
export type DelegatedStakingActivitiesMaxOrderBy = {
  amount?: InputMaybe<OrderBy>;
  delegator_address?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  event_type?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  pool_address?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type DelegatedStakingActivitiesMinFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  delegator_address?: Maybe<Scalars["String"]["output"]>;
  event_index?: Maybe<Scalars["bigint"]["output"]>;
  event_type?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  pool_address?: Maybe<Scalars["String"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** order by min() on columns of table "delegated_staking_activities" */
export type DelegatedStakingActivitiesMinOrderBy = {
  amount?: InputMaybe<OrderBy>;
  delegator_address?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  event_type?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  pool_address?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "delegated_staking_activities" */
export type DelegatedStakingActivitiesMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<DelegatedStakingActivities>;
};

/** on_conflict condition type for table "delegated_staking_activities" */
export type DelegatedStakingActivitiesOnConflict = {
  constraint: DelegatedStakingActivitiesConstraint;
  update_columns?: Array<DelegatedStakingActivitiesUpdateColumn>;
  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
};

/** Ordering options when selecting data from "delegated_staking_activities". */
export type DelegatedStakingActivitiesOrderBy = {
  amount?: InputMaybe<OrderBy>;
  delegator_address?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  event_type?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  pool_address?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: delegated_staking_activities */
export type DelegatedStakingActivitiesPkColumnsInput = {
  event_index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** select columns of table "delegated_staking_activities" */
export enum DelegatedStakingActivitiesSelectColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  DelegatorAddress = "delegator_address",
  /** column name */
  EventIndex = "event_index",
  /** column name */
  EventType = "event_type",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  PoolAddress = "pool_address",
  /** column name */
  TransactionVersion = "transaction_version",
}

/** input type for updating data in table "delegated_staking_activities" */
export type DelegatedStakingActivitiesSetInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  delegator_address?: InputMaybe<Scalars["String"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  event_type?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  pool_address?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type DelegatedStakingActivitiesStddevFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** order by stddev() on columns of table "delegated_staking_activities" */
export type DelegatedStakingActivitiesStddevOrderBy = {
  amount?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type DelegatedStakingActivitiesStddevPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** order by stddev_pop() on columns of table "delegated_staking_activities" */
export type DelegatedStakingActivitiesStddevPopOrderBy = {
  amount?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type DelegatedStakingActivitiesStddevSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** order by stddev_samp() on columns of table "delegated_staking_activities" */
export type DelegatedStakingActivitiesStddevSampOrderBy = {
  amount?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "delegated_staking_activities" */
export type DelegatedStakingActivitiesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: DelegatedStakingActivitiesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type DelegatedStakingActivitiesStreamCursorValueInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  delegator_address?: InputMaybe<Scalars["String"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  event_type?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  pool_address?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type DelegatedStakingActivitiesSumFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  event_index?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** order by sum() on columns of table "delegated_staking_activities" */
export type DelegatedStakingActivitiesSumOrderBy = {
  amount?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** update columns of table "delegated_staking_activities" */
export enum DelegatedStakingActivitiesUpdateColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  DelegatorAddress = "delegator_address",
  /** column name */
  EventIndex = "event_index",
  /** column name */
  EventType = "event_type",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  PoolAddress = "pool_address",
  /** column name */
  TransactionVersion = "transaction_version",
}

export type DelegatedStakingActivitiesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<DelegatedStakingActivitiesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<DelegatedStakingActivitiesSetInput>;
  /** filter the rows which have to be updated */
  where: DelegatedStakingActivitiesBoolExp;
};

/** aggregate var_pop on columns */
export type DelegatedStakingActivitiesVarPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** order by var_pop() on columns of table "delegated_staking_activities" */
export type DelegatedStakingActivitiesVarPopOrderBy = {
  amount?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type DelegatedStakingActivitiesVarSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** order by var_samp() on columns of table "delegated_staking_activities" */
export type DelegatedStakingActivitiesVarSampOrderBy = {
  amount?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type DelegatedStakingActivitiesVarianceFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** order by variance() on columns of table "delegated_staking_activities" */
export type DelegatedStakingActivitiesVarianceOrderBy = {
  amount?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** columns and relationships of "delegated_staking_pool_balances" */
export type DelegatedStakingPoolBalances = {
  active_table_handle: Scalars["String"]["output"];
  inactive_table_handle: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  operator_commission_percentage: Scalars["numeric"]["output"];
  staking_pool_address: Scalars["String"]["output"];
  total_coins: Scalars["numeric"]["output"];
  total_shares: Scalars["numeric"]["output"];
  transaction_version: Scalars["bigint"]["output"];
};

/** aggregated selection of "delegated_staking_pool_balances" */
export type DelegatedStakingPoolBalancesAggregate = {
  aggregate?: Maybe<DelegatedStakingPoolBalancesAggregateFields>;
  nodes: Array<DelegatedStakingPoolBalances>;
};

/** aggregate fields of "delegated_staking_pool_balances" */
export type DelegatedStakingPoolBalancesAggregateFields = {
  avg?: Maybe<DelegatedStakingPoolBalancesAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<DelegatedStakingPoolBalancesMaxFields>;
  min?: Maybe<DelegatedStakingPoolBalancesMinFields>;
  stddev?: Maybe<DelegatedStakingPoolBalancesStddevFields>;
  stddev_pop?: Maybe<DelegatedStakingPoolBalancesStddevPopFields>;
  stddev_samp?: Maybe<DelegatedStakingPoolBalancesStddevSampFields>;
  sum?: Maybe<DelegatedStakingPoolBalancesSumFields>;
  var_pop?: Maybe<DelegatedStakingPoolBalancesVarPopFields>;
  var_samp?: Maybe<DelegatedStakingPoolBalancesVarSampFields>;
  variance?: Maybe<DelegatedStakingPoolBalancesVarianceFields>;
};

/** aggregate fields of "delegated_staking_pool_balances" */
export type DelegatedStakingPoolBalancesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<DelegatedStakingPoolBalancesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type DelegatedStakingPoolBalancesAvgFields = {
  operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
  total_coins?: Maybe<Scalars["Float"]["output"]>;
  total_shares?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "delegated_staking_pool_balances". All fields are combined with a logical 'AND'. */
export type DelegatedStakingPoolBalancesBoolExp = {
  _and?: InputMaybe<Array<DelegatedStakingPoolBalancesBoolExp>>;
  _not?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;
  _or?: InputMaybe<Array<DelegatedStakingPoolBalancesBoolExp>>;
  active_table_handle?: InputMaybe<StringComparisonExp>;
  inactive_table_handle?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  operator_commission_percentage?: InputMaybe<NumericComparisonExp>;
  staking_pool_address?: InputMaybe<StringComparisonExp>;
  total_coins?: InputMaybe<NumericComparisonExp>;
  total_shares?: InputMaybe<NumericComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "delegated_staking_pool_balances" */
export enum DelegatedStakingPoolBalancesConstraint {
  /** unique or primary key constraint on columns "staking_pool_address", "transaction_version" */
  DelegatedStakingPoolBalancesPkey = "delegated_staking_pool_balances_pkey",
}

/** input type for incrementing numeric columns in table "delegated_staking_pool_balances" */
export type DelegatedStakingPoolBalancesIncInput = {
  operator_commission_percentage?: InputMaybe<Scalars["numeric"]["input"]>;
  total_coins?: InputMaybe<Scalars["numeric"]["input"]>;
  total_shares?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "delegated_staking_pool_balances" */
export type DelegatedStakingPoolBalancesInsertInput = {
  active_table_handle?: InputMaybe<Scalars["String"]["input"]>;
  inactive_table_handle?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  operator_commission_percentage?: InputMaybe<Scalars["numeric"]["input"]>;
  staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
  total_coins?: InputMaybe<Scalars["numeric"]["input"]>;
  total_shares?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type DelegatedStakingPoolBalancesMaxFields = {
  active_table_handle?: Maybe<Scalars["String"]["output"]>;
  inactive_table_handle?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  operator_commission_percentage?: Maybe<Scalars["numeric"]["output"]>;
  staking_pool_address?: Maybe<Scalars["String"]["output"]>;
  total_coins?: Maybe<Scalars["numeric"]["output"]>;
  total_shares?: Maybe<Scalars["numeric"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type DelegatedStakingPoolBalancesMinFields = {
  active_table_handle?: Maybe<Scalars["String"]["output"]>;
  inactive_table_handle?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  operator_commission_percentage?: Maybe<Scalars["numeric"]["output"]>;
  staking_pool_address?: Maybe<Scalars["String"]["output"]>;
  total_coins?: Maybe<Scalars["numeric"]["output"]>;
  total_shares?: Maybe<Scalars["numeric"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "delegated_staking_pool_balances" */
export type DelegatedStakingPoolBalancesMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<DelegatedStakingPoolBalances>;
};

/** on_conflict condition type for table "delegated_staking_pool_balances" */
export type DelegatedStakingPoolBalancesOnConflict = {
  constraint: DelegatedStakingPoolBalancesConstraint;
  update_columns?: Array<DelegatedStakingPoolBalancesUpdateColumn>;
  where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;
};

/** Ordering options when selecting data from "delegated_staking_pool_balances". */
export type DelegatedStakingPoolBalancesOrderBy = {
  active_table_handle?: InputMaybe<OrderBy>;
  inactive_table_handle?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  operator_commission_percentage?: InputMaybe<OrderBy>;
  staking_pool_address?: InputMaybe<OrderBy>;
  total_coins?: InputMaybe<OrderBy>;
  total_shares?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: delegated_staking_pool_balances */
export type DelegatedStakingPoolBalancesPkColumnsInput = {
  staking_pool_address: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** select columns of table "delegated_staking_pool_balances" */
export enum DelegatedStakingPoolBalancesSelectColumn {
  /** column name */
  ActiveTableHandle = "active_table_handle",
  /** column name */
  InactiveTableHandle = "inactive_table_handle",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  OperatorCommissionPercentage = "operator_commission_percentage",
  /** column name */
  StakingPoolAddress = "staking_pool_address",
  /** column name */
  TotalCoins = "total_coins",
  /** column name */
  TotalShares = "total_shares",
  /** column name */
  TransactionVersion = "transaction_version",
}

/** input type for updating data in table "delegated_staking_pool_balances" */
export type DelegatedStakingPoolBalancesSetInput = {
  active_table_handle?: InputMaybe<Scalars["String"]["input"]>;
  inactive_table_handle?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  operator_commission_percentage?: InputMaybe<Scalars["numeric"]["input"]>;
  staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
  total_coins?: InputMaybe<Scalars["numeric"]["input"]>;
  total_shares?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type DelegatedStakingPoolBalancesStddevFields = {
  operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
  total_coins?: Maybe<Scalars["Float"]["output"]>;
  total_shares?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type DelegatedStakingPoolBalancesStddevPopFields = {
  operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
  total_coins?: Maybe<Scalars["Float"]["output"]>;
  total_shares?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type DelegatedStakingPoolBalancesStddevSampFields = {
  operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
  total_coins?: Maybe<Scalars["Float"]["output"]>;
  total_shares?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "delegated_staking_pool_balances" */
export type DelegatedStakingPoolBalancesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: DelegatedStakingPoolBalancesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type DelegatedStakingPoolBalancesStreamCursorValueInput = {
  active_table_handle?: InputMaybe<Scalars["String"]["input"]>;
  inactive_table_handle?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  operator_commission_percentage?: InputMaybe<Scalars["numeric"]["input"]>;
  staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
  total_coins?: InputMaybe<Scalars["numeric"]["input"]>;
  total_shares?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type DelegatedStakingPoolBalancesSumFields = {
  operator_commission_percentage?: Maybe<Scalars["numeric"]["output"]>;
  total_coins?: Maybe<Scalars["numeric"]["output"]>;
  total_shares?: Maybe<Scalars["numeric"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "delegated_staking_pool_balances" */
export enum DelegatedStakingPoolBalancesUpdateColumn {
  /** column name */
  ActiveTableHandle = "active_table_handle",
  /** column name */
  InactiveTableHandle = "inactive_table_handle",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  OperatorCommissionPercentage = "operator_commission_percentage",
  /** column name */
  StakingPoolAddress = "staking_pool_address",
  /** column name */
  TotalCoins = "total_coins",
  /** column name */
  TotalShares = "total_shares",
  /** column name */
  TransactionVersion = "transaction_version",
}

export type DelegatedStakingPoolBalancesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<DelegatedStakingPoolBalancesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<DelegatedStakingPoolBalancesSetInput>;
  /** filter the rows which have to be updated */
  where: DelegatedStakingPoolBalancesBoolExp;
};

/** aggregate var_pop on columns */
export type DelegatedStakingPoolBalancesVarPopFields = {
  operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
  total_coins?: Maybe<Scalars["Float"]["output"]>;
  total_shares?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type DelegatedStakingPoolBalancesVarSampFields = {
  operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
  total_coins?: Maybe<Scalars["Float"]["output"]>;
  total_shares?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type DelegatedStakingPoolBalancesVarianceFields = {
  operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
  total_coins?: Maybe<Scalars["Float"]["output"]>;
  total_shares?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "delegated_staking_pools" */
export type DelegatedStakingPools = {
  /** An object relationship */
  current_staking_pool?: Maybe<CurrentStakingPoolVoter>;
  first_transaction_version: Scalars["bigint"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  staking_pool_address: Scalars["String"]["output"];
};

/** aggregated selection of "delegated_staking_pools" */
export type DelegatedStakingPoolsAggregate = {
  aggregate?: Maybe<DelegatedStakingPoolsAggregateFields>;
  nodes: Array<DelegatedStakingPools>;
};

/** aggregate fields of "delegated_staking_pools" */
export type DelegatedStakingPoolsAggregateFields = {
  avg?: Maybe<DelegatedStakingPoolsAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<DelegatedStakingPoolsMaxFields>;
  min?: Maybe<DelegatedStakingPoolsMinFields>;
  stddev?: Maybe<DelegatedStakingPoolsStddevFields>;
  stddev_pop?: Maybe<DelegatedStakingPoolsStddevPopFields>;
  stddev_samp?: Maybe<DelegatedStakingPoolsStddevSampFields>;
  sum?: Maybe<DelegatedStakingPoolsSumFields>;
  var_pop?: Maybe<DelegatedStakingPoolsVarPopFields>;
  var_samp?: Maybe<DelegatedStakingPoolsVarSampFields>;
  variance?: Maybe<DelegatedStakingPoolsVarianceFields>;
};

/** aggregate fields of "delegated_staking_pools" */
export type DelegatedStakingPoolsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<DelegatedStakingPoolsSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type DelegatedStakingPoolsAvgFields = {
  first_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "delegated_staking_pools". All fields are combined with a logical 'AND'. */
export type DelegatedStakingPoolsBoolExp = {
  _and?: InputMaybe<Array<DelegatedStakingPoolsBoolExp>>;
  _not?: InputMaybe<DelegatedStakingPoolsBoolExp>;
  _or?: InputMaybe<Array<DelegatedStakingPoolsBoolExp>>;
  current_staking_pool?: InputMaybe<CurrentStakingPoolVoterBoolExp>;
  first_transaction_version?: InputMaybe<BigintComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  staking_pool_address?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "delegated_staking_pools" */
export enum DelegatedStakingPoolsConstraint {
  /** unique or primary key constraint on columns "staking_pool_address" */
  DelegatedStakingPoolsPkey = "delegated_staking_pools_pkey",
}

/** input type for incrementing numeric columns in table "delegated_staking_pools" */
export type DelegatedStakingPoolsIncInput = {
  first_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "delegated_staking_pools" */
export type DelegatedStakingPoolsInsertInput = {
  current_staking_pool?: InputMaybe<CurrentStakingPoolVoterObjRelInsertInput>;
  first_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type DelegatedStakingPoolsMaxFields = {
  first_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  staking_pool_address?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type DelegatedStakingPoolsMinFields = {
  first_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  staking_pool_address?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "delegated_staking_pools" */
export type DelegatedStakingPoolsMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<DelegatedStakingPools>;
};

/** on_conflict condition type for table "delegated_staking_pools" */
export type DelegatedStakingPoolsOnConflict = {
  constraint: DelegatedStakingPoolsConstraint;
  update_columns?: Array<DelegatedStakingPoolsUpdateColumn>;
  where?: InputMaybe<DelegatedStakingPoolsBoolExp>;
};

/** Ordering options when selecting data from "delegated_staking_pools". */
export type DelegatedStakingPoolsOrderBy = {
  current_staking_pool?: InputMaybe<CurrentStakingPoolVoterOrderBy>;
  first_transaction_version?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  staking_pool_address?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: delegated_staking_pools */
export type DelegatedStakingPoolsPkColumnsInput = {
  staking_pool_address: Scalars["String"]["input"];
};

/** select columns of table "delegated_staking_pools" */
export enum DelegatedStakingPoolsSelectColumn {
  /** column name */
  FirstTransactionVersion = "first_transaction_version",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  StakingPoolAddress = "staking_pool_address",
}

/** input type for updating data in table "delegated_staking_pools" */
export type DelegatedStakingPoolsSetInput = {
  first_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type DelegatedStakingPoolsStddevFields = {
  first_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type DelegatedStakingPoolsStddevPopFields = {
  first_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type DelegatedStakingPoolsStddevSampFields = {
  first_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "delegated_staking_pools" */
export type DelegatedStakingPoolsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: DelegatedStakingPoolsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type DelegatedStakingPoolsStreamCursorValueInput = {
  first_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type DelegatedStakingPoolsSumFields = {
  first_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "delegated_staking_pools" */
export enum DelegatedStakingPoolsUpdateColumn {
  /** column name */
  FirstTransactionVersion = "first_transaction_version",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  StakingPoolAddress = "staking_pool_address",
}

export type DelegatedStakingPoolsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<DelegatedStakingPoolsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<DelegatedStakingPoolsSetInput>;
  /** filter the rows which have to be updated */
  where: DelegatedStakingPoolsBoolExp;
};

/** aggregate var_pop on columns */
export type DelegatedStakingPoolsVarPopFields = {
  first_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type DelegatedStakingPoolsVarSampFields = {
  first_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type DelegatedStakingPoolsVarianceFields = {
  first_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "delegator_balances" */
export type DelegatorBalances = {
  delegator_address: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  parent_table_handle: Scalars["String"]["output"];
  pool_address: Scalars["String"]["output"];
  pool_type: Scalars["String"]["output"];
  shares: Scalars["numeric"]["output"];
  table_handle: Scalars["String"]["output"];
  transaction_version: Scalars["bigint"]["output"];
  write_set_change_index: Scalars["bigint"]["output"];
};

/** aggregated selection of "delegator_balances" */
export type DelegatorBalancesAggregate = {
  aggregate?: Maybe<DelegatorBalancesAggregateFields>;
  nodes: Array<DelegatorBalances>;
};

/** aggregate fields of "delegator_balances" */
export type DelegatorBalancesAggregateFields = {
  avg?: Maybe<DelegatorBalancesAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<DelegatorBalancesMaxFields>;
  min?: Maybe<DelegatorBalancesMinFields>;
  stddev?: Maybe<DelegatorBalancesStddevFields>;
  stddev_pop?: Maybe<DelegatorBalancesStddevPopFields>;
  stddev_samp?: Maybe<DelegatorBalancesStddevSampFields>;
  sum?: Maybe<DelegatorBalancesSumFields>;
  var_pop?: Maybe<DelegatorBalancesVarPopFields>;
  var_samp?: Maybe<DelegatorBalancesVarSampFields>;
  variance?: Maybe<DelegatorBalancesVarianceFields>;
};

/** aggregate fields of "delegator_balances" */
export type DelegatorBalancesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<DelegatorBalancesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type DelegatorBalancesAvgFields = {
  shares?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "delegator_balances". All fields are combined with a logical 'AND'. */
export type DelegatorBalancesBoolExp = {
  _and?: InputMaybe<Array<DelegatorBalancesBoolExp>>;
  _not?: InputMaybe<DelegatorBalancesBoolExp>;
  _or?: InputMaybe<Array<DelegatorBalancesBoolExp>>;
  delegator_address?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  parent_table_handle?: InputMaybe<StringComparisonExp>;
  pool_address?: InputMaybe<StringComparisonExp>;
  pool_type?: InputMaybe<StringComparisonExp>;
  shares?: InputMaybe<NumericComparisonExp>;
  table_handle?: InputMaybe<StringComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  write_set_change_index?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "delegator_balances" */
export enum DelegatorBalancesConstraint {
  /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
  DelegatorBalancesPkey = "delegator_balances_pkey",
}

/** input type for incrementing numeric columns in table "delegator_balances" */
export type DelegatorBalancesIncInput = {
  shares?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "delegator_balances" */
export type DelegatorBalancesInsertInput = {
  delegator_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  parent_table_handle?: InputMaybe<Scalars["String"]["input"]>;
  pool_address?: InputMaybe<Scalars["String"]["input"]>;
  pool_type?: InputMaybe<Scalars["String"]["input"]>;
  shares?: InputMaybe<Scalars["numeric"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type DelegatorBalancesMaxFields = {
  delegator_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  parent_table_handle?: Maybe<Scalars["String"]["output"]>;
  pool_address?: Maybe<Scalars["String"]["output"]>;
  pool_type?: Maybe<Scalars["String"]["output"]>;
  shares?: Maybe<Scalars["numeric"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type DelegatorBalancesMinFields = {
  delegator_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  parent_table_handle?: Maybe<Scalars["String"]["output"]>;
  pool_address?: Maybe<Scalars["String"]["output"]>;
  pool_type?: Maybe<Scalars["String"]["output"]>;
  shares?: Maybe<Scalars["numeric"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "delegator_balances" */
export type DelegatorBalancesMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<DelegatorBalances>;
};

/** on_conflict condition type for table "delegator_balances" */
export type DelegatorBalancesOnConflict = {
  constraint: DelegatorBalancesConstraint;
  update_columns?: Array<DelegatorBalancesUpdateColumn>;
  where?: InputMaybe<DelegatorBalancesBoolExp>;
};

/** Ordering options when selecting data from "delegator_balances". */
export type DelegatorBalancesOrderBy = {
  delegator_address?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  parent_table_handle?: InputMaybe<OrderBy>;
  pool_address?: InputMaybe<OrderBy>;
  pool_type?: InputMaybe<OrderBy>;
  shares?: InputMaybe<OrderBy>;
  table_handle?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  write_set_change_index?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: delegator_balances */
export type DelegatorBalancesPkColumnsInput = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** select columns of table "delegator_balances" */
export enum DelegatorBalancesSelectColumn {
  /** column name */
  DelegatorAddress = "delegator_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  ParentTableHandle = "parent_table_handle",
  /** column name */
  PoolAddress = "pool_address",
  /** column name */
  PoolType = "pool_type",
  /** column name */
  Shares = "shares",
  /** column name */
  TableHandle = "table_handle",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

/** input type for updating data in table "delegator_balances" */
export type DelegatorBalancesSetInput = {
  delegator_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  parent_table_handle?: InputMaybe<Scalars["String"]["input"]>;
  pool_address?: InputMaybe<Scalars["String"]["input"]>;
  pool_type?: InputMaybe<Scalars["String"]["input"]>;
  shares?: InputMaybe<Scalars["numeric"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type DelegatorBalancesStddevFields = {
  shares?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type DelegatorBalancesStddevPopFields = {
  shares?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type DelegatorBalancesStddevSampFields = {
  shares?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "delegator_balances" */
export type DelegatorBalancesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: DelegatorBalancesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type DelegatorBalancesStreamCursorValueInput = {
  delegator_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  parent_table_handle?: InputMaybe<Scalars["String"]["input"]>;
  pool_address?: InputMaybe<Scalars["String"]["input"]>;
  pool_type?: InputMaybe<Scalars["String"]["input"]>;
  shares?: InputMaybe<Scalars["numeric"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type DelegatorBalancesSumFields = {
  shares?: Maybe<Scalars["numeric"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "delegator_balances" */
export enum DelegatorBalancesUpdateColumn {
  /** column name */
  DelegatorAddress = "delegator_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  ParentTableHandle = "parent_table_handle",
  /** column name */
  PoolAddress = "pool_address",
  /** column name */
  PoolType = "pool_type",
  /** column name */
  Shares = "shares",
  /** column name */
  TableHandle = "table_handle",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

export type DelegatorBalancesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<DelegatorBalancesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<DelegatorBalancesSetInput>;
  /** filter the rows which have to be updated */
  where: DelegatorBalancesBoolExp;
};

/** aggregate var_pop on columns */
export type DelegatorBalancesVarPopFields = {
  shares?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type DelegatorBalancesVarSampFields = {
  shares?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type DelegatorBalancesVarianceFields = {
  shares?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "delegator_distinct_pool" */
export type DelegatorDistinctPool = {
  /** An object relationship */
  current_pool_balance?: Maybe<CurrentDelegatedStakingPoolBalances>;
  delegator_address?: Maybe<Scalars["String"]["output"]>;
  pool_address?: Maybe<Scalars["String"]["output"]>;
  /** An object relationship */
  staking_pool_metadata?: Maybe<CurrentStakingPoolVoter>;
};

/** aggregated selection of "delegator_distinct_pool" */
export type DelegatorDistinctPoolAggregate = {
  aggregate?: Maybe<DelegatorDistinctPoolAggregateFields>;
  nodes: Array<DelegatorDistinctPool>;
};

/** aggregate fields of "delegator_distinct_pool" */
export type DelegatorDistinctPoolAggregateFields = {
  count: Scalars["Int"]["output"];
  max?: Maybe<DelegatorDistinctPoolMaxFields>;
  min?: Maybe<DelegatorDistinctPoolMinFields>;
};

/** aggregate fields of "delegator_distinct_pool" */
export type DelegatorDistinctPoolAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<DelegatorDistinctPoolSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** Boolean expression to filter rows from the table "delegator_distinct_pool". All fields are combined with a logical 'AND'. */
export type DelegatorDistinctPoolBoolExp = {
  _and?: InputMaybe<Array<DelegatorDistinctPoolBoolExp>>;
  _not?: InputMaybe<DelegatorDistinctPoolBoolExp>;
  _or?: InputMaybe<Array<DelegatorDistinctPoolBoolExp>>;
  current_pool_balance?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;
  delegator_address?: InputMaybe<StringComparisonExp>;
  pool_address?: InputMaybe<StringComparisonExp>;
  staking_pool_metadata?: InputMaybe<CurrentStakingPoolVoterBoolExp>;
};

/** aggregate max on columns */
export type DelegatorDistinctPoolMaxFields = {
  delegator_address?: Maybe<Scalars["String"]["output"]>;
  pool_address?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type DelegatorDistinctPoolMinFields = {
  delegator_address?: Maybe<Scalars["String"]["output"]>;
  pool_address?: Maybe<Scalars["String"]["output"]>;
};

/** Ordering options when selecting data from "delegator_distinct_pool". */
export type DelegatorDistinctPoolOrderBy = {
  current_pool_balance?: InputMaybe<CurrentDelegatedStakingPoolBalancesOrderBy>;
  delegator_address?: InputMaybe<OrderBy>;
  pool_address?: InputMaybe<OrderBy>;
  staking_pool_metadata?: InputMaybe<CurrentStakingPoolVoterOrderBy>;
};

/** select columns of table "delegator_distinct_pool" */
export enum DelegatorDistinctPoolSelectColumn {
  /** column name */
  DelegatorAddress = "delegator_address",
  /** column name */
  PoolAddress = "pool_address",
}

/** Streaming cursor of the table "delegator_distinct_pool" */
export type DelegatorDistinctPoolStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: DelegatorDistinctPoolStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type DelegatorDistinctPoolStreamCursorValueInput = {
  delegator_address?: InputMaybe<Scalars["String"]["input"]>;
  pool_address?: InputMaybe<Scalars["String"]["input"]>;
};

/** columns and relationships of "event_size_info" */
export type EventSizeInfo = {
  index: Scalars["bigint"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  total_bytes: Scalars["bigint"]["output"];
  transaction_version: Scalars["bigint"]["output"];
  type_tag_bytes: Scalars["bigint"]["output"];
};

/** aggregated selection of "event_size_info" */
export type EventSizeInfoAggregate = {
  aggregate?: Maybe<EventSizeInfoAggregateFields>;
  nodes: Array<EventSizeInfo>;
};

/** aggregate fields of "event_size_info" */
export type EventSizeInfoAggregateFields = {
  avg?: Maybe<EventSizeInfoAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<EventSizeInfoMaxFields>;
  min?: Maybe<EventSizeInfoMinFields>;
  stddev?: Maybe<EventSizeInfoStddevFields>;
  stddev_pop?: Maybe<EventSizeInfoStddevPopFields>;
  stddev_samp?: Maybe<EventSizeInfoStddevSampFields>;
  sum?: Maybe<EventSizeInfoSumFields>;
  var_pop?: Maybe<EventSizeInfoVarPopFields>;
  var_samp?: Maybe<EventSizeInfoVarSampFields>;
  variance?: Maybe<EventSizeInfoVarianceFields>;
};

/** aggregate fields of "event_size_info" */
export type EventSizeInfoAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventSizeInfoSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type EventSizeInfoAvgFields = {
  index?: Maybe<Scalars["Float"]["output"]>;
  total_bytes?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  type_tag_bytes?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "event_size_info". All fields are combined with a logical 'AND'. */
export type EventSizeInfoBoolExp = {
  _and?: InputMaybe<Array<EventSizeInfoBoolExp>>;
  _not?: InputMaybe<EventSizeInfoBoolExp>;
  _or?: InputMaybe<Array<EventSizeInfoBoolExp>>;
  index?: InputMaybe<BigintComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  total_bytes?: InputMaybe<BigintComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  type_tag_bytes?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "event_size_info" */
export enum EventSizeInfoConstraint {
  /** unique or primary key constraint on columns "index", "transaction_version" */
  EventSizeInfoPkey = "event_size_info_pkey",
}

/** input type for incrementing numeric columns in table "event_size_info" */
export type EventSizeInfoIncInput = {
  index?: InputMaybe<Scalars["bigint"]["input"]>;
  total_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type_tag_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "event_size_info" */
export type EventSizeInfoInsertInput = {
  index?: InputMaybe<Scalars["bigint"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  total_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type_tag_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type EventSizeInfoMaxFields = {
  index?: Maybe<Scalars["bigint"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  total_bytes?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  type_tag_bytes?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type EventSizeInfoMinFields = {
  index?: Maybe<Scalars["bigint"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  total_bytes?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  type_tag_bytes?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "event_size_info" */
export type EventSizeInfoMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<EventSizeInfo>;
};

/** on_conflict condition type for table "event_size_info" */
export type EventSizeInfoOnConflict = {
  constraint: EventSizeInfoConstraint;
  update_columns?: Array<EventSizeInfoUpdateColumn>;
  where?: InputMaybe<EventSizeInfoBoolExp>;
};

/** Ordering options when selecting data from "event_size_info". */
export type EventSizeInfoOrderBy = {
  index?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  total_bytes?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  type_tag_bytes?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: event_size_info */
export type EventSizeInfoPkColumnsInput = {
  index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** select columns of table "event_size_info" */
export enum EventSizeInfoSelectColumn {
  /** column name */
  Index = "index",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  TotalBytes = "total_bytes",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  TypeTagBytes = "type_tag_bytes",
}

/** input type for updating data in table "event_size_info" */
export type EventSizeInfoSetInput = {
  index?: InputMaybe<Scalars["bigint"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  total_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type_tag_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type EventSizeInfoStddevFields = {
  index?: Maybe<Scalars["Float"]["output"]>;
  total_bytes?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  type_tag_bytes?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type EventSizeInfoStddevPopFields = {
  index?: Maybe<Scalars["Float"]["output"]>;
  total_bytes?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  type_tag_bytes?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type EventSizeInfoStddevSampFields = {
  index?: Maybe<Scalars["Float"]["output"]>;
  total_bytes?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  type_tag_bytes?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "event_size_info" */
export type EventSizeInfoStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: EventSizeInfoStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventSizeInfoStreamCursorValueInput = {
  index?: InputMaybe<Scalars["bigint"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  total_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type_tag_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type EventSizeInfoSumFields = {
  index?: Maybe<Scalars["bigint"]["output"]>;
  total_bytes?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  type_tag_bytes?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "event_size_info" */
export enum EventSizeInfoUpdateColumn {
  /** column name */
  Index = "index",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  TotalBytes = "total_bytes",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  TypeTagBytes = "type_tag_bytes",
}

export type EventSizeInfoUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EventSizeInfoIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventSizeInfoSetInput>;
  /** filter the rows which have to be updated */
  where: EventSizeInfoBoolExp;
};

/** aggregate var_pop on columns */
export type EventSizeInfoVarPopFields = {
  index?: Maybe<Scalars["Float"]["output"]>;
  total_bytes?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  type_tag_bytes?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type EventSizeInfoVarSampFields = {
  index?: Maybe<Scalars["Float"]["output"]>;
  total_bytes?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  type_tag_bytes?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type EventSizeInfoVarianceFields = {
  index?: Maybe<Scalars["Float"]["output"]>;
  total_bytes?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  type_tag_bytes?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "events" */
export type Events = {
  account_address: Scalars["String"]["output"];
  creation_number: Scalars["bigint"]["output"];
  data: Scalars["jsonb"]["output"];
  event_index: Scalars["bigint"]["output"];
  indexed_type: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  sequence_number: Scalars["bigint"]["output"];
  transaction_block_height: Scalars["bigint"]["output"];
  transaction_version: Scalars["bigint"]["output"];
  type: Scalars["String"]["output"];
};

/** columns and relationships of "events" */
export type EventsDataArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregated selection of "events" */
export type EventsAggregate = {
  aggregate?: Maybe<EventsAggregateFields>;
  nodes: Array<Events>;
};

/** aggregate fields of "events" */
export type EventsAggregateFields = {
  avg?: Maybe<EventsAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<EventsMaxFields>;
  min?: Maybe<EventsMinFields>;
  stddev?: Maybe<EventsStddevFields>;
  stddev_pop?: Maybe<EventsStddevPopFields>;
  stddev_samp?: Maybe<EventsStddevSampFields>;
  sum?: Maybe<EventsSumFields>;
  var_pop?: Maybe<EventsVarPopFields>;
  var_samp?: Maybe<EventsVarSampFields>;
  variance?: Maybe<EventsVarianceFields>;
};

/** aggregate fields of "events" */
export type EventsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventsSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type EventsAppendInput = {
  data?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** aggregate avg on columns */
export type EventsAvgFields = {
  creation_number?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  sequence_number?: Maybe<Scalars["Float"]["output"]>;
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "events". All fields are combined with a logical 'AND'. */
export type EventsBoolExp = {
  _and?: InputMaybe<Array<EventsBoolExp>>;
  _not?: InputMaybe<EventsBoolExp>;
  _or?: InputMaybe<Array<EventsBoolExp>>;
  account_address?: InputMaybe<StringComparisonExp>;
  creation_number?: InputMaybe<BigintComparisonExp>;
  data?: InputMaybe<JsonbComparisonExp>;
  event_index?: InputMaybe<BigintComparisonExp>;
  indexed_type?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  sequence_number?: InputMaybe<BigintComparisonExp>;
  transaction_block_height?: InputMaybe<BigintComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  type?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "events" */
export enum EventsConstraint {
  /** unique or primary key constraint on columns "event_index", "transaction_version" */
  EventsPkey = "events_pkey",
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type EventsDeleteAtPathInput = {
  data?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type EventsDeleteElemInput = {
  data?: InputMaybe<Scalars["Int"]["input"]>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type EventsDeleteKeyInput = {
  data?: InputMaybe<Scalars["String"]["input"]>;
};

/** input type for incrementing numeric columns in table "events" */
export type EventsIncInput = {
  creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "events" */
export type EventsInsertInput = {
  account_address?: InputMaybe<Scalars["String"]["input"]>;
  creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
  data?: InputMaybe<Scalars["jsonb"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  indexed_type?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type EventsMaxFields = {
  account_address?: Maybe<Scalars["String"]["output"]>;
  creation_number?: Maybe<Scalars["bigint"]["output"]>;
  event_index?: Maybe<Scalars["bigint"]["output"]>;
  indexed_type?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  sequence_number?: Maybe<Scalars["bigint"]["output"]>;
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  type?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type EventsMinFields = {
  account_address?: Maybe<Scalars["String"]["output"]>;
  creation_number?: Maybe<Scalars["bigint"]["output"]>;
  event_index?: Maybe<Scalars["bigint"]["output"]>;
  indexed_type?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  sequence_number?: Maybe<Scalars["bigint"]["output"]>;
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  type?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "events" */
export type EventsMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<Events>;
};

/** on_conflict condition type for table "events" */
export type EventsOnConflict = {
  constraint: EventsConstraint;
  update_columns?: Array<EventsUpdateColumn>;
  where?: InputMaybe<EventsBoolExp>;
};

/** Ordering options when selecting data from "events". */
export type EventsOrderBy = {
  account_address?: InputMaybe<OrderBy>;
  creation_number?: InputMaybe<OrderBy>;
  data?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  indexed_type?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  sequence_number?: InputMaybe<OrderBy>;
  transaction_block_height?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: events */
export type EventsPkColumnsInput = {
  event_index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type EventsPrependInput = {
  data?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** select columns of table "events" */
export enum EventsSelectColumn {
  /** column name */
  AccountAddress = "account_address",
  /** column name */
  CreationNumber = "creation_number",
  /** column name */
  Data = "data",
  /** column name */
  EventIndex = "event_index",
  /** column name */
  IndexedType = "indexed_type",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  SequenceNumber = "sequence_number",
  /** column name */
  TransactionBlockHeight = "transaction_block_height",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  Type = "type",
}

/** input type for updating data in table "events" */
export type EventsSetInput = {
  account_address?: InputMaybe<Scalars["String"]["input"]>;
  creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
  data?: InputMaybe<Scalars["jsonb"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  indexed_type?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type EventsStddevFields = {
  creation_number?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  sequence_number?: Maybe<Scalars["Float"]["output"]>;
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type EventsStddevPopFields = {
  creation_number?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  sequence_number?: Maybe<Scalars["Float"]["output"]>;
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type EventsStddevSampFields = {
  creation_number?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  sequence_number?: Maybe<Scalars["Float"]["output"]>;
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "events" */
export type EventsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: EventsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventsStreamCursorValueInput = {
  account_address?: InputMaybe<Scalars["String"]["input"]>;
  creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
  data?: InputMaybe<Scalars["jsonb"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  indexed_type?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type EventsSumFields = {
  creation_number?: Maybe<Scalars["bigint"]["output"]>;
  event_index?: Maybe<Scalars["bigint"]["output"]>;
  sequence_number?: Maybe<Scalars["bigint"]["output"]>;
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "events" */
export enum EventsUpdateColumn {
  /** column name */
  AccountAddress = "account_address",
  /** column name */
  CreationNumber = "creation_number",
  /** column name */
  Data = "data",
  /** column name */
  EventIndex = "event_index",
  /** column name */
  IndexedType = "indexed_type",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  SequenceNumber = "sequence_number",
  /** column name */
  TransactionBlockHeight = "transaction_block_height",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  Type = "type",
}

export type EventsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<EventsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<EventsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<EventsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<EventsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EventsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<EventsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventsSetInput>;
  /** filter the rows which have to be updated */
  where: EventsBoolExp;
};

/** aggregate var_pop on columns */
export type EventsVarPopFields = {
  creation_number?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  sequence_number?: Maybe<Scalars["Float"]["output"]>;
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type EventsVarSampFields = {
  creation_number?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  sequence_number?: Maybe<Scalars["Float"]["output"]>;
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type EventsVarianceFields = {
  creation_number?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  sequence_number?: Maybe<Scalars["Float"]["output"]>;
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "events_view" */
export type EventsView = {
  account_address?: Maybe<Scalars["String"]["output"]>;
  creation_number?: Maybe<Scalars["bigint"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  json_data?: Maybe<Scalars["String"]["output"]>;
  sequence_number?: Maybe<Scalars["bigint"]["output"]>;
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  type?: Maybe<Scalars["String"]["output"]>;
};

/** aggregated selection of "events_view" */
export type EventsViewAggregate = {
  aggregate?: Maybe<EventsViewAggregateFields>;
  nodes: Array<EventsView>;
};

/** aggregate fields of "events_view" */
export type EventsViewAggregateFields = {
  avg?: Maybe<EventsViewAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<EventsViewMaxFields>;
  min?: Maybe<EventsViewMinFields>;
  stddev?: Maybe<EventsViewStddevFields>;
  stddev_pop?: Maybe<EventsViewStddevPopFields>;
  stddev_samp?: Maybe<EventsViewStddevSampFields>;
  sum?: Maybe<EventsViewSumFields>;
  var_pop?: Maybe<EventsViewVarPopFields>;
  var_samp?: Maybe<EventsViewVarSampFields>;
  variance?: Maybe<EventsViewVarianceFields>;
};

/** aggregate fields of "events_view" */
export type EventsViewAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EventsViewSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type EventsViewAvgFields = {
  creation_number?: Maybe<Scalars["Float"]["output"]>;
  sequence_number?: Maybe<Scalars["Float"]["output"]>;
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "events_view". All fields are combined with a logical 'AND'. */
export type EventsViewBoolExp = {
  _and?: InputMaybe<Array<EventsViewBoolExp>>;
  _not?: InputMaybe<EventsViewBoolExp>;
  _or?: InputMaybe<Array<EventsViewBoolExp>>;
  account_address?: InputMaybe<StringComparisonExp>;
  creation_number?: InputMaybe<BigintComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  json_data?: InputMaybe<StringComparisonExp>;
  sequence_number?: InputMaybe<BigintComparisonExp>;
  transaction_block_height?: InputMaybe<BigintComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  type?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "events_view" */
export type EventsViewIncInput = {
  creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
  sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "events_view" */
export type EventsViewInsertInput = {
  account_address?: InputMaybe<Scalars["String"]["input"]>;
  creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  json_data?: InputMaybe<Scalars["String"]["input"]>;
  sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type EventsViewMaxFields = {
  account_address?: Maybe<Scalars["String"]["output"]>;
  creation_number?: Maybe<Scalars["bigint"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  json_data?: Maybe<Scalars["String"]["output"]>;
  sequence_number?: Maybe<Scalars["bigint"]["output"]>;
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  type?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type EventsViewMinFields = {
  account_address?: Maybe<Scalars["String"]["output"]>;
  creation_number?: Maybe<Scalars["bigint"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  json_data?: Maybe<Scalars["String"]["output"]>;
  sequence_number?: Maybe<Scalars["bigint"]["output"]>;
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  type?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "events_view" */
export type EventsViewMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<EventsView>;
};

/** Ordering options when selecting data from "events_view". */
export type EventsViewOrderBy = {
  account_address?: InputMaybe<OrderBy>;
  creation_number?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  json_data?: InputMaybe<OrderBy>;
  sequence_number?: InputMaybe<OrderBy>;
  transaction_block_height?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
};

/** select columns of table "events_view" */
export enum EventsViewSelectColumn {
  /** column name */
  AccountAddress = "account_address",
  /** column name */
  CreationNumber = "creation_number",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  JsonData = "json_data",
  /** column name */
  SequenceNumber = "sequence_number",
  /** column name */
  TransactionBlockHeight = "transaction_block_height",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  Type = "type",
}

/** input type for updating data in table "events_view" */
export type EventsViewSetInput = {
  account_address?: InputMaybe<Scalars["String"]["input"]>;
  creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  json_data?: InputMaybe<Scalars["String"]["input"]>;
  sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type EventsViewStddevFields = {
  creation_number?: Maybe<Scalars["Float"]["output"]>;
  sequence_number?: Maybe<Scalars["Float"]["output"]>;
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type EventsViewStddevPopFields = {
  creation_number?: Maybe<Scalars["Float"]["output"]>;
  sequence_number?: Maybe<Scalars["Float"]["output"]>;
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type EventsViewStddevSampFields = {
  creation_number?: Maybe<Scalars["Float"]["output"]>;
  sequence_number?: Maybe<Scalars["Float"]["output"]>;
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "events_view" */
export type EventsViewStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: EventsViewStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EventsViewStreamCursorValueInput = {
  account_address?: InputMaybe<Scalars["String"]["input"]>;
  creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  json_data?: InputMaybe<Scalars["String"]["input"]>;
  sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type EventsViewSumFields = {
  creation_number?: Maybe<Scalars["bigint"]["output"]>;
  sequence_number?: Maybe<Scalars["bigint"]["output"]>;
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

export type EventsViewUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<EventsViewIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventsViewSetInput>;
  /** filter the rows which have to be updated */
  where: EventsViewBoolExp;
};

/** aggregate var_pop on columns */
export type EventsViewVarPopFields = {
  creation_number?: Maybe<Scalars["Float"]["output"]>;
  sequence_number?: Maybe<Scalars["Float"]["output"]>;
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type EventsViewVarSampFields = {
  creation_number?: Maybe<Scalars["Float"]["output"]>;
  sequence_number?: Maybe<Scalars["Float"]["output"]>;
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type EventsViewVarianceFields = {
  creation_number?: Maybe<Scalars["Float"]["output"]>;
  sequence_number?: Maybe<Scalars["Float"]["output"]>;
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "fungible_asset_activities" */
export type FungibleAssetActivities = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  asset_type?: Maybe<Scalars["String"]["output"]>;
  block_height: Scalars["bigint"]["output"];
  entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
  event_index: Scalars["bigint"]["output"];
  gas_fee_payer_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at: Scalars["timestamp"]["output"];
  is_frozen?: Maybe<Scalars["Boolean"]["output"]>;
  is_gas_fee: Scalars["Boolean"]["output"];
  is_transaction_success: Scalars["Boolean"]["output"];
  /** An object relationship */
  metadata?: Maybe<FungibleAssetMetadata>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  /** An array relationship */
  owner_cedra_names: Array<CurrentCedraNames>;
  /** An aggregate relationship */
  owner_cedra_names_aggregate: CurrentCedraNamesAggregate;
  storage_id: Scalars["String"]["output"];
  storage_refund_amount: Scalars["numeric"]["output"];
  token_standard: Scalars["String"]["output"];
  transaction_timestamp: Scalars["timestamp"]["output"];
  transaction_version: Scalars["bigint"]["output"];
  type: Scalars["String"]["output"];
};

/** columns and relationships of "fungible_asset_activities" */
export type FungibleAssetActivitiesOwnerCedraNamesArgs = {
  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
  where?: InputMaybe<CurrentCedraNamesBoolExp>;
};

/** columns and relationships of "fungible_asset_activities" */
export type FungibleAssetActivitiesOwnerCedraNamesAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
  where?: InputMaybe<CurrentCedraNamesBoolExp>;
};

/** aggregated selection of "fungible_asset_activities" */
export type FungibleAssetActivitiesAggregate = {
  aggregate?: Maybe<FungibleAssetActivitiesAggregateFields>;
  nodes: Array<FungibleAssetActivities>;
};

export type FungibleAssetActivitiesAggregateBoolExp = {
  bool_and?: InputMaybe<FungibleAssetActivitiesAggregateBoolExpBoolAnd>;
  bool_or?: InputMaybe<FungibleAssetActivitiesAggregateBoolExpBoolOr>;
  count?: InputMaybe<FungibleAssetActivitiesAggregateBoolExpCount>;
};

export type FungibleAssetActivitiesAggregateBoolExpBoolAnd = {
  arguments: FungibleAssetActivitiesSelectColumnFungibleAssetActivitiesAggregateBoolExpBoolAndArgumentsColumns;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
  filter?: InputMaybe<FungibleAssetActivitiesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type FungibleAssetActivitiesAggregateBoolExpBoolOr = {
  arguments: FungibleAssetActivitiesSelectColumnFungibleAssetActivitiesAggregateBoolExpBoolOrArgumentsColumns;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
  filter?: InputMaybe<FungibleAssetActivitiesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type FungibleAssetActivitiesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
  filter?: InputMaybe<FungibleAssetActivitiesBoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "fungible_asset_activities" */
export type FungibleAssetActivitiesAggregateFields = {
  avg?: Maybe<FungibleAssetActivitiesAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<FungibleAssetActivitiesMaxFields>;
  min?: Maybe<FungibleAssetActivitiesMinFields>;
  stddev?: Maybe<FungibleAssetActivitiesStddevFields>;
  stddev_pop?: Maybe<FungibleAssetActivitiesStddevPopFields>;
  stddev_samp?: Maybe<FungibleAssetActivitiesStddevSampFields>;
  sum?: Maybe<FungibleAssetActivitiesSumFields>;
  var_pop?: Maybe<FungibleAssetActivitiesVarPopFields>;
  var_samp?: Maybe<FungibleAssetActivitiesVarSampFields>;
  variance?: Maybe<FungibleAssetActivitiesVarianceFields>;
};

/** aggregate fields of "fungible_asset_activities" */
export type FungibleAssetActivitiesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** order by aggregate values of table "fungible_asset_activities" */
export type FungibleAssetActivitiesAggregateOrderBy = {
  avg?: InputMaybe<FungibleAssetActivitiesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<FungibleAssetActivitiesMaxOrderBy>;
  min?: InputMaybe<FungibleAssetActivitiesMinOrderBy>;
  stddev?: InputMaybe<FungibleAssetActivitiesStddevOrderBy>;
  stddev_pop?: InputMaybe<FungibleAssetActivitiesStddevPopOrderBy>;
  stddev_samp?: InputMaybe<FungibleAssetActivitiesStddevSampOrderBy>;
  sum?: InputMaybe<FungibleAssetActivitiesSumOrderBy>;
  var_pop?: InputMaybe<FungibleAssetActivitiesVarPopOrderBy>;
  var_samp?: InputMaybe<FungibleAssetActivitiesVarSampOrderBy>;
  variance?: InputMaybe<FungibleAssetActivitiesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "fungible_asset_activities" */
export type FungibleAssetActivitiesArrRelInsertInput = {
  data: Array<FungibleAssetActivitiesInsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<FungibleAssetActivitiesOnConflict>;
};

/** aggregate avg on columns */
export type FungibleAssetActivitiesAvgFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  block_height?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** order by avg() on columns of table "fungible_asset_activities" */
export type FungibleAssetActivitiesAvgOrderBy = {
  amount?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  storage_refund_amount?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "fungible_asset_activities". All fields are combined with a logical 'AND'. */
export type FungibleAssetActivitiesBoolExp = {
  _and?: InputMaybe<Array<FungibleAssetActivitiesBoolExp>>;
  _not?: InputMaybe<FungibleAssetActivitiesBoolExp>;
  _or?: InputMaybe<Array<FungibleAssetActivitiesBoolExp>>;
  amount?: InputMaybe<NumericComparisonExp>;
  asset_type?: InputMaybe<StringComparisonExp>;
  block_height?: InputMaybe<BigintComparisonExp>;
  entry_function_id_str?: InputMaybe<StringComparisonExp>;
  event_index?: InputMaybe<BigintComparisonExp>;
  gas_fee_payer_address?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_frozen?: InputMaybe<BooleanComparisonExp>;
  is_gas_fee?: InputMaybe<BooleanComparisonExp>;
  is_transaction_success?: InputMaybe<BooleanComparisonExp>;
  metadata?: InputMaybe<FungibleAssetMetadataBoolExp>;
  owner_address?: InputMaybe<StringComparisonExp>;
  owner_cedra_names?: InputMaybe<CurrentCedraNamesBoolExp>;
  owner_cedra_names_aggregate?: InputMaybe<CurrentCedraNamesAggregateBoolExp>;
  storage_id?: InputMaybe<StringComparisonExp>;
  storage_refund_amount?: InputMaybe<NumericComparisonExp>;
  token_standard?: InputMaybe<StringComparisonExp>;
  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  type?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "fungible_asset_activities" */
export enum FungibleAssetActivitiesConstraint {
  /** unique or primary key constraint on columns "event_index", "transaction_version" */
  FungibleAssetActivitiesPkey = "fungible_asset_activities_pkey",
}

/** input type for incrementing numeric columns in table "fungible_asset_activities" */
export type FungibleAssetActivitiesIncInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "fungible_asset_activities" */
export type FungibleAssetActivitiesInsertInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  asset_type?: InputMaybe<Scalars["String"]["input"]>;
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  gas_fee_payer_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_gas_fee?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_transaction_success?: InputMaybe<Scalars["Boolean"]["input"]>;
  metadata?: InputMaybe<FungibleAssetMetadataObjRelInsertInput>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  owner_cedra_names?: InputMaybe<CurrentCedraNamesArrRelInsertInput>;
  storage_id?: InputMaybe<Scalars["String"]["input"]>;
  storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type FungibleAssetActivitiesMaxFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  asset_type?: Maybe<Scalars["String"]["output"]>;
  block_height?: Maybe<Scalars["bigint"]["output"]>;
  entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
  event_index?: Maybe<Scalars["bigint"]["output"]>;
  gas_fee_payer_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  storage_id?: Maybe<Scalars["String"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["numeric"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  type?: Maybe<Scalars["String"]["output"]>;
};

/** order by max() on columns of table "fungible_asset_activities" */
export type FungibleAssetActivitiesMaxOrderBy = {
  amount?: InputMaybe<OrderBy>;
  asset_type?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  entry_function_id_str?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  gas_fee_payer_address?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  owner_address?: InputMaybe<OrderBy>;
  storage_id?: InputMaybe<OrderBy>;
  storage_refund_amount?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
  transaction_timestamp?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type FungibleAssetActivitiesMinFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  asset_type?: Maybe<Scalars["String"]["output"]>;
  block_height?: Maybe<Scalars["bigint"]["output"]>;
  entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
  event_index?: Maybe<Scalars["bigint"]["output"]>;
  gas_fee_payer_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  storage_id?: Maybe<Scalars["String"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["numeric"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  type?: Maybe<Scalars["String"]["output"]>;
};

/** order by min() on columns of table "fungible_asset_activities" */
export type FungibleAssetActivitiesMinOrderBy = {
  amount?: InputMaybe<OrderBy>;
  asset_type?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  entry_function_id_str?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  gas_fee_payer_address?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  owner_address?: InputMaybe<OrderBy>;
  storage_id?: InputMaybe<OrderBy>;
  storage_refund_amount?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
  transaction_timestamp?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "fungible_asset_activities" */
export type FungibleAssetActivitiesMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<FungibleAssetActivities>;
};

/** on_conflict condition type for table "fungible_asset_activities" */
export type FungibleAssetActivitiesOnConflict = {
  constraint: FungibleAssetActivitiesConstraint;
  update_columns?: Array<FungibleAssetActivitiesUpdateColumn>;
  where?: InputMaybe<FungibleAssetActivitiesBoolExp>;
};

/** Ordering options when selecting data from "fungible_asset_activities". */
export type FungibleAssetActivitiesOrderBy = {
  amount?: InputMaybe<OrderBy>;
  asset_type?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  entry_function_id_str?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  gas_fee_payer_address?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_frozen?: InputMaybe<OrderBy>;
  is_gas_fee?: InputMaybe<OrderBy>;
  is_transaction_success?: InputMaybe<OrderBy>;
  metadata?: InputMaybe<FungibleAssetMetadataOrderBy>;
  owner_address?: InputMaybe<OrderBy>;
  owner_cedra_names_aggregate?: InputMaybe<CurrentCedraNamesAggregateOrderBy>;
  storage_id?: InputMaybe<OrderBy>;
  storage_refund_amount?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
  transaction_timestamp?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: fungible_asset_activities */
export type FungibleAssetActivitiesPkColumnsInput = {
  event_index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** select columns of table "fungible_asset_activities" */
export enum FungibleAssetActivitiesSelectColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  AssetType = "asset_type",
  /** column name */
  BlockHeight = "block_height",
  /** column name */
  EntryFunctionIdStr = "entry_function_id_str",
  /** column name */
  EventIndex = "event_index",
  /** column name */
  GasFeePayerAddress = "gas_fee_payer_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsFrozen = "is_frozen",
  /** column name */
  IsGasFee = "is_gas_fee",
  /** column name */
  IsTransactionSuccess = "is_transaction_success",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  StorageId = "storage_id",
  /** column name */
  StorageRefundAmount = "storage_refund_amount",
  /** column name */
  TokenStandard = "token_standard",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  Type = "type",
}

/** select "fungible_asset_activities_aggregate_bool_exp_bool_and_arguments_columns" columns of table "fungible_asset_activities" */
export enum FungibleAssetActivitiesSelectColumnFungibleAssetActivitiesAggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  IsFrozen = "is_frozen",
  /** column name */
  IsGasFee = "is_gas_fee",
  /** column name */
  IsTransactionSuccess = "is_transaction_success",
}

/** select "fungible_asset_activities_aggregate_bool_exp_bool_or_arguments_columns" columns of table "fungible_asset_activities" */
export enum FungibleAssetActivitiesSelectColumnFungibleAssetActivitiesAggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  IsFrozen = "is_frozen",
  /** column name */
  IsGasFee = "is_gas_fee",
  /** column name */
  IsTransactionSuccess = "is_transaction_success",
}

/** input type for updating data in table "fungible_asset_activities" */
export type FungibleAssetActivitiesSetInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  asset_type?: InputMaybe<Scalars["String"]["input"]>;
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  gas_fee_payer_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_gas_fee?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_transaction_success?: InputMaybe<Scalars["Boolean"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  storage_id?: InputMaybe<Scalars["String"]["input"]>;
  storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type FungibleAssetActivitiesStddevFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  block_height?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** order by stddev() on columns of table "fungible_asset_activities" */
export type FungibleAssetActivitiesStddevOrderBy = {
  amount?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  storage_refund_amount?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type FungibleAssetActivitiesStddevPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  block_height?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** order by stddev_pop() on columns of table "fungible_asset_activities" */
export type FungibleAssetActivitiesStddevPopOrderBy = {
  amount?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  storage_refund_amount?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type FungibleAssetActivitiesStddevSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  block_height?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** order by stddev_samp() on columns of table "fungible_asset_activities" */
export type FungibleAssetActivitiesStddevSampOrderBy = {
  amount?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  storage_refund_amount?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "fungible_asset_activities" */
export type FungibleAssetActivitiesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: FungibleAssetActivitiesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type FungibleAssetActivitiesStreamCursorValueInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  asset_type?: InputMaybe<Scalars["String"]["input"]>;
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  gas_fee_payer_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_gas_fee?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_transaction_success?: InputMaybe<Scalars["Boolean"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  storage_id?: InputMaybe<Scalars["String"]["input"]>;
  storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type FungibleAssetActivitiesSumFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  block_height?: Maybe<Scalars["bigint"]["output"]>;
  event_index?: Maybe<Scalars["bigint"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["numeric"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** order by sum() on columns of table "fungible_asset_activities" */
export type FungibleAssetActivitiesSumOrderBy = {
  amount?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  storage_refund_amount?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** update columns of table "fungible_asset_activities" */
export enum FungibleAssetActivitiesUpdateColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  AssetType = "asset_type",
  /** column name */
  BlockHeight = "block_height",
  /** column name */
  EntryFunctionIdStr = "entry_function_id_str",
  /** column name */
  EventIndex = "event_index",
  /** column name */
  GasFeePayerAddress = "gas_fee_payer_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsFrozen = "is_frozen",
  /** column name */
  IsGasFee = "is_gas_fee",
  /** column name */
  IsTransactionSuccess = "is_transaction_success",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  StorageId = "storage_id",
  /** column name */
  StorageRefundAmount = "storage_refund_amount",
  /** column name */
  TokenStandard = "token_standard",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  Type = "type",
}

export type FungibleAssetActivitiesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<FungibleAssetActivitiesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<FungibleAssetActivitiesSetInput>;
  /** filter the rows which have to be updated */
  where: FungibleAssetActivitiesBoolExp;
};

/** aggregate var_pop on columns */
export type FungibleAssetActivitiesVarPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  block_height?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** order by var_pop() on columns of table "fungible_asset_activities" */
export type FungibleAssetActivitiesVarPopOrderBy = {
  amount?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  storage_refund_amount?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type FungibleAssetActivitiesVarSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  block_height?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** order by var_samp() on columns of table "fungible_asset_activities" */
export type FungibleAssetActivitiesVarSampOrderBy = {
  amount?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  storage_refund_amount?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type FungibleAssetActivitiesVarianceFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  block_height?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** order by variance() on columns of table "fungible_asset_activities" */
export type FungibleAssetActivitiesVarianceOrderBy = {
  amount?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  storage_refund_amount?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** columns and relationships of "fungible_asset_balances" */
export type FungibleAssetBalances = {
  amount: Scalars["numeric"]["output"];
  asset_type: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  is_frozen: Scalars["Boolean"]["output"];
  is_primary: Scalars["Boolean"]["output"];
  owner_address: Scalars["String"]["output"];
  storage_id: Scalars["String"]["output"];
  token_standard: Scalars["String"]["output"];
  transaction_timestamp: Scalars["timestamp"]["output"];
  transaction_version: Scalars["bigint"]["output"];
  write_set_change_index: Scalars["bigint"]["output"];
};

/** aggregated selection of "fungible_asset_balances" */
export type FungibleAssetBalancesAggregate = {
  aggregate?: Maybe<FungibleAssetBalancesAggregateFields>;
  nodes: Array<FungibleAssetBalances>;
};

/** aggregate fields of "fungible_asset_balances" */
export type FungibleAssetBalancesAggregateFields = {
  avg?: Maybe<FungibleAssetBalancesAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<FungibleAssetBalancesMaxFields>;
  min?: Maybe<FungibleAssetBalancesMinFields>;
  stddev?: Maybe<FungibleAssetBalancesStddevFields>;
  stddev_pop?: Maybe<FungibleAssetBalancesStddevPopFields>;
  stddev_samp?: Maybe<FungibleAssetBalancesStddevSampFields>;
  sum?: Maybe<FungibleAssetBalancesSumFields>;
  var_pop?: Maybe<FungibleAssetBalancesVarPopFields>;
  var_samp?: Maybe<FungibleAssetBalancesVarSampFields>;
  variance?: Maybe<FungibleAssetBalancesVarianceFields>;
};

/** aggregate fields of "fungible_asset_balances" */
export type FungibleAssetBalancesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<FungibleAssetBalancesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type FungibleAssetBalancesAvgFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "fungible_asset_balances". All fields are combined with a logical 'AND'. */
export type FungibleAssetBalancesBoolExp = {
  _and?: InputMaybe<Array<FungibleAssetBalancesBoolExp>>;
  _not?: InputMaybe<FungibleAssetBalancesBoolExp>;
  _or?: InputMaybe<Array<FungibleAssetBalancesBoolExp>>;
  amount?: InputMaybe<NumericComparisonExp>;
  asset_type?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_frozen?: InputMaybe<BooleanComparisonExp>;
  is_primary?: InputMaybe<BooleanComparisonExp>;
  owner_address?: InputMaybe<StringComparisonExp>;
  storage_id?: InputMaybe<StringComparisonExp>;
  token_standard?: InputMaybe<StringComparisonExp>;
  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  write_set_change_index?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "fungible_asset_balances" */
export enum FungibleAssetBalancesConstraint {
  /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
  FungibleAssetBalancesPkey = "fungible_asset_balances_pkey",
}

/** input type for incrementing numeric columns in table "fungible_asset_balances" */
export type FungibleAssetBalancesIncInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "fungible_asset_balances" */
export type FungibleAssetBalancesInsertInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  asset_type?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  storage_id?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type FungibleAssetBalancesMaxFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  asset_type?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  storage_id?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type FungibleAssetBalancesMinFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  asset_type?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  storage_id?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "fungible_asset_balances" */
export type FungibleAssetBalancesMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<FungibleAssetBalances>;
};

/** on_conflict condition type for table "fungible_asset_balances" */
export type FungibleAssetBalancesOnConflict = {
  constraint: FungibleAssetBalancesConstraint;
  update_columns?: Array<FungibleAssetBalancesUpdateColumn>;
  where?: InputMaybe<FungibleAssetBalancesBoolExp>;
};

/** Ordering options when selecting data from "fungible_asset_balances". */
export type FungibleAssetBalancesOrderBy = {
  amount?: InputMaybe<OrderBy>;
  asset_type?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_frozen?: InputMaybe<OrderBy>;
  is_primary?: InputMaybe<OrderBy>;
  owner_address?: InputMaybe<OrderBy>;
  storage_id?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
  transaction_timestamp?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  write_set_change_index?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: fungible_asset_balances */
export type FungibleAssetBalancesPkColumnsInput = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** select columns of table "fungible_asset_balances" */
export enum FungibleAssetBalancesSelectColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  AssetType = "asset_type",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsFrozen = "is_frozen",
  /** column name */
  IsPrimary = "is_primary",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  StorageId = "storage_id",
  /** column name */
  TokenStandard = "token_standard",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

/** input type for updating data in table "fungible_asset_balances" */
export type FungibleAssetBalancesSetInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  asset_type?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  storage_id?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type FungibleAssetBalancesStddevFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type FungibleAssetBalancesStddevPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type FungibleAssetBalancesStddevSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "fungible_asset_balances" */
export type FungibleAssetBalancesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: FungibleAssetBalancesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type FungibleAssetBalancesStreamCursorValueInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  asset_type?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  storage_id?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type FungibleAssetBalancesSumFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "fungible_asset_balances" */
export enum FungibleAssetBalancesUpdateColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  AssetType = "asset_type",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsFrozen = "is_frozen",
  /** column name */
  IsPrimary = "is_primary",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  StorageId = "storage_id",
  /** column name */
  TokenStandard = "token_standard",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

export type FungibleAssetBalancesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<FungibleAssetBalancesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<FungibleAssetBalancesSetInput>;
  /** filter the rows which have to be updated */
  where: FungibleAssetBalancesBoolExp;
};

/** aggregate var_pop on columns */
export type FungibleAssetBalancesVarPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type FungibleAssetBalancesVarSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type FungibleAssetBalancesVarianceFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "fungible_asset_metadata" */
export type FungibleAssetMetadata = {
  asset_type: Scalars["String"]["output"];
  creator_address: Scalars["String"]["output"];
  decimals: Scalars["Int"]["output"];
  icon_uri?: Maybe<Scalars["String"]["output"]>;
  inserted_at: Scalars["timestamp"]["output"];
  is_token_v2?: Maybe<Scalars["Boolean"]["output"]>;
  last_transaction_timestamp: Scalars["timestamp"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  maximum_v2?: Maybe<Scalars["numeric"]["output"]>;
  name: Scalars["String"]["output"];
  project_uri?: Maybe<Scalars["String"]["output"]>;
  supply_aggregator_table_handle_v1?: Maybe<Scalars["String"]["output"]>;
  supply_aggregator_table_key_v1?: Maybe<Scalars["String"]["output"]>;
  supply_v2?: Maybe<Scalars["numeric"]["output"]>;
  symbol: Scalars["String"]["output"];
  token_standard: Scalars["String"]["output"];
};

/** aggregated selection of "fungible_asset_metadata" */
export type FungibleAssetMetadataAggregate = {
  aggregate?: Maybe<FungibleAssetMetadataAggregateFields>;
  nodes: Array<FungibleAssetMetadata>;
};

/** aggregate fields of "fungible_asset_metadata" */
export type FungibleAssetMetadataAggregateFields = {
  avg?: Maybe<FungibleAssetMetadataAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<FungibleAssetMetadataMaxFields>;
  min?: Maybe<FungibleAssetMetadataMinFields>;
  stddev?: Maybe<FungibleAssetMetadataStddevFields>;
  stddev_pop?: Maybe<FungibleAssetMetadataStddevPopFields>;
  stddev_samp?: Maybe<FungibleAssetMetadataStddevSampFields>;
  sum?: Maybe<FungibleAssetMetadataSumFields>;
  var_pop?: Maybe<FungibleAssetMetadataVarPopFields>;
  var_samp?: Maybe<FungibleAssetMetadataVarSampFields>;
  variance?: Maybe<FungibleAssetMetadataVarianceFields>;
};

/** aggregate fields of "fungible_asset_metadata" */
export type FungibleAssetMetadataAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<FungibleAssetMetadataSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type FungibleAssetMetadataAvgFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum_v2?: Maybe<Scalars["Float"]["output"]>;
  supply_v2?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "fungible_asset_metadata". All fields are combined with a logical 'AND'. */
export type FungibleAssetMetadataBoolExp = {
  _and?: InputMaybe<Array<FungibleAssetMetadataBoolExp>>;
  _not?: InputMaybe<FungibleAssetMetadataBoolExp>;
  _or?: InputMaybe<Array<FungibleAssetMetadataBoolExp>>;
  asset_type?: InputMaybe<StringComparisonExp>;
  creator_address?: InputMaybe<StringComparisonExp>;
  decimals?: InputMaybe<IntComparisonExp>;
  icon_uri?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_token_v2?: InputMaybe<BooleanComparisonExp>;
  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  maximum_v2?: InputMaybe<NumericComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  project_uri?: InputMaybe<StringComparisonExp>;
  supply_aggregator_table_handle_v1?: InputMaybe<StringComparisonExp>;
  supply_aggregator_table_key_v1?: InputMaybe<StringComparisonExp>;
  supply_v2?: InputMaybe<NumericComparisonExp>;
  symbol?: InputMaybe<StringComparisonExp>;
  token_standard?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "fungible_asset_metadata" */
export enum FungibleAssetMetadataConstraint {
  /** unique or primary key constraint on columns "asset_type" */
  FungibleAssetMetadataPkey = "fungible_asset_metadata_pkey",
}

/** input type for incrementing numeric columns in table "fungible_asset_metadata" */
export type FungibleAssetMetadataIncInput = {
  decimals?: InputMaybe<Scalars["Int"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  maximum_v2?: InputMaybe<Scalars["numeric"]["input"]>;
  supply_v2?: InputMaybe<Scalars["numeric"]["input"]>;
};

/** input type for inserting data into table "fungible_asset_metadata" */
export type FungibleAssetMetadataInsertInput = {
  asset_type?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  decimals?: InputMaybe<Scalars["Int"]["input"]>;
  icon_uri?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_token_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  maximum_v2?: InputMaybe<Scalars["numeric"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  project_uri?: InputMaybe<Scalars["String"]["input"]>;
  supply_aggregator_table_handle_v1?: InputMaybe<Scalars["String"]["input"]>;
  supply_aggregator_table_key_v1?: InputMaybe<Scalars["String"]["input"]>;
  supply_v2?: InputMaybe<Scalars["numeric"]["input"]>;
  symbol?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type FungibleAssetMetadataMaxFields = {
  asset_type?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  decimals?: Maybe<Scalars["Int"]["output"]>;
  icon_uri?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  maximum_v2?: Maybe<Scalars["numeric"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  project_uri?: Maybe<Scalars["String"]["output"]>;
  supply_aggregator_table_handle_v1?: Maybe<Scalars["String"]["output"]>;
  supply_aggregator_table_key_v1?: Maybe<Scalars["String"]["output"]>;
  supply_v2?: Maybe<Scalars["numeric"]["output"]>;
  symbol?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type FungibleAssetMetadataMinFields = {
  asset_type?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  decimals?: Maybe<Scalars["Int"]["output"]>;
  icon_uri?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  maximum_v2?: Maybe<Scalars["numeric"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  project_uri?: Maybe<Scalars["String"]["output"]>;
  supply_aggregator_table_handle_v1?: Maybe<Scalars["String"]["output"]>;
  supply_aggregator_table_key_v1?: Maybe<Scalars["String"]["output"]>;
  supply_v2?: Maybe<Scalars["numeric"]["output"]>;
  symbol?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "fungible_asset_metadata" */
export type FungibleAssetMetadataMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<FungibleAssetMetadata>;
};

/** input type for inserting object relation for remote table "fungible_asset_metadata" */
export type FungibleAssetMetadataObjRelInsertInput = {
  data: FungibleAssetMetadataInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<FungibleAssetMetadataOnConflict>;
};

/** on_conflict condition type for table "fungible_asset_metadata" */
export type FungibleAssetMetadataOnConflict = {
  constraint: FungibleAssetMetadataConstraint;
  update_columns?: Array<FungibleAssetMetadataUpdateColumn>;
  where?: InputMaybe<FungibleAssetMetadataBoolExp>;
};

/** Ordering options when selecting data from "fungible_asset_metadata". */
export type FungibleAssetMetadataOrderBy = {
  asset_type?: InputMaybe<OrderBy>;
  creator_address?: InputMaybe<OrderBy>;
  decimals?: InputMaybe<OrderBy>;
  icon_uri?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_token_v2?: InputMaybe<OrderBy>;
  last_transaction_timestamp?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  maximum_v2?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  project_uri?: InputMaybe<OrderBy>;
  supply_aggregator_table_handle_v1?: InputMaybe<OrderBy>;
  supply_aggregator_table_key_v1?: InputMaybe<OrderBy>;
  supply_v2?: InputMaybe<OrderBy>;
  symbol?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: fungible_asset_metadata */
export type FungibleAssetMetadataPkColumnsInput = {
  asset_type: Scalars["String"]["input"];
};

/** select columns of table "fungible_asset_metadata" */
export enum FungibleAssetMetadataSelectColumn {
  /** column name */
  AssetType = "asset_type",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  Decimals = "decimals",
  /** column name */
  IconUri = "icon_uri",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsTokenV2 = "is_token_v2",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  MaximumV2 = "maximum_v2",
  /** column name */
  Name = "name",
  /** column name */
  ProjectUri = "project_uri",
  /** column name */
  SupplyAggregatorTableHandleV1 = "supply_aggregator_table_handle_v1",
  /** column name */
  SupplyAggregatorTableKeyV1 = "supply_aggregator_table_key_v1",
  /** column name */
  SupplyV2 = "supply_v2",
  /** column name */
  Symbol = "symbol",
  /** column name */
  TokenStandard = "token_standard",
}

/** input type for updating data in table "fungible_asset_metadata" */
export type FungibleAssetMetadataSetInput = {
  asset_type?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  decimals?: InputMaybe<Scalars["Int"]["input"]>;
  icon_uri?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_token_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  maximum_v2?: InputMaybe<Scalars["numeric"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  project_uri?: InputMaybe<Scalars["String"]["input"]>;
  supply_aggregator_table_handle_v1?: InputMaybe<Scalars["String"]["input"]>;
  supply_aggregator_table_key_v1?: InputMaybe<Scalars["String"]["input"]>;
  supply_v2?: InputMaybe<Scalars["numeric"]["input"]>;
  symbol?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type FungibleAssetMetadataStddevFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum_v2?: Maybe<Scalars["Float"]["output"]>;
  supply_v2?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type FungibleAssetMetadataStddevPopFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum_v2?: Maybe<Scalars["Float"]["output"]>;
  supply_v2?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type FungibleAssetMetadataStddevSampFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum_v2?: Maybe<Scalars["Float"]["output"]>;
  supply_v2?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "fungible_asset_metadata" */
export type FungibleAssetMetadataStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: FungibleAssetMetadataStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type FungibleAssetMetadataStreamCursorValueInput = {
  asset_type?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  decimals?: InputMaybe<Scalars["Int"]["input"]>;
  icon_uri?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_token_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  maximum_v2?: InputMaybe<Scalars["numeric"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  project_uri?: InputMaybe<Scalars["String"]["input"]>;
  supply_aggregator_table_handle_v1?: InputMaybe<Scalars["String"]["input"]>;
  supply_aggregator_table_key_v1?: InputMaybe<Scalars["String"]["input"]>;
  supply_v2?: InputMaybe<Scalars["numeric"]["input"]>;
  symbol?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type FungibleAssetMetadataSumFields = {
  decimals?: Maybe<Scalars["Int"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  maximum_v2?: Maybe<Scalars["numeric"]["output"]>;
  supply_v2?: Maybe<Scalars["numeric"]["output"]>;
};

/** update columns of table "fungible_asset_metadata" */
export enum FungibleAssetMetadataUpdateColumn {
  /** column name */
  AssetType = "asset_type",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  Decimals = "decimals",
  /** column name */
  IconUri = "icon_uri",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsTokenV2 = "is_token_v2",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  MaximumV2 = "maximum_v2",
  /** column name */
  Name = "name",
  /** column name */
  ProjectUri = "project_uri",
  /** column name */
  SupplyAggregatorTableHandleV1 = "supply_aggregator_table_handle_v1",
  /** column name */
  SupplyAggregatorTableKeyV1 = "supply_aggregator_table_key_v1",
  /** column name */
  SupplyV2 = "supply_v2",
  /** column name */
  Symbol = "symbol",
  /** column name */
  TokenStandard = "token_standard",
}

export type FungibleAssetMetadataUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<FungibleAssetMetadataIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<FungibleAssetMetadataSetInput>;
  /** filter the rows which have to be updated */
  where: FungibleAssetMetadataBoolExp;
};

/** aggregate var_pop on columns */
export type FungibleAssetMetadataVarPopFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum_v2?: Maybe<Scalars["Float"]["output"]>;
  supply_v2?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type FungibleAssetMetadataVarSampFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum_v2?: Maybe<Scalars["Float"]["output"]>;
  supply_v2?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type FungibleAssetMetadataVarianceFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
  maximum_v2?: Maybe<Scalars["Float"]["output"]>;
  supply_v2?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "fungible_asset_to_coin_mappings" */
export type FungibleAssetToCoinMappings = {
  coin_type: Scalars["String"]["output"];
  fungible_asset_metadata_address: Scalars["String"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
};

/** aggregated selection of "fungible_asset_to_coin_mappings" */
export type FungibleAssetToCoinMappingsAggregate = {
  aggregate?: Maybe<FungibleAssetToCoinMappingsAggregateFields>;
  nodes: Array<FungibleAssetToCoinMappings>;
};

/** aggregate fields of "fungible_asset_to_coin_mappings" */
export type FungibleAssetToCoinMappingsAggregateFields = {
  avg?: Maybe<FungibleAssetToCoinMappingsAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<FungibleAssetToCoinMappingsMaxFields>;
  min?: Maybe<FungibleAssetToCoinMappingsMinFields>;
  stddev?: Maybe<FungibleAssetToCoinMappingsStddevFields>;
  stddev_pop?: Maybe<FungibleAssetToCoinMappingsStddevPopFields>;
  stddev_samp?: Maybe<FungibleAssetToCoinMappingsStddevSampFields>;
  sum?: Maybe<FungibleAssetToCoinMappingsSumFields>;
  var_pop?: Maybe<FungibleAssetToCoinMappingsVarPopFields>;
  var_samp?: Maybe<FungibleAssetToCoinMappingsVarSampFields>;
  variance?: Maybe<FungibleAssetToCoinMappingsVarianceFields>;
};

/** aggregate fields of "fungible_asset_to_coin_mappings" */
export type FungibleAssetToCoinMappingsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<FungibleAssetToCoinMappingsSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type FungibleAssetToCoinMappingsAvgFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "fungible_asset_to_coin_mappings". All fields are combined with a logical 'AND'. */
export type FungibleAssetToCoinMappingsBoolExp = {
  _and?: InputMaybe<Array<FungibleAssetToCoinMappingsBoolExp>>;
  _not?: InputMaybe<FungibleAssetToCoinMappingsBoolExp>;
  _or?: InputMaybe<Array<FungibleAssetToCoinMappingsBoolExp>>;
  coin_type?: InputMaybe<StringComparisonExp>;
  fungible_asset_metadata_address?: InputMaybe<StringComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "fungible_asset_to_coin_mappings" */
export enum FungibleAssetToCoinMappingsConstraint {
  /** unique or primary key constraint on columns "fungible_asset_metadata_address" */
  FungibleAssetToCoinMappingsPkey = "fungible_asset_to_coin_mappings_pkey",
}

/** input type for incrementing numeric columns in table "fungible_asset_to_coin_mappings" */
export type FungibleAssetToCoinMappingsIncInput = {
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "fungible_asset_to_coin_mappings" */
export type FungibleAssetToCoinMappingsInsertInput = {
  coin_type?: InputMaybe<Scalars["String"]["input"]>;
  fungible_asset_metadata_address?: InputMaybe<Scalars["String"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type FungibleAssetToCoinMappingsMaxFields = {
  coin_type?: Maybe<Scalars["String"]["output"]>;
  fungible_asset_metadata_address?: Maybe<Scalars["String"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type FungibleAssetToCoinMappingsMinFields = {
  coin_type?: Maybe<Scalars["String"]["output"]>;
  fungible_asset_metadata_address?: Maybe<Scalars["String"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "fungible_asset_to_coin_mappings" */
export type FungibleAssetToCoinMappingsMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<FungibleAssetToCoinMappings>;
};

/** on_conflict condition type for table "fungible_asset_to_coin_mappings" */
export type FungibleAssetToCoinMappingsOnConflict = {
  constraint: FungibleAssetToCoinMappingsConstraint;
  update_columns?: Array<FungibleAssetToCoinMappingsUpdateColumn>;
  where?: InputMaybe<FungibleAssetToCoinMappingsBoolExp>;
};

/** Ordering options when selecting data from "fungible_asset_to_coin_mappings". */
export type FungibleAssetToCoinMappingsOrderBy = {
  coin_type?: InputMaybe<OrderBy>;
  fungible_asset_metadata_address?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: fungible_asset_to_coin_mappings */
export type FungibleAssetToCoinMappingsPkColumnsInput = {
  fungible_asset_metadata_address: Scalars["String"]["input"];
};

/** select columns of table "fungible_asset_to_coin_mappings" */
export enum FungibleAssetToCoinMappingsSelectColumn {
  /** column name */
  CoinType = "coin_type",
  /** column name */
  FungibleAssetMetadataAddress = "fungible_asset_metadata_address",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
}

/** input type for updating data in table "fungible_asset_to_coin_mappings" */
export type FungibleAssetToCoinMappingsSetInput = {
  coin_type?: InputMaybe<Scalars["String"]["input"]>;
  fungible_asset_metadata_address?: InputMaybe<Scalars["String"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type FungibleAssetToCoinMappingsStddevFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type FungibleAssetToCoinMappingsStddevPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type FungibleAssetToCoinMappingsStddevSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "fungible_asset_to_coin_mappings" */
export type FungibleAssetToCoinMappingsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: FungibleAssetToCoinMappingsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type FungibleAssetToCoinMappingsStreamCursorValueInput = {
  coin_type?: InputMaybe<Scalars["String"]["input"]>;
  fungible_asset_metadata_address?: InputMaybe<Scalars["String"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type FungibleAssetToCoinMappingsSumFields = {
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "fungible_asset_to_coin_mappings" */
export enum FungibleAssetToCoinMappingsUpdateColumn {
  /** column name */
  CoinType = "coin_type",
  /** column name */
  FungibleAssetMetadataAddress = "fungible_asset_metadata_address",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
}

export type FungibleAssetToCoinMappingsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<FungibleAssetToCoinMappingsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<FungibleAssetToCoinMappingsSetInput>;
  /** filter the rows which have to be updated */
  where: FungibleAssetToCoinMappingsBoolExp;
};

/** aggregate var_pop on columns */
export type FungibleAssetToCoinMappingsVarPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type FungibleAssetToCoinMappingsVarSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type FungibleAssetToCoinMappingsVarianceFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "gas_fees" */
export type GasFees = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  block_height: Scalars["bigint"]["output"];
  entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
  gas_fee_payer_address?: Maybe<Scalars["String"]["output"]>;
  is_transaction_success: Scalars["Boolean"]["output"];
  owner_address?: Maybe<Scalars["String"]["output"]>;
  storage_refund_amount: Scalars["numeric"]["output"];
  transaction_timestamp: Scalars["timestamp"]["output"];
  transaction_version: Scalars["bigint"]["output"];
};

/** aggregated selection of "gas_fees" */
export type GasFeesAggregate = {
  aggregate?: Maybe<GasFeesAggregateFields>;
  nodes: Array<GasFees>;
};

/** aggregate fields of "gas_fees" */
export type GasFeesAggregateFields = {
  avg?: Maybe<GasFeesAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<GasFeesMaxFields>;
  min?: Maybe<GasFeesMinFields>;
  stddev?: Maybe<GasFeesStddevFields>;
  stddev_pop?: Maybe<GasFeesStddevPopFields>;
  stddev_samp?: Maybe<GasFeesStddevSampFields>;
  sum?: Maybe<GasFeesSumFields>;
  var_pop?: Maybe<GasFeesVarPopFields>;
  var_samp?: Maybe<GasFeesVarSampFields>;
  variance?: Maybe<GasFeesVarianceFields>;
};

/** aggregate fields of "gas_fees" */
export type GasFeesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<GasFeesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type GasFeesAvgFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  block_height?: Maybe<Scalars["Float"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "gas_fees". All fields are combined with a logical 'AND'. */
export type GasFeesBoolExp = {
  _and?: InputMaybe<Array<GasFeesBoolExp>>;
  _not?: InputMaybe<GasFeesBoolExp>;
  _or?: InputMaybe<Array<GasFeesBoolExp>>;
  amount?: InputMaybe<NumericComparisonExp>;
  block_height?: InputMaybe<BigintComparisonExp>;
  entry_function_id_str?: InputMaybe<StringComparisonExp>;
  gas_fee_payer_address?: InputMaybe<StringComparisonExp>;
  is_transaction_success?: InputMaybe<BooleanComparisonExp>;
  owner_address?: InputMaybe<StringComparisonExp>;
  storage_refund_amount?: InputMaybe<NumericComparisonExp>;
  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "gas_fees" */
export enum GasFeesConstraint {
  /** unique or primary key constraint on columns "transaction_version" */
  GasFeesPkey = "gas_fees_pkey",
}

/** input type for incrementing numeric columns in table "gas_fees" */
export type GasFeesIncInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "gas_fees" */
export type GasFeesInsertInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
  gas_fee_payer_address?: InputMaybe<Scalars["String"]["input"]>;
  is_transaction_success?: InputMaybe<Scalars["Boolean"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type GasFeesMaxFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  block_height?: Maybe<Scalars["bigint"]["output"]>;
  entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
  gas_fee_payer_address?: Maybe<Scalars["String"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["numeric"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type GasFeesMinFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  block_height?: Maybe<Scalars["bigint"]["output"]>;
  entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
  gas_fee_payer_address?: Maybe<Scalars["String"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["numeric"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "gas_fees" */
export type GasFeesMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<GasFees>;
};

/** on_conflict condition type for table "gas_fees" */
export type GasFeesOnConflict = {
  constraint: GasFeesConstraint;
  update_columns?: Array<GasFeesUpdateColumn>;
  where?: InputMaybe<GasFeesBoolExp>;
};

/** Ordering options when selecting data from "gas_fees". */
export type GasFeesOrderBy = {
  amount?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  entry_function_id_str?: InputMaybe<OrderBy>;
  gas_fee_payer_address?: InputMaybe<OrderBy>;
  is_transaction_success?: InputMaybe<OrderBy>;
  owner_address?: InputMaybe<OrderBy>;
  storage_refund_amount?: InputMaybe<OrderBy>;
  transaction_timestamp?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: gas_fees */
export type GasFeesPkColumnsInput = {
  transaction_version: Scalars["bigint"]["input"];
};

/** select columns of table "gas_fees" */
export enum GasFeesSelectColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  BlockHeight = "block_height",
  /** column name */
  EntryFunctionIdStr = "entry_function_id_str",
  /** column name */
  GasFeePayerAddress = "gas_fee_payer_address",
  /** column name */
  IsTransactionSuccess = "is_transaction_success",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  StorageRefundAmount = "storage_refund_amount",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
}

/** input type for updating data in table "gas_fees" */
export type GasFeesSetInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
  gas_fee_payer_address?: InputMaybe<Scalars["String"]["input"]>;
  is_transaction_success?: InputMaybe<Scalars["Boolean"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type GasFeesStddevFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  block_height?: Maybe<Scalars["Float"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type GasFeesStddevPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  block_height?: Maybe<Scalars["Float"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type GasFeesStddevSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  block_height?: Maybe<Scalars["Float"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "gas_fees" */
export type GasFeesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: GasFeesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type GasFeesStreamCursorValueInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
  gas_fee_payer_address?: InputMaybe<Scalars["String"]["input"]>;
  is_transaction_success?: InputMaybe<Scalars["Boolean"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type GasFeesSumFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  block_height?: Maybe<Scalars["bigint"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["numeric"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "gas_fees" */
export enum GasFeesUpdateColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  BlockHeight = "block_height",
  /** column name */
  EntryFunctionIdStr = "entry_function_id_str",
  /** column name */
  GasFeePayerAddress = "gas_fee_payer_address",
  /** column name */
  IsTransactionSuccess = "is_transaction_success",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  StorageRefundAmount = "storage_refund_amount",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
}

export type GasFeesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<GasFeesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GasFeesSetInput>;
  /** filter the rows which have to be updated */
  where: GasFeesBoolExp;
};

/** aggregate var_pop on columns */
export type GasFeesVarPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  block_height?: Maybe<Scalars["Float"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type GasFeesVarSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  block_height?: Maybe<Scalars["Float"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type GasFeesVarianceFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  block_height?: Maybe<Scalars["Float"]["output"]>;
  storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "indexer_status" */
export type IndexerStatus = {
  db: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  is_indexer_up: Scalars["Boolean"]["output"];
};

/** aggregated selection of "indexer_status" */
export type IndexerStatusAggregate = {
  aggregate?: Maybe<IndexerStatusAggregateFields>;
  nodes: Array<IndexerStatus>;
};

/** aggregate fields of "indexer_status" */
export type IndexerStatusAggregateFields = {
  count: Scalars["Int"]["output"];
  max?: Maybe<IndexerStatusMaxFields>;
  min?: Maybe<IndexerStatusMinFields>;
};

/** aggregate fields of "indexer_status" */
export type IndexerStatusAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<IndexerStatusSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** Boolean expression to filter rows from the table "indexer_status". All fields are combined with a logical 'AND'. */
export type IndexerStatusBoolExp = {
  _and?: InputMaybe<Array<IndexerStatusBoolExp>>;
  _not?: InputMaybe<IndexerStatusBoolExp>;
  _or?: InputMaybe<Array<IndexerStatusBoolExp>>;
  db?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_indexer_up?: InputMaybe<BooleanComparisonExp>;
};

/** unique or primary key constraints on table "indexer_status" */
export enum IndexerStatusConstraint {
  /** unique or primary key constraint on columns "db" */
  IndexerStatusPkey = "indexer_status_pkey",
}

/** input type for inserting data into table "indexer_status" */
export type IndexerStatusInsertInput = {
  db?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_indexer_up?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate max on columns */
export type IndexerStatusMaxFields = {
  db?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
};

/** aggregate min on columns */
export type IndexerStatusMinFields = {
  db?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
};

/** response of any mutation on the table "indexer_status" */
export type IndexerStatusMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<IndexerStatus>;
};

/** on_conflict condition type for table "indexer_status" */
export type IndexerStatusOnConflict = {
  constraint: IndexerStatusConstraint;
  update_columns?: Array<IndexerStatusUpdateColumn>;
  where?: InputMaybe<IndexerStatusBoolExp>;
};

/** Ordering options when selecting data from "indexer_status". */
export type IndexerStatusOrderBy = {
  db?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_indexer_up?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: indexer_status */
export type IndexerStatusPkColumnsInput = {
  db: Scalars["String"]["input"];
};

/** select columns of table "indexer_status" */
export enum IndexerStatusSelectColumn {
  /** column name */
  Db = "db",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsIndexerUp = "is_indexer_up",
}

/** input type for updating data in table "indexer_status" */
export type IndexerStatusSetInput = {
  db?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_indexer_up?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** Streaming cursor of the table "indexer_status" */
export type IndexerStatusStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: IndexerStatusStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type IndexerStatusStreamCursorValueInput = {
  db?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_indexer_up?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** update columns of table "indexer_status" */
export enum IndexerStatusUpdateColumn {
  /** column name */
  Db = "db",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsIndexerUp = "is_indexer_up",
}

export type IndexerStatusUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<IndexerStatusSetInput>;
  /** filter the rows which have to be updated */
  where: IndexerStatusBoolExp;
};

export type JsonbCastExp = {
  String?: InputMaybe<StringComparisonExp>;
};

/** Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'. */
export type JsonbComparisonExp = {
  _cast?: InputMaybe<JsonbCastExp>;
  /** is the column contained in the given json value */
  _contained_in?: InputMaybe<Scalars["jsonb"]["input"]>;
  /** does the column contain the given json value at the top level */
  _contains?: InputMaybe<Scalars["jsonb"]["input"]>;
  _eq?: InputMaybe<Scalars["jsonb"]["input"]>;
  _gt?: InputMaybe<Scalars["jsonb"]["input"]>;
  _gte?: InputMaybe<Scalars["jsonb"]["input"]>;
  /** does the string exist as a top-level key in the column */
  _has_key?: InputMaybe<Scalars["String"]["input"]>;
  /** do all of these strings exist as top-level keys in the column */
  _has_keys_all?: InputMaybe<Array<Scalars["String"]["input"]>>;
  /** do any of these strings exist as top-level keys in the column */
  _has_keys_any?: InputMaybe<Array<Scalars["String"]["input"]>>;
  _in?: InputMaybe<Array<Scalars["jsonb"]["input"]>>;
  _is_null?: InputMaybe<Scalars["Boolean"]["input"]>;
  _lt?: InputMaybe<Scalars["jsonb"]["input"]>;
  _lte?: InputMaybe<Scalars["jsonb"]["input"]>;
  _neq?: InputMaybe<Scalars["jsonb"]["input"]>;
  _nin?: InputMaybe<Array<Scalars["jsonb"]["input"]>>;
};

/** columns and relationships of "move_modules" */
export type MoveModules = {
  address: Scalars["String"]["output"];
  bytecode?: Maybe<Scalars["bytea"]["output"]>;
  exposed_functions?: Maybe<Scalars["jsonb"]["output"]>;
  friends?: Maybe<Scalars["jsonb"]["output"]>;
  inserted_at: Scalars["timestamp"]["output"];
  is_deleted: Scalars["Boolean"]["output"];
  name: Scalars["String"]["output"];
  structs?: Maybe<Scalars["jsonb"]["output"]>;
  transaction_block_height: Scalars["bigint"]["output"];
  transaction_version: Scalars["bigint"]["output"];
  write_set_change_index: Scalars["bigint"]["output"];
};

/** columns and relationships of "move_modules" */
export type MoveModulesExposedFunctionsArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** columns and relationships of "move_modules" */
export type MoveModulesFriendsArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** columns and relationships of "move_modules" */
export type MoveModulesStructsArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregated selection of "move_modules" */
export type MoveModulesAggregate = {
  aggregate?: Maybe<MoveModulesAggregateFields>;
  nodes: Array<MoveModules>;
};

/** aggregate fields of "move_modules" */
export type MoveModulesAggregateFields = {
  avg?: Maybe<MoveModulesAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<MoveModulesMaxFields>;
  min?: Maybe<MoveModulesMinFields>;
  stddev?: Maybe<MoveModulesStddevFields>;
  stddev_pop?: Maybe<MoveModulesStddevPopFields>;
  stddev_samp?: Maybe<MoveModulesStddevSampFields>;
  sum?: Maybe<MoveModulesSumFields>;
  var_pop?: Maybe<MoveModulesVarPopFields>;
  var_samp?: Maybe<MoveModulesVarSampFields>;
  variance?: Maybe<MoveModulesVarianceFields>;
};

/** aggregate fields of "move_modules" */
export type MoveModulesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<MoveModulesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type MoveModulesAppendInput = {
  exposed_functions?: InputMaybe<Scalars["jsonb"]["input"]>;
  friends?: InputMaybe<Scalars["jsonb"]["input"]>;
  structs?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** aggregate avg on columns */
export type MoveModulesAvgFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "move_modules". All fields are combined with a logical 'AND'. */
export type MoveModulesBoolExp = {
  _and?: InputMaybe<Array<MoveModulesBoolExp>>;
  _not?: InputMaybe<MoveModulesBoolExp>;
  _or?: InputMaybe<Array<MoveModulesBoolExp>>;
  address?: InputMaybe<StringComparisonExp>;
  bytecode?: InputMaybe<ByteaComparisonExp>;
  exposed_functions?: InputMaybe<JsonbComparisonExp>;
  friends?: InputMaybe<JsonbComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_deleted?: InputMaybe<BooleanComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  structs?: InputMaybe<JsonbComparisonExp>;
  transaction_block_height?: InputMaybe<BigintComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  write_set_change_index?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "move_modules" */
export enum MoveModulesConstraint {
  /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
  MoveModulesPkey = "move_modules_pkey",
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type MoveModulesDeleteAtPathInput = {
  exposed_functions?: InputMaybe<Array<Scalars["String"]["input"]>>;
  friends?: InputMaybe<Array<Scalars["String"]["input"]>>;
  structs?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type MoveModulesDeleteElemInput = {
  exposed_functions?: InputMaybe<Scalars["Int"]["input"]>;
  friends?: InputMaybe<Scalars["Int"]["input"]>;
  structs?: InputMaybe<Scalars["Int"]["input"]>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type MoveModulesDeleteKeyInput = {
  exposed_functions?: InputMaybe<Scalars["String"]["input"]>;
  friends?: InputMaybe<Scalars["String"]["input"]>;
  structs?: InputMaybe<Scalars["String"]["input"]>;
};

/** input type for incrementing numeric columns in table "move_modules" */
export type MoveModulesIncInput = {
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "move_modules" */
export type MoveModulesInsertInput = {
  address?: InputMaybe<Scalars["String"]["input"]>;
  bytecode?: InputMaybe<Scalars["bytea"]["input"]>;
  exposed_functions?: InputMaybe<Scalars["jsonb"]["input"]>;
  friends?: InputMaybe<Scalars["jsonb"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  structs?: InputMaybe<Scalars["jsonb"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type MoveModulesMaxFields = {
  address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type MoveModulesMinFields = {
  address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "move_modules" */
export type MoveModulesMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<MoveModules>;
};

/** on_conflict condition type for table "move_modules" */
export type MoveModulesOnConflict = {
  constraint: MoveModulesConstraint;
  update_columns?: Array<MoveModulesUpdateColumn>;
  where?: InputMaybe<MoveModulesBoolExp>;
};

/** Ordering options when selecting data from "move_modules". */
export type MoveModulesOrderBy = {
  address?: InputMaybe<OrderBy>;
  bytecode?: InputMaybe<OrderBy>;
  exposed_functions?: InputMaybe<OrderBy>;
  friends?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_deleted?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  structs?: InputMaybe<OrderBy>;
  transaction_block_height?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  write_set_change_index?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: move_modules */
export type MoveModulesPkColumnsInput = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type MoveModulesPrependInput = {
  exposed_functions?: InputMaybe<Scalars["jsonb"]["input"]>;
  friends?: InputMaybe<Scalars["jsonb"]["input"]>;
  structs?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** select columns of table "move_modules" */
export enum MoveModulesSelectColumn {
  /** column name */
  Address = "address",
  /** column name */
  Bytecode = "bytecode",
  /** column name */
  ExposedFunctions = "exposed_functions",
  /** column name */
  Friends = "friends",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  Name = "name",
  /** column name */
  Structs = "structs",
  /** column name */
  TransactionBlockHeight = "transaction_block_height",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

/** input type for updating data in table "move_modules" */
export type MoveModulesSetInput = {
  address?: InputMaybe<Scalars["String"]["input"]>;
  bytecode?: InputMaybe<Scalars["bytea"]["input"]>;
  exposed_functions?: InputMaybe<Scalars["jsonb"]["input"]>;
  friends?: InputMaybe<Scalars["jsonb"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  structs?: InputMaybe<Scalars["jsonb"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type MoveModulesStddevFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type MoveModulesStddevPopFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type MoveModulesStddevSampFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "move_modules" */
export type MoveModulesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: MoveModulesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type MoveModulesStreamCursorValueInput = {
  address?: InputMaybe<Scalars["String"]["input"]>;
  bytecode?: InputMaybe<Scalars["bytea"]["input"]>;
  exposed_functions?: InputMaybe<Scalars["jsonb"]["input"]>;
  friends?: InputMaybe<Scalars["jsonb"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  structs?: InputMaybe<Scalars["jsonb"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type MoveModulesSumFields = {
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "move_modules" */
export enum MoveModulesUpdateColumn {
  /** column name */
  Address = "address",
  /** column name */
  Bytecode = "bytecode",
  /** column name */
  ExposedFunctions = "exposed_functions",
  /** column name */
  Friends = "friends",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  Name = "name",
  /** column name */
  Structs = "structs",
  /** column name */
  TransactionBlockHeight = "transaction_block_height",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

export type MoveModulesUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<MoveModulesAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<MoveModulesDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<MoveModulesDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<MoveModulesDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<MoveModulesIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<MoveModulesPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<MoveModulesSetInput>;
  /** filter the rows which have to be updated */
  where: MoveModulesBoolExp;
};

/** aggregate var_pop on columns */
export type MoveModulesVarPopFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type MoveModulesVarSampFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type MoveModulesVarianceFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "move_resources" */
export type MoveResources = {
  address: Scalars["String"]["output"];
  data?: Maybe<Scalars["jsonb"]["output"]>;
  generic_type_params?: Maybe<Scalars["jsonb"]["output"]>;
  inserted_at: Scalars["timestamp"]["output"];
  is_deleted: Scalars["Boolean"]["output"];
  module: Scalars["String"]["output"];
  name: Scalars["String"]["output"];
  state_key_hash: Scalars["String"]["output"];
  transaction_block_height: Scalars["bigint"]["output"];
  transaction_version: Scalars["bigint"]["output"];
  type: Scalars["String"]["output"];
  write_set_change_index: Scalars["bigint"]["output"];
};

/** columns and relationships of "move_resources" */
export type MoveResourcesDataArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** columns and relationships of "move_resources" */
export type MoveResourcesGenericTypeParamsArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregated selection of "move_resources" */
export type MoveResourcesAggregate = {
  aggregate?: Maybe<MoveResourcesAggregateFields>;
  nodes: Array<MoveResources>;
};

/** aggregate fields of "move_resources" */
export type MoveResourcesAggregateFields = {
  avg?: Maybe<MoveResourcesAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<MoveResourcesMaxFields>;
  min?: Maybe<MoveResourcesMinFields>;
  stddev?: Maybe<MoveResourcesStddevFields>;
  stddev_pop?: Maybe<MoveResourcesStddevPopFields>;
  stddev_samp?: Maybe<MoveResourcesStddevSampFields>;
  sum?: Maybe<MoveResourcesSumFields>;
  var_pop?: Maybe<MoveResourcesVarPopFields>;
  var_samp?: Maybe<MoveResourcesVarSampFields>;
  variance?: Maybe<MoveResourcesVarianceFields>;
};

/** aggregate fields of "move_resources" */
export type MoveResourcesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<MoveResourcesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type MoveResourcesAppendInput = {
  data?: InputMaybe<Scalars["jsonb"]["input"]>;
  generic_type_params?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** aggregate avg on columns */
export type MoveResourcesAvgFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "move_resources". All fields are combined with a logical 'AND'. */
export type MoveResourcesBoolExp = {
  _and?: InputMaybe<Array<MoveResourcesBoolExp>>;
  _not?: InputMaybe<MoveResourcesBoolExp>;
  _or?: InputMaybe<Array<MoveResourcesBoolExp>>;
  address?: InputMaybe<StringComparisonExp>;
  data?: InputMaybe<JsonbComparisonExp>;
  generic_type_params?: InputMaybe<JsonbComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_deleted?: InputMaybe<BooleanComparisonExp>;
  module?: InputMaybe<StringComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  state_key_hash?: InputMaybe<StringComparisonExp>;
  transaction_block_height?: InputMaybe<BigintComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  type?: InputMaybe<StringComparisonExp>;
  write_set_change_index?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "move_resources" */
export enum MoveResourcesConstraint {
  /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
  MoveResourcesPkey = "move_resources_pkey",
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type MoveResourcesDeleteAtPathInput = {
  data?: InputMaybe<Array<Scalars["String"]["input"]>>;
  generic_type_params?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type MoveResourcesDeleteElemInput = {
  data?: InputMaybe<Scalars["Int"]["input"]>;
  generic_type_params?: InputMaybe<Scalars["Int"]["input"]>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type MoveResourcesDeleteKeyInput = {
  data?: InputMaybe<Scalars["String"]["input"]>;
  generic_type_params?: InputMaybe<Scalars["String"]["input"]>;
};

/** input type for incrementing numeric columns in table "move_resources" */
export type MoveResourcesIncInput = {
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "move_resources" */
export type MoveResourcesInsertInput = {
  address?: InputMaybe<Scalars["String"]["input"]>;
  data?: InputMaybe<Scalars["jsonb"]["input"]>;
  generic_type_params?: InputMaybe<Scalars["jsonb"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  module?: InputMaybe<Scalars["String"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type MoveResourcesMaxFields = {
  address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  module?: Maybe<Scalars["String"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  state_key_hash?: Maybe<Scalars["String"]["output"]>;
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  type?: Maybe<Scalars["String"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type MoveResourcesMinFields = {
  address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  module?: Maybe<Scalars["String"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  state_key_hash?: Maybe<Scalars["String"]["output"]>;
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  type?: Maybe<Scalars["String"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "move_resources" */
export type MoveResourcesMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<MoveResources>;
};

/** on_conflict condition type for table "move_resources" */
export type MoveResourcesOnConflict = {
  constraint: MoveResourcesConstraint;
  update_columns?: Array<MoveResourcesUpdateColumn>;
  where?: InputMaybe<MoveResourcesBoolExp>;
};

/** Ordering options when selecting data from "move_resources". */
export type MoveResourcesOrderBy = {
  address?: InputMaybe<OrderBy>;
  data?: InputMaybe<OrderBy>;
  generic_type_params?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_deleted?: InputMaybe<OrderBy>;
  module?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  state_key_hash?: InputMaybe<OrderBy>;
  transaction_block_height?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  write_set_change_index?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: move_resources */
export type MoveResourcesPkColumnsInput = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type MoveResourcesPrependInput = {
  data?: InputMaybe<Scalars["jsonb"]["input"]>;
  generic_type_params?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** select columns of table "move_resources" */
export enum MoveResourcesSelectColumn {
  /** column name */
  Address = "address",
  /** column name */
  Data = "data",
  /** column name */
  GenericTypeParams = "generic_type_params",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  Module = "module",
  /** column name */
  Name = "name",
  /** column name */
  StateKeyHash = "state_key_hash",
  /** column name */
  TransactionBlockHeight = "transaction_block_height",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  Type = "type",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

/** input type for updating data in table "move_resources" */
export type MoveResourcesSetInput = {
  address?: InputMaybe<Scalars["String"]["input"]>;
  data?: InputMaybe<Scalars["jsonb"]["input"]>;
  generic_type_params?: InputMaybe<Scalars["jsonb"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  module?: InputMaybe<Scalars["String"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type MoveResourcesStddevFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type MoveResourcesStddevPopFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type MoveResourcesStddevSampFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "move_resources" */
export type MoveResourcesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: MoveResourcesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type MoveResourcesStreamCursorValueInput = {
  address?: InputMaybe<Scalars["String"]["input"]>;
  data?: InputMaybe<Scalars["jsonb"]["input"]>;
  generic_type_params?: InputMaybe<Scalars["jsonb"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  module?: InputMaybe<Scalars["String"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type MoveResourcesSumFields = {
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "move_resources" */
export enum MoveResourcesUpdateColumn {
  /** column name */
  Address = "address",
  /** column name */
  Data = "data",
  /** column name */
  GenericTypeParams = "generic_type_params",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  Module = "module",
  /** column name */
  Name = "name",
  /** column name */
  StateKeyHash = "state_key_hash",
  /** column name */
  TransactionBlockHeight = "transaction_block_height",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  Type = "type",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

export type MoveResourcesUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<MoveResourcesAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<MoveResourcesDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<MoveResourcesDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<MoveResourcesDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<MoveResourcesIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<MoveResourcesPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<MoveResourcesSetInput>;
  /** filter the rows which have to be updated */
  where: MoveResourcesBoolExp;
};

/** aggregate var_pop on columns */
export type MoveResourcesVarPopFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type MoveResourcesVarSampFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type MoveResourcesVarianceFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "move_resources_view" */
export type MoveResourcesView = {
  address?: Maybe<Scalars["String"]["output"]>;
  generic_type_params?: Maybe<Scalars["jsonb"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  is_deleted?: Maybe<Scalars["Boolean"]["output"]>;
  json_data?: Maybe<Scalars["String"]["output"]>;
  module?: Maybe<Scalars["String"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  type?: Maybe<Scalars["String"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** columns and relationships of "move_resources_view" */
export type MoveResourcesViewGenericTypeParamsArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregated selection of "move_resources_view" */
export type MoveResourcesViewAggregate = {
  aggregate?: Maybe<MoveResourcesViewAggregateFields>;
  nodes: Array<MoveResourcesView>;
};

/** aggregate fields of "move_resources_view" */
export type MoveResourcesViewAggregateFields = {
  avg?: Maybe<MoveResourcesViewAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<MoveResourcesViewMaxFields>;
  min?: Maybe<MoveResourcesViewMinFields>;
  stddev?: Maybe<MoveResourcesViewStddevFields>;
  stddev_pop?: Maybe<MoveResourcesViewStddevPopFields>;
  stddev_samp?: Maybe<MoveResourcesViewStddevSampFields>;
  sum?: Maybe<MoveResourcesViewSumFields>;
  var_pop?: Maybe<MoveResourcesViewVarPopFields>;
  var_samp?: Maybe<MoveResourcesViewVarSampFields>;
  variance?: Maybe<MoveResourcesViewVarianceFields>;
};

/** aggregate fields of "move_resources_view" */
export type MoveResourcesViewAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<MoveResourcesViewSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type MoveResourcesViewAppendInput = {
  generic_type_params?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** aggregate avg on columns */
export type MoveResourcesViewAvgFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "move_resources_view". All fields are combined with a logical 'AND'. */
export type MoveResourcesViewBoolExp = {
  _and?: InputMaybe<Array<MoveResourcesViewBoolExp>>;
  _not?: InputMaybe<MoveResourcesViewBoolExp>;
  _or?: InputMaybe<Array<MoveResourcesViewBoolExp>>;
  address?: InputMaybe<StringComparisonExp>;
  generic_type_params?: InputMaybe<JsonbComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_deleted?: InputMaybe<BooleanComparisonExp>;
  json_data?: InputMaybe<StringComparisonExp>;
  module?: InputMaybe<StringComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  transaction_block_height?: InputMaybe<BigintComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  type?: InputMaybe<StringComparisonExp>;
  write_set_change_index?: InputMaybe<BigintComparisonExp>;
};

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type MoveResourcesViewDeleteAtPathInput = {
  generic_type_params?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type MoveResourcesViewDeleteElemInput = {
  generic_type_params?: InputMaybe<Scalars["Int"]["input"]>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type MoveResourcesViewDeleteKeyInput = {
  generic_type_params?: InputMaybe<Scalars["String"]["input"]>;
};

/** input type for incrementing numeric columns in table "move_resources_view" */
export type MoveResourcesViewIncInput = {
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "move_resources_view" */
export type MoveResourcesViewInsertInput = {
  address?: InputMaybe<Scalars["String"]["input"]>;
  generic_type_params?: InputMaybe<Scalars["jsonb"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  json_data?: InputMaybe<Scalars["String"]["input"]>;
  module?: InputMaybe<Scalars["String"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type MoveResourcesViewMaxFields = {
  address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  json_data?: Maybe<Scalars["String"]["output"]>;
  module?: Maybe<Scalars["String"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  type?: Maybe<Scalars["String"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type MoveResourcesViewMinFields = {
  address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  json_data?: Maybe<Scalars["String"]["output"]>;
  module?: Maybe<Scalars["String"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  type?: Maybe<Scalars["String"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "move_resources_view" */
export type MoveResourcesViewMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<MoveResourcesView>;
};

/** Ordering options when selecting data from "move_resources_view". */
export type MoveResourcesViewOrderBy = {
  address?: InputMaybe<OrderBy>;
  generic_type_params?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_deleted?: InputMaybe<OrderBy>;
  json_data?: InputMaybe<OrderBy>;
  module?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  transaction_block_height?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  write_set_change_index?: InputMaybe<OrderBy>;
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type MoveResourcesViewPrependInput = {
  generic_type_params?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** select columns of table "move_resources_view" */
export enum MoveResourcesViewSelectColumn {
  /** column name */
  Address = "address",
  /** column name */
  GenericTypeParams = "generic_type_params",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  JsonData = "json_data",
  /** column name */
  Module = "module",
  /** column name */
  Name = "name",
  /** column name */
  TransactionBlockHeight = "transaction_block_height",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  Type = "type",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

/** input type for updating data in table "move_resources_view" */
export type MoveResourcesViewSetInput = {
  address?: InputMaybe<Scalars["String"]["input"]>;
  generic_type_params?: InputMaybe<Scalars["jsonb"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  json_data?: InputMaybe<Scalars["String"]["input"]>;
  module?: InputMaybe<Scalars["String"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type MoveResourcesViewStddevFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type MoveResourcesViewStddevPopFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type MoveResourcesViewStddevSampFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "move_resources_view" */
export type MoveResourcesViewStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: MoveResourcesViewStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type MoveResourcesViewStreamCursorValueInput = {
  address?: InputMaybe<Scalars["String"]["input"]>;
  generic_type_params?: InputMaybe<Scalars["jsonb"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  json_data?: InputMaybe<Scalars["String"]["input"]>;
  module?: InputMaybe<Scalars["String"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type MoveResourcesViewSumFields = {
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

export type MoveResourcesViewUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<MoveResourcesViewAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<MoveResourcesViewDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<MoveResourcesViewDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<MoveResourcesViewDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<MoveResourcesViewIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<MoveResourcesViewPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<MoveResourcesViewSetInput>;
  /** filter the rows which have to be updated */
  where: MoveResourcesViewBoolExp;
};

/** aggregate var_pop on columns */
export type MoveResourcesViewVarPopFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type MoveResourcesViewVarSampFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type MoveResourcesViewVarianceFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** mutation root */
export type MutationRoot = {
  /** delete data from the table: "account_transactions" */
  delete_account_transactions?: Maybe<AccountTransactionsMutationResponse>;
  /** delete single row from the table: "account_transactions" */
  delete_account_transactions_by_pk?: Maybe<AccountTransactions>;
  /** delete data from the table: "ans_lookup" */
  delete_ans_lookup?: Maybe<AnsLookupMutationResponse>;
  /** delete single row from the table: "ans_lookup" */
  delete_ans_lookup_by_pk?: Maybe<AnsLookup>;
  /** delete data from the table: "ans_lookup_v2" */
  delete_ans_lookup_v2?: Maybe<AnsLookupV2MutationResponse>;
  /** delete single row from the table: "ans_lookup_v2" */
  delete_ans_lookup_v2_by_pk?: Maybe<AnsLookupV2>;
  /** delete data from the table: "ans_primary_name" */
  delete_ans_primary_name?: Maybe<AnsPrimaryNameMutationResponse>;
  /** delete single row from the table: "ans_primary_name" */
  delete_ans_primary_name_by_pk?: Maybe<AnsPrimaryName>;
  /** delete data from the table: "ans_primary_name_v2" */
  delete_ans_primary_name_v2?: Maybe<AnsPrimaryNameV2MutationResponse>;
  /** delete single row from the table: "ans_primary_name_v2" */
  delete_ans_primary_name_v2_by_pk?: Maybe<AnsPrimaryNameV2>;
  /** delete data from the table: "auth_key_account_addresses" */
  delete_auth_key_account_addresses?: Maybe<AuthKeyAccountAddressesMutationResponse>;
  /** delete single row from the table: "auth_key_account_addresses" */
  delete_auth_key_account_addresses_by_pk?: Maybe<AuthKeyAccountAddresses>;
  /** delete data from the table: "block_metadata_transactions" */
  delete_block_metadata_transactions?: Maybe<BlockMetadataTransactionsMutationResponse>;
  /** delete single row from the table: "block_metadata_transactions" */
  delete_block_metadata_transactions_by_pk?: Maybe<BlockMetadataTransactions>;
  /** delete data from the table: "coin_activities" */
  delete_coin_activities?: Maybe<CoinActivitiesMutationResponse>;
  /** delete single row from the table: "coin_activities" */
  delete_coin_activities_by_pk?: Maybe<CoinActivities>;
  /** delete data from the table: "coin_balances" */
  delete_coin_balances?: Maybe<CoinBalancesMutationResponse>;
  /** delete single row from the table: "coin_balances" */
  delete_coin_balances_by_pk?: Maybe<CoinBalances>;
  /** delete data from the table: "coin_infos" */
  delete_coin_infos?: Maybe<CoinInfosMutationResponse>;
  /** delete single row from the table: "coin_infos" */
  delete_coin_infos_by_pk?: Maybe<CoinInfos>;
  /** delete data from the table: "coin_supply" */
  delete_coin_supply?: Maybe<CoinSupplyMutationResponse>;
  /** delete single row from the table: "coin_supply" */
  delete_coin_supply_by_pk?: Maybe<CoinSupply>;
  /** delete data from the table: "collection_datas" */
  delete_collection_datas?: Maybe<CollectionDatasMutationResponse>;
  /** delete single row from the table: "collection_datas" */
  delete_collection_datas_by_pk?: Maybe<CollectionDatas>;
  /** delete data from the table: "collections_v2" */
  delete_collections_v2?: Maybe<CollectionsV2MutationResponse>;
  /** delete single row from the table: "collections_v2" */
  delete_collections_v2_by_pk?: Maybe<CollectionsV2>;
  /** delete data from the table: "current_ans_lookup" */
  delete_current_ans_lookup?: Maybe<CurrentAnsLookupMutationResponse>;
  /** delete single row from the table: "current_ans_lookup" */
  delete_current_ans_lookup_by_pk?: Maybe<CurrentAnsLookup>;
  /** delete data from the table: "current_ans_lookup_v2" */
  delete_current_ans_lookup_v2?: Maybe<CurrentAnsLookupV2MutationResponse>;
  /** delete single row from the table: "current_ans_lookup_v2" */
  delete_current_ans_lookup_v2_by_pk?: Maybe<CurrentAnsLookupV2>;
  /** delete data from the table: "current_ans_primary_name" */
  delete_current_ans_primary_name?: Maybe<CurrentAnsPrimaryNameMutationResponse>;
  /** delete single row from the table: "current_ans_primary_name" */
  delete_current_ans_primary_name_by_pk?: Maybe<CurrentAnsPrimaryName>;
  /** delete data from the table: "current_ans_primary_name_v2" */
  delete_current_ans_primary_name_v2?: Maybe<CurrentAnsPrimaryNameV2MutationResponse>;
  /** delete single row from the table: "current_ans_primary_name_v2" */
  delete_current_ans_primary_name_v2_by_pk?: Maybe<CurrentAnsPrimaryNameV2>;
  /** delete data from the table: "current_coin_balances" */
  delete_current_coin_balances?: Maybe<CurrentCoinBalancesMutationResponse>;
  /** delete single row from the table: "current_coin_balances" */
  delete_current_coin_balances_by_pk?: Maybe<CurrentCoinBalances>;
  /** delete data from the table: "current_collection_datas" */
  delete_current_collection_datas?: Maybe<CurrentCollectionDatasMutationResponse>;
  /** delete single row from the table: "current_collection_datas" */
  delete_current_collection_datas_by_pk?: Maybe<CurrentCollectionDatas>;
  /** delete data from the table: "current_collections_v2" */
  delete_current_collections_v2?: Maybe<CurrentCollectionsV2MutationResponse>;
  /** delete single row from the table: "current_collections_v2" */
  delete_current_collections_v2_by_pk?: Maybe<CurrentCollectionsV2>;
  /** delete data from the table: "current_delegated_staking_pool_balances" */
  delete_current_delegated_staking_pool_balances?: Maybe<CurrentDelegatedStakingPoolBalancesMutationResponse>;
  /** delete single row from the table: "current_delegated_staking_pool_balances" */
  delete_current_delegated_staking_pool_balances_by_pk?: Maybe<CurrentDelegatedStakingPoolBalances>;
  /** delete data from the table: "current_delegated_voter" */
  delete_current_delegated_voter?: Maybe<CurrentDelegatedVoterMutationResponse>;
  /** delete single row from the table: "current_delegated_voter" */
  delete_current_delegated_voter_by_pk?: Maybe<CurrentDelegatedVoter>;
  /** delete data from the table: "current_delegator_balances" */
  delete_current_delegator_balances?: Maybe<CurrentDelegatorBalancesMutationResponse>;
  /** delete single row from the table: "current_delegator_balances" */
  delete_current_delegator_balances_by_pk?: Maybe<CurrentDelegatorBalances>;
  /** delete data from the table: "current_fungible_asset_balances_legacy" */
  delete_current_fungible_asset_balances?: Maybe<CurrentFungibleAssetBalancesMutationResponse>;
  /** delete single row from the table: "current_fungible_asset_balances_legacy" */
  delete_current_fungible_asset_balances_by_pk?: Maybe<CurrentFungibleAssetBalances>;
  /** delete data from the table: "current_fungible_asset_balances" */
  delete_current_fungible_asset_balances_new?: Maybe<CurrentFungibleAssetBalancesNewMutationResponse>;
  /** delete single row from the table: "current_fungible_asset_balances" */
  delete_current_fungible_asset_balances_new_by_pk?: Maybe<CurrentFungibleAssetBalancesNew>;
  /** delete data from the table: "current_objects" */
  delete_current_objects?: Maybe<CurrentObjectsMutationResponse>;
  /** delete single row from the table: "current_objects" */
  delete_current_objects_by_pk?: Maybe<CurrentObjects>;
  /** delete data from the table: "current_staking_pool_voter" */
  delete_current_staking_pool_voter?: Maybe<CurrentStakingPoolVoterMutationResponse>;
  /** delete single row from the table: "current_staking_pool_voter" */
  delete_current_staking_pool_voter_by_pk?: Maybe<CurrentStakingPoolVoter>;
  /** delete data from the table: "current_table_items" */
  delete_current_table_items?: Maybe<CurrentTableItemsMutationResponse>;
  /** delete single row from the table: "current_table_items" */
  delete_current_table_items_by_pk?: Maybe<CurrentTableItems>;
  /** delete data from the table: "current_table_items_view" */
  delete_current_table_items_view?: Maybe<CurrentTableItemsViewMutationResponse>;
  /** delete data from the table: "current_token_datas" */
  delete_current_token_datas?: Maybe<CurrentTokenDatasMutationResponse>;
  /** delete single row from the table: "current_token_datas" */
  delete_current_token_datas_by_pk?: Maybe<CurrentTokenDatas>;
  /** delete data from the table: "current_token_datas_v2" */
  delete_current_token_datas_v2?: Maybe<CurrentTokenDatasV2MutationResponse>;
  /** delete single row from the table: "current_token_datas_v2" */
  delete_current_token_datas_v2_by_pk?: Maybe<CurrentTokenDatasV2>;
  /** delete data from the table: "current_token_ownerships" */
  delete_current_token_ownerships?: Maybe<CurrentTokenOwnershipsMutationResponse>;
  /** delete single row from the table: "current_token_ownerships" */
  delete_current_token_ownerships_by_pk?: Maybe<CurrentTokenOwnerships>;
  /** delete data from the table: "current_token_ownerships_v2" */
  delete_current_token_ownerships_v2?: Maybe<CurrentTokenOwnershipsV2MutationResponse>;
  /** delete single row from the table: "current_token_ownerships_v2" */
  delete_current_token_ownerships_v2_by_pk?: Maybe<CurrentTokenOwnershipsV2>;
  /** delete data from the table: "current_token_pending_claims" */
  delete_current_token_pending_claims?: Maybe<CurrentTokenPendingClaimsMutationResponse>;
  /** delete single row from the table: "current_token_pending_claims" */
  delete_current_token_pending_claims_by_pk?: Maybe<CurrentTokenPendingClaims>;
  /** delete data from the table: "current_token_royalty_v1" */
  delete_current_token_royalty_v1?: Maybe<CurrentTokenRoyaltyV1MutationResponse>;
  /** delete single row from the table: "current_token_royalty_v1" */
  delete_current_token_royalty_v1_by_pk?: Maybe<CurrentTokenRoyaltyV1>;
  /** delete data from the table: "current_token_v2_metadata" */
  delete_current_token_v2_metadata?: Maybe<CurrentTokenV2MetadataMutationResponse>;
  /** delete single row from the table: "current_token_v2_metadata" */
  delete_current_token_v2_metadata_by_pk?: Maybe<CurrentTokenV2Metadata>;
  /** delete data from the table: "delegated_staking_activities" */
  delete_delegated_staking_activities?: Maybe<DelegatedStakingActivitiesMutationResponse>;
  /** delete single row from the table: "delegated_staking_activities" */
  delete_delegated_staking_activities_by_pk?: Maybe<DelegatedStakingActivities>;
  /** delete data from the table: "delegated_staking_pool_balances" */
  delete_delegated_staking_pool_balances?: Maybe<DelegatedStakingPoolBalancesMutationResponse>;
  /** delete single row from the table: "delegated_staking_pool_balances" */
  delete_delegated_staking_pool_balances_by_pk?: Maybe<DelegatedStakingPoolBalances>;
  /** delete data from the table: "delegated_staking_pools" */
  delete_delegated_staking_pools?: Maybe<DelegatedStakingPoolsMutationResponse>;
  /** delete single row from the table: "delegated_staking_pools" */
  delete_delegated_staking_pools_by_pk?: Maybe<DelegatedStakingPools>;
  /** delete data from the table: "delegator_balances" */
  delete_delegator_balances?: Maybe<DelegatorBalancesMutationResponse>;
  /** delete single row from the table: "delegator_balances" */
  delete_delegator_balances_by_pk?: Maybe<DelegatorBalances>;
  /** delete data from the table: "event_size_info" */
  delete_event_size_info?: Maybe<EventSizeInfoMutationResponse>;
  /** delete single row from the table: "event_size_info" */
  delete_event_size_info_by_pk?: Maybe<EventSizeInfo>;
  /** delete data from the table: "events" */
  delete_events?: Maybe<EventsMutationResponse>;
  /** delete single row from the table: "events" */
  delete_events_by_pk?: Maybe<Events>;
  /** delete data from the table: "events_view" */
  delete_events_view?: Maybe<EventsViewMutationResponse>;
  /** delete data from the table: "fungible_asset_activities" */
  delete_fungible_asset_activities?: Maybe<FungibleAssetActivitiesMutationResponse>;
  /** delete single row from the table: "fungible_asset_activities" */
  delete_fungible_asset_activities_by_pk?: Maybe<FungibleAssetActivities>;
  /** delete data from the table: "fungible_asset_balances" */
  delete_fungible_asset_balances?: Maybe<FungibleAssetBalancesMutationResponse>;
  /** delete single row from the table: "fungible_asset_balances" */
  delete_fungible_asset_balances_by_pk?: Maybe<FungibleAssetBalances>;
  /** delete data from the table: "fungible_asset_metadata" */
  delete_fungible_asset_metadata?: Maybe<FungibleAssetMetadataMutationResponse>;
  /** delete single row from the table: "fungible_asset_metadata" */
  delete_fungible_asset_metadata_by_pk?: Maybe<FungibleAssetMetadata>;
  /** delete data from the table: "fungible_asset_to_coin_mappings" */
  delete_fungible_asset_to_coin_mappings?: Maybe<FungibleAssetToCoinMappingsMutationResponse>;
  /** delete single row from the table: "fungible_asset_to_coin_mappings" */
  delete_fungible_asset_to_coin_mappings_by_pk?: Maybe<FungibleAssetToCoinMappings>;
  /** delete data from the table: "gas_fees" */
  delete_gas_fees?: Maybe<GasFeesMutationResponse>;
  /** delete single row from the table: "gas_fees" */
  delete_gas_fees_by_pk?: Maybe<GasFees>;
  /** delete data from the table: "indexer_status" */
  delete_indexer_status?: Maybe<IndexerStatusMutationResponse>;
  /** delete single row from the table: "indexer_status" */
  delete_indexer_status_by_pk?: Maybe<IndexerStatus>;
  /** delete data from the table: "move_modules" */
  delete_move_modules?: Maybe<MoveModulesMutationResponse>;
  /** delete single row from the table: "move_modules" */
  delete_move_modules_by_pk?: Maybe<MoveModules>;
  /** delete data from the table: "move_resources" */
  delete_move_resources?: Maybe<MoveResourcesMutationResponse>;
  /** delete single row from the table: "move_resources" */
  delete_move_resources_by_pk?: Maybe<MoveResources>;
  /** delete data from the table: "move_resources_view" */
  delete_move_resources_view?: Maybe<MoveResourcesViewMutationResponse>;
  /** delete data from the table: "nft_metadata_crawler.parsed_asset_uris" */
  delete_nft_metadata_crawler_parsed_asset_uris?: Maybe<NftMetadataCrawlerParsedAssetUrisMutationResponse>;
  /** delete single row from the table: "nft_metadata_crawler.parsed_asset_uris" */
  delete_nft_metadata_crawler_parsed_asset_uris_by_pk?: Maybe<NftMetadataCrawlerParsedAssetUris>;
  /** delete data from the table: "nft_points" */
  delete_nft_points?: Maybe<NftPointsMutationResponse>;
  /** delete single row from the table: "nft_points" */
  delete_nft_points_by_pk?: Maybe<NftPoints>;
  /** delete data from the table: "objects" */
  delete_objects?: Maybe<ObjectsMutationResponse>;
  /** delete single row from the table: "objects" */
  delete_objects_by_pk?: Maybe<Objects>;
  /** delete data from the table: "processor_metadata.processor_status" */
  delete_processor_metadata_processor_status?: Maybe<ProcessorMetadataProcessorStatusMutationResponse>;
  /** delete single row from the table: "processor_metadata.processor_status" */
  delete_processor_metadata_processor_status_by_pk?: Maybe<ProcessorMetadataProcessorStatus>;
  /** delete data from the table: "processor_status" */
  delete_processor_status?: Maybe<ProcessorStatusMutationResponse>;
  /** delete single row from the table: "processor_status" */
  delete_processor_status_by_pk?: Maybe<ProcessorStatus>;
  /** delete data from the table: "proposal_votes" */
  delete_proposal_votes?: Maybe<ProposalVotesMutationResponse>;
  /** delete single row from the table: "proposal_votes" */
  delete_proposal_votes_by_pk?: Maybe<ProposalVotes>;
  /** delete data from the table: "public_key_auth_keys" */
  delete_public_key_auth_keys?: Maybe<PublicKeyAuthKeysMutationResponse>;
  /** delete single row from the table: "public_key_auth_keys" */
  delete_public_key_auth_keys_by_pk?: Maybe<PublicKeyAuthKeys>;
  /** delete data from the table: "signatures" */
  delete_signatures?: Maybe<SignaturesMutationResponse>;
  /** delete single row from the table: "signatures" */
  delete_signatures_by_pk?: Maybe<Signatures>;
  /** delete data from the table: "spam_assets" */
  delete_spam_assets?: Maybe<SpamAssetsMutationResponse>;
  /** delete single row from the table: "spam_assets" */
  delete_spam_assets_by_pk?: Maybe<SpamAssets>;
  /** delete data from the table: "table_items" */
  delete_table_items?: Maybe<TableItemsMutationResponse>;
  /** delete single row from the table: "table_items" */
  delete_table_items_by_pk?: Maybe<TableItems>;
  /** delete data from the table: "table_items_view" */
  delete_table_items_view?: Maybe<TableItemsViewMutationResponse>;
  /** delete data from the table: "table_metadatas" */
  delete_table_metadatas?: Maybe<TableMetadatasMutationResponse>;
  /** delete single row from the table: "table_metadatas" */
  delete_table_metadatas_by_pk?: Maybe<TableMetadatas>;
  /** delete data from the table: "token_activities" */
  delete_token_activities?: Maybe<TokenActivitiesMutationResponse>;
  /** delete single row from the table: "token_activities" */
  delete_token_activities_by_pk?: Maybe<TokenActivities>;
  /** delete data from the table: "token_activities_v2" */
  delete_token_activities_v2?: Maybe<TokenActivitiesV2MutationResponse>;
  /** delete single row from the table: "token_activities_v2" */
  delete_token_activities_v2_by_pk?: Maybe<TokenActivitiesV2>;
  /** delete data from the table: "token_datas" */
  delete_token_datas?: Maybe<TokenDatasMutationResponse>;
  /** delete single row from the table: "token_datas" */
  delete_token_datas_by_pk?: Maybe<TokenDatas>;
  /** delete data from the table: "token_datas_v2" */
  delete_token_datas_v2?: Maybe<TokenDatasV2MutationResponse>;
  /** delete single row from the table: "token_datas_v2" */
  delete_token_datas_v2_by_pk?: Maybe<TokenDatasV2>;
  /** delete data from the table: "token_ownerships" */
  delete_token_ownerships?: Maybe<TokenOwnershipsMutationResponse>;
  /** delete single row from the table: "token_ownerships" */
  delete_token_ownerships_by_pk?: Maybe<TokenOwnerships>;
  /** delete data from the table: "token_ownerships_v2" */
  delete_token_ownerships_v2?: Maybe<TokenOwnershipsV2MutationResponse>;
  /** delete single row from the table: "token_ownerships_v2" */
  delete_token_ownerships_v2_by_pk?: Maybe<TokenOwnershipsV2>;
  /** delete data from the table: "tokens" */
  delete_tokens?: Maybe<TokensMutationResponse>;
  /** delete single row from the table: "tokens" */
  delete_tokens_by_pk?: Maybe<Tokens>;
  /** delete data from the table: "transaction_size_info" */
  delete_transaction_size_info?: Maybe<TransactionSizeInfoMutationResponse>;
  /** delete single row from the table: "transaction_size_info" */
  delete_transaction_size_info_by_pk?: Maybe<TransactionSizeInfo>;
  /** delete data from the table: "transactions_view" */
  delete_transactions_view?: Maybe<TransactionsViewMutationResponse>;
  /** delete data from the table: "user_transactions" */
  delete_user_transactions?: Maybe<UserTransactionsMutationResponse>;
  /** delete single row from the table: "user_transactions" */
  delete_user_transactions_by_pk?: Maybe<UserTransactions>;
  /** insert data into the table: "account_transactions" */
  insert_account_transactions?: Maybe<AccountTransactionsMutationResponse>;
  /** insert a single row into the table: "account_transactions" */
  insert_account_transactions_one?: Maybe<AccountTransactions>;
  /** insert data into the table: "ans_lookup" */
  insert_ans_lookup?: Maybe<AnsLookupMutationResponse>;
  /** insert a single row into the table: "ans_lookup" */
  insert_ans_lookup_one?: Maybe<AnsLookup>;
  /** insert data into the table: "ans_lookup_v2" */
  insert_ans_lookup_v2?: Maybe<AnsLookupV2MutationResponse>;
  /** insert a single row into the table: "ans_lookup_v2" */
  insert_ans_lookup_v2_one?: Maybe<AnsLookupV2>;
  /** insert data into the table: "ans_primary_name" */
  insert_ans_primary_name?: Maybe<AnsPrimaryNameMutationResponse>;
  /** insert a single row into the table: "ans_primary_name" */
  insert_ans_primary_name_one?: Maybe<AnsPrimaryName>;
  /** insert data into the table: "ans_primary_name_v2" */
  insert_ans_primary_name_v2?: Maybe<AnsPrimaryNameV2MutationResponse>;
  /** insert a single row into the table: "ans_primary_name_v2" */
  insert_ans_primary_name_v2_one?: Maybe<AnsPrimaryNameV2>;
  /** insert data into the table: "auth_key_account_addresses" */
  insert_auth_key_account_addresses?: Maybe<AuthKeyAccountAddressesMutationResponse>;
  /** insert a single row into the table: "auth_key_account_addresses" */
  insert_auth_key_account_addresses_one?: Maybe<AuthKeyAccountAddresses>;
  /** insert data into the table: "block_metadata_transactions" */
  insert_block_metadata_transactions?: Maybe<BlockMetadataTransactionsMutationResponse>;
  /** insert a single row into the table: "block_metadata_transactions" */
  insert_block_metadata_transactions_one?: Maybe<BlockMetadataTransactions>;
  /** insert data into the table: "coin_activities" */
  insert_coin_activities?: Maybe<CoinActivitiesMutationResponse>;
  /** insert a single row into the table: "coin_activities" */
  insert_coin_activities_one?: Maybe<CoinActivities>;
  /** insert data into the table: "coin_balances" */
  insert_coin_balances?: Maybe<CoinBalancesMutationResponse>;
  /** insert a single row into the table: "coin_balances" */
  insert_coin_balances_one?: Maybe<CoinBalances>;
  /** insert data into the table: "coin_infos" */
  insert_coin_infos?: Maybe<CoinInfosMutationResponse>;
  /** insert a single row into the table: "coin_infos" */
  insert_coin_infos_one?: Maybe<CoinInfos>;
  /** insert data into the table: "coin_supply" */
  insert_coin_supply?: Maybe<CoinSupplyMutationResponse>;
  /** insert a single row into the table: "coin_supply" */
  insert_coin_supply_one?: Maybe<CoinSupply>;
  /** insert data into the table: "collection_datas" */
  insert_collection_datas?: Maybe<CollectionDatasMutationResponse>;
  /** insert a single row into the table: "collection_datas" */
  insert_collection_datas_one?: Maybe<CollectionDatas>;
  /** insert data into the table: "collections_v2" */
  insert_collections_v2?: Maybe<CollectionsV2MutationResponse>;
  /** insert a single row into the table: "collections_v2" */
  insert_collections_v2_one?: Maybe<CollectionsV2>;
  /** insert data into the table: "current_ans_lookup" */
  insert_current_ans_lookup?: Maybe<CurrentAnsLookupMutationResponse>;
  /** insert a single row into the table: "current_ans_lookup" */
  insert_current_ans_lookup_one?: Maybe<CurrentAnsLookup>;
  /** insert data into the table: "current_ans_lookup_v2" */
  insert_current_ans_lookup_v2?: Maybe<CurrentAnsLookupV2MutationResponse>;
  /** insert a single row into the table: "current_ans_lookup_v2" */
  insert_current_ans_lookup_v2_one?: Maybe<CurrentAnsLookupV2>;
  /** insert data into the table: "current_ans_primary_name" */
  insert_current_ans_primary_name?: Maybe<CurrentAnsPrimaryNameMutationResponse>;
  /** insert a single row into the table: "current_ans_primary_name" */
  insert_current_ans_primary_name_one?: Maybe<CurrentAnsPrimaryName>;
  /** insert data into the table: "current_ans_primary_name_v2" */
  insert_current_ans_primary_name_v2?: Maybe<CurrentAnsPrimaryNameV2MutationResponse>;
  /** insert a single row into the table: "current_ans_primary_name_v2" */
  insert_current_ans_primary_name_v2_one?: Maybe<CurrentAnsPrimaryNameV2>;
  /** insert data into the table: "current_coin_balances" */
  insert_current_coin_balances?: Maybe<CurrentCoinBalancesMutationResponse>;
  /** insert a single row into the table: "current_coin_balances" */
  insert_current_coin_balances_one?: Maybe<CurrentCoinBalances>;
  /** insert data into the table: "current_collection_datas" */
  insert_current_collection_datas?: Maybe<CurrentCollectionDatasMutationResponse>;
  /** insert a single row into the table: "current_collection_datas" */
  insert_current_collection_datas_one?: Maybe<CurrentCollectionDatas>;
  /** insert data into the table: "current_collections_v2" */
  insert_current_collections_v2?: Maybe<CurrentCollectionsV2MutationResponse>;
  /** insert a single row into the table: "current_collections_v2" */
  insert_current_collections_v2_one?: Maybe<CurrentCollectionsV2>;
  /** insert data into the table: "current_delegated_staking_pool_balances" */
  insert_current_delegated_staking_pool_balances?: Maybe<CurrentDelegatedStakingPoolBalancesMutationResponse>;
  /** insert a single row into the table: "current_delegated_staking_pool_balances" */
  insert_current_delegated_staking_pool_balances_one?: Maybe<CurrentDelegatedStakingPoolBalances>;
  /** insert data into the table: "current_delegated_voter" */
  insert_current_delegated_voter?: Maybe<CurrentDelegatedVoterMutationResponse>;
  /** insert a single row into the table: "current_delegated_voter" */
  insert_current_delegated_voter_one?: Maybe<CurrentDelegatedVoter>;
  /** insert data into the table: "current_delegator_balances" */
  insert_current_delegator_balances?: Maybe<CurrentDelegatorBalancesMutationResponse>;
  /** insert a single row into the table: "current_delegator_balances" */
  insert_current_delegator_balances_one?: Maybe<CurrentDelegatorBalances>;
  /** insert data into the table: "current_fungible_asset_balances_legacy" */
  insert_current_fungible_asset_balances?: Maybe<CurrentFungibleAssetBalancesMutationResponse>;
  /** insert data into the table: "current_fungible_asset_balances" */
  insert_current_fungible_asset_balances_new?: Maybe<CurrentFungibleAssetBalancesNewMutationResponse>;
  /** insert a single row into the table: "current_fungible_asset_balances" */
  insert_current_fungible_asset_balances_new_one?: Maybe<CurrentFungibleAssetBalancesNew>;
  /** insert a single row into the table: "current_fungible_asset_balances_legacy" */
  insert_current_fungible_asset_balances_one?: Maybe<CurrentFungibleAssetBalances>;
  /** insert data into the table: "current_objects" */
  insert_current_objects?: Maybe<CurrentObjectsMutationResponse>;
  /** insert a single row into the table: "current_objects" */
  insert_current_objects_one?: Maybe<CurrentObjects>;
  /** insert data into the table: "current_staking_pool_voter" */
  insert_current_staking_pool_voter?: Maybe<CurrentStakingPoolVoterMutationResponse>;
  /** insert a single row into the table: "current_staking_pool_voter" */
  insert_current_staking_pool_voter_one?: Maybe<CurrentStakingPoolVoter>;
  /** insert data into the table: "current_table_items" */
  insert_current_table_items?: Maybe<CurrentTableItemsMutationResponse>;
  /** insert a single row into the table: "current_table_items" */
  insert_current_table_items_one?: Maybe<CurrentTableItems>;
  /** insert data into the table: "current_table_items_view" */
  insert_current_table_items_view?: Maybe<CurrentTableItemsViewMutationResponse>;
  /** insert a single row into the table: "current_table_items_view" */
  insert_current_table_items_view_one?: Maybe<CurrentTableItemsView>;
  /** insert data into the table: "current_token_datas" */
  insert_current_token_datas?: Maybe<CurrentTokenDatasMutationResponse>;
  /** insert a single row into the table: "current_token_datas" */
  insert_current_token_datas_one?: Maybe<CurrentTokenDatas>;
  /** insert data into the table: "current_token_datas_v2" */
  insert_current_token_datas_v2?: Maybe<CurrentTokenDatasV2MutationResponse>;
  /** insert a single row into the table: "current_token_datas_v2" */
  insert_current_token_datas_v2_one?: Maybe<CurrentTokenDatasV2>;
  /** insert data into the table: "current_token_ownerships" */
  insert_current_token_ownerships?: Maybe<CurrentTokenOwnershipsMutationResponse>;
  /** insert a single row into the table: "current_token_ownerships" */
  insert_current_token_ownerships_one?: Maybe<CurrentTokenOwnerships>;
  /** insert data into the table: "current_token_ownerships_v2" */
  insert_current_token_ownerships_v2?: Maybe<CurrentTokenOwnershipsV2MutationResponse>;
  /** insert a single row into the table: "current_token_ownerships_v2" */
  insert_current_token_ownerships_v2_one?: Maybe<CurrentTokenOwnershipsV2>;
  /** insert data into the table: "current_token_pending_claims" */
  insert_current_token_pending_claims?: Maybe<CurrentTokenPendingClaimsMutationResponse>;
  /** insert a single row into the table: "current_token_pending_claims" */
  insert_current_token_pending_claims_one?: Maybe<CurrentTokenPendingClaims>;
  /** insert data into the table: "current_token_royalty_v1" */
  insert_current_token_royalty_v1?: Maybe<CurrentTokenRoyaltyV1MutationResponse>;
  /** insert a single row into the table: "current_token_royalty_v1" */
  insert_current_token_royalty_v1_one?: Maybe<CurrentTokenRoyaltyV1>;
  /** insert data into the table: "current_token_v2_metadata" */
  insert_current_token_v2_metadata?: Maybe<CurrentTokenV2MetadataMutationResponse>;
  /** insert a single row into the table: "current_token_v2_metadata" */
  insert_current_token_v2_metadata_one?: Maybe<CurrentTokenV2Metadata>;
  /** insert data into the table: "delegated_staking_activities" */
  insert_delegated_staking_activities?: Maybe<DelegatedStakingActivitiesMutationResponse>;
  /** insert a single row into the table: "delegated_staking_activities" */
  insert_delegated_staking_activities_one?: Maybe<DelegatedStakingActivities>;
  /** insert data into the table: "delegated_staking_pool_balances" */
  insert_delegated_staking_pool_balances?: Maybe<DelegatedStakingPoolBalancesMutationResponse>;
  /** insert a single row into the table: "delegated_staking_pool_balances" */
  insert_delegated_staking_pool_balances_one?: Maybe<DelegatedStakingPoolBalances>;
  /** insert data into the table: "delegated_staking_pools" */
  insert_delegated_staking_pools?: Maybe<DelegatedStakingPoolsMutationResponse>;
  /** insert a single row into the table: "delegated_staking_pools" */
  insert_delegated_staking_pools_one?: Maybe<DelegatedStakingPools>;
  /** insert data into the table: "delegator_balances" */
  insert_delegator_balances?: Maybe<DelegatorBalancesMutationResponse>;
  /** insert a single row into the table: "delegator_balances" */
  insert_delegator_balances_one?: Maybe<DelegatorBalances>;
  /** insert data into the table: "event_size_info" */
  insert_event_size_info?: Maybe<EventSizeInfoMutationResponse>;
  /** insert a single row into the table: "event_size_info" */
  insert_event_size_info_one?: Maybe<EventSizeInfo>;
  /** insert data into the table: "events" */
  insert_events?: Maybe<EventsMutationResponse>;
  /** insert a single row into the table: "events" */
  insert_events_one?: Maybe<Events>;
  /** insert data into the table: "events_view" */
  insert_events_view?: Maybe<EventsViewMutationResponse>;
  /** insert a single row into the table: "events_view" */
  insert_events_view_one?: Maybe<EventsView>;
  /** insert data into the table: "fungible_asset_activities" */
  insert_fungible_asset_activities?: Maybe<FungibleAssetActivitiesMutationResponse>;
  /** insert a single row into the table: "fungible_asset_activities" */
  insert_fungible_asset_activities_one?: Maybe<FungibleAssetActivities>;
  /** insert data into the table: "fungible_asset_balances" */
  insert_fungible_asset_balances?: Maybe<FungibleAssetBalancesMutationResponse>;
  /** insert a single row into the table: "fungible_asset_balances" */
  insert_fungible_asset_balances_one?: Maybe<FungibleAssetBalances>;
  /** insert data into the table: "fungible_asset_metadata" */
  insert_fungible_asset_metadata?: Maybe<FungibleAssetMetadataMutationResponse>;
  /** insert a single row into the table: "fungible_asset_metadata" */
  insert_fungible_asset_metadata_one?: Maybe<FungibleAssetMetadata>;
  /** insert data into the table: "fungible_asset_to_coin_mappings" */
  insert_fungible_asset_to_coin_mappings?: Maybe<FungibleAssetToCoinMappingsMutationResponse>;
  /** insert a single row into the table: "fungible_asset_to_coin_mappings" */
  insert_fungible_asset_to_coin_mappings_one?: Maybe<FungibleAssetToCoinMappings>;
  /** insert data into the table: "gas_fees" */
  insert_gas_fees?: Maybe<GasFeesMutationResponse>;
  /** insert a single row into the table: "gas_fees" */
  insert_gas_fees_one?: Maybe<GasFees>;
  /** insert data into the table: "indexer_status" */
  insert_indexer_status?: Maybe<IndexerStatusMutationResponse>;
  /** insert a single row into the table: "indexer_status" */
  insert_indexer_status_one?: Maybe<IndexerStatus>;
  /** insert data into the table: "move_modules" */
  insert_move_modules?: Maybe<MoveModulesMutationResponse>;
  /** insert a single row into the table: "move_modules" */
  insert_move_modules_one?: Maybe<MoveModules>;
  /** insert data into the table: "move_resources" */
  insert_move_resources?: Maybe<MoveResourcesMutationResponse>;
  /** insert a single row into the table: "move_resources" */
  insert_move_resources_one?: Maybe<MoveResources>;
  /** insert data into the table: "move_resources_view" */
  insert_move_resources_view?: Maybe<MoveResourcesViewMutationResponse>;
  /** insert a single row into the table: "move_resources_view" */
  insert_move_resources_view_one?: Maybe<MoveResourcesView>;
  /** insert data into the table: "nft_metadata_crawler.parsed_asset_uris" */
  insert_nft_metadata_crawler_parsed_asset_uris?: Maybe<NftMetadataCrawlerParsedAssetUrisMutationResponse>;
  /** insert a single row into the table: "nft_metadata_crawler.parsed_asset_uris" */
  insert_nft_metadata_crawler_parsed_asset_uris_one?: Maybe<NftMetadataCrawlerParsedAssetUris>;
  /** insert data into the table: "nft_points" */
  insert_nft_points?: Maybe<NftPointsMutationResponse>;
  /** insert a single row into the table: "nft_points" */
  insert_nft_points_one?: Maybe<NftPoints>;
  /** insert data into the table: "objects" */
  insert_objects?: Maybe<ObjectsMutationResponse>;
  /** insert a single row into the table: "objects" */
  insert_objects_one?: Maybe<Objects>;
  /** insert data into the table: "processor_metadata.processor_status" */
  insert_processor_metadata_processor_status?: Maybe<ProcessorMetadataProcessorStatusMutationResponse>;
  /** insert a single row into the table: "processor_metadata.processor_status" */
  insert_processor_metadata_processor_status_one?: Maybe<ProcessorMetadataProcessorStatus>;
  /** insert data into the table: "processor_status" */
  insert_processor_status?: Maybe<ProcessorStatusMutationResponse>;
  /** insert a single row into the table: "processor_status" */
  insert_processor_status_one?: Maybe<ProcessorStatus>;
  /** insert data into the table: "proposal_votes" */
  insert_proposal_votes?: Maybe<ProposalVotesMutationResponse>;
  /** insert a single row into the table: "proposal_votes" */
  insert_proposal_votes_one?: Maybe<ProposalVotes>;
  /** insert data into the table: "public_key_auth_keys" */
  insert_public_key_auth_keys?: Maybe<PublicKeyAuthKeysMutationResponse>;
  /** insert a single row into the table: "public_key_auth_keys" */
  insert_public_key_auth_keys_one?: Maybe<PublicKeyAuthKeys>;
  /** insert data into the table: "signatures" */
  insert_signatures?: Maybe<SignaturesMutationResponse>;
  /** insert a single row into the table: "signatures" */
  insert_signatures_one?: Maybe<Signatures>;
  /** insert data into the table: "spam_assets" */
  insert_spam_assets?: Maybe<SpamAssetsMutationResponse>;
  /** insert a single row into the table: "spam_assets" */
  insert_spam_assets_one?: Maybe<SpamAssets>;
  /** insert data into the table: "table_items" */
  insert_table_items?: Maybe<TableItemsMutationResponse>;
  /** insert a single row into the table: "table_items" */
  insert_table_items_one?: Maybe<TableItems>;
  /** insert data into the table: "table_items_view" */
  insert_table_items_view?: Maybe<TableItemsViewMutationResponse>;
  /** insert a single row into the table: "table_items_view" */
  insert_table_items_view_one?: Maybe<TableItemsView>;
  /** insert data into the table: "table_metadatas" */
  insert_table_metadatas?: Maybe<TableMetadatasMutationResponse>;
  /** insert a single row into the table: "table_metadatas" */
  insert_table_metadatas_one?: Maybe<TableMetadatas>;
  /** insert data into the table: "token_activities" */
  insert_token_activities?: Maybe<TokenActivitiesMutationResponse>;
  /** insert a single row into the table: "token_activities" */
  insert_token_activities_one?: Maybe<TokenActivities>;
  /** insert data into the table: "token_activities_v2" */
  insert_token_activities_v2?: Maybe<TokenActivitiesV2MutationResponse>;
  /** insert a single row into the table: "token_activities_v2" */
  insert_token_activities_v2_one?: Maybe<TokenActivitiesV2>;
  /** insert data into the table: "token_datas" */
  insert_token_datas?: Maybe<TokenDatasMutationResponse>;
  /** insert a single row into the table: "token_datas" */
  insert_token_datas_one?: Maybe<TokenDatas>;
  /** insert data into the table: "token_datas_v2" */
  insert_token_datas_v2?: Maybe<TokenDatasV2MutationResponse>;
  /** insert a single row into the table: "token_datas_v2" */
  insert_token_datas_v2_one?: Maybe<TokenDatasV2>;
  /** insert data into the table: "token_ownerships" */
  insert_token_ownerships?: Maybe<TokenOwnershipsMutationResponse>;
  /** insert a single row into the table: "token_ownerships" */
  insert_token_ownerships_one?: Maybe<TokenOwnerships>;
  /** insert data into the table: "token_ownerships_v2" */
  insert_token_ownerships_v2?: Maybe<TokenOwnershipsV2MutationResponse>;
  /** insert a single row into the table: "token_ownerships_v2" */
  insert_token_ownerships_v2_one?: Maybe<TokenOwnershipsV2>;
  /** insert data into the table: "tokens" */
  insert_tokens?: Maybe<TokensMutationResponse>;
  /** insert a single row into the table: "tokens" */
  insert_tokens_one?: Maybe<Tokens>;
  /** insert data into the table: "transaction_size_info" */
  insert_transaction_size_info?: Maybe<TransactionSizeInfoMutationResponse>;
  /** insert a single row into the table: "transaction_size_info" */
  insert_transaction_size_info_one?: Maybe<TransactionSizeInfo>;
  /** insert data into the table: "transactions_view" */
  insert_transactions_view?: Maybe<TransactionsViewMutationResponse>;
  /** insert a single row into the table: "transactions_view" */
  insert_transactions_view_one?: Maybe<TransactionsView>;
  /** insert data into the table: "user_transactions" */
  insert_user_transactions?: Maybe<UserTransactionsMutationResponse>;
  /** insert a single row into the table: "user_transactions" */
  insert_user_transactions_one?: Maybe<UserTransactions>;
  /** update data of the table: "account_transactions" */
  update_account_transactions?: Maybe<AccountTransactionsMutationResponse>;
  /** update single row of the table: "account_transactions" */
  update_account_transactions_by_pk?: Maybe<AccountTransactions>;
  /** update multiples rows of table: "account_transactions" */
  update_account_transactions_many?: Maybe<Array<Maybe<AccountTransactionsMutationResponse>>>;
  /** update data of the table: "ans_lookup" */
  update_ans_lookup?: Maybe<AnsLookupMutationResponse>;
  /** update single row of the table: "ans_lookup" */
  update_ans_lookup_by_pk?: Maybe<AnsLookup>;
  /** update multiples rows of table: "ans_lookup" */
  update_ans_lookup_many?: Maybe<Array<Maybe<AnsLookupMutationResponse>>>;
  /** update data of the table: "ans_lookup_v2" */
  update_ans_lookup_v2?: Maybe<AnsLookupV2MutationResponse>;
  /** update single row of the table: "ans_lookup_v2" */
  update_ans_lookup_v2_by_pk?: Maybe<AnsLookupV2>;
  /** update multiples rows of table: "ans_lookup_v2" */
  update_ans_lookup_v2_many?: Maybe<Array<Maybe<AnsLookupV2MutationResponse>>>;
  /** update data of the table: "ans_primary_name" */
  update_ans_primary_name?: Maybe<AnsPrimaryNameMutationResponse>;
  /** update single row of the table: "ans_primary_name" */
  update_ans_primary_name_by_pk?: Maybe<AnsPrimaryName>;
  /** update multiples rows of table: "ans_primary_name" */
  update_ans_primary_name_many?: Maybe<Array<Maybe<AnsPrimaryNameMutationResponse>>>;
  /** update data of the table: "ans_primary_name_v2" */
  update_ans_primary_name_v2?: Maybe<AnsPrimaryNameV2MutationResponse>;
  /** update single row of the table: "ans_primary_name_v2" */
  update_ans_primary_name_v2_by_pk?: Maybe<AnsPrimaryNameV2>;
  /** update multiples rows of table: "ans_primary_name_v2" */
  update_ans_primary_name_v2_many?: Maybe<Array<Maybe<AnsPrimaryNameV2MutationResponse>>>;
  /** update data of the table: "auth_key_account_addresses" */
  update_auth_key_account_addresses?: Maybe<AuthKeyAccountAddressesMutationResponse>;
  /** update single row of the table: "auth_key_account_addresses" */
  update_auth_key_account_addresses_by_pk?: Maybe<AuthKeyAccountAddresses>;
  /** update multiples rows of table: "auth_key_account_addresses" */
  update_auth_key_account_addresses_many?: Maybe<Array<Maybe<AuthKeyAccountAddressesMutationResponse>>>;
  /** update data of the table: "block_metadata_transactions" */
  update_block_metadata_transactions?: Maybe<BlockMetadataTransactionsMutationResponse>;
  /** update single row of the table: "block_metadata_transactions" */
  update_block_metadata_transactions_by_pk?: Maybe<BlockMetadataTransactions>;
  /** update multiples rows of table: "block_metadata_transactions" */
  update_block_metadata_transactions_many?: Maybe<Array<Maybe<BlockMetadataTransactionsMutationResponse>>>;
  /** update data of the table: "coin_activities" */
  update_coin_activities?: Maybe<CoinActivitiesMutationResponse>;
  /** update single row of the table: "coin_activities" */
  update_coin_activities_by_pk?: Maybe<CoinActivities>;
  /** update multiples rows of table: "coin_activities" */
  update_coin_activities_many?: Maybe<Array<Maybe<CoinActivitiesMutationResponse>>>;
  /** update data of the table: "coin_balances" */
  update_coin_balances?: Maybe<CoinBalancesMutationResponse>;
  /** update single row of the table: "coin_balances" */
  update_coin_balances_by_pk?: Maybe<CoinBalances>;
  /** update multiples rows of table: "coin_balances" */
  update_coin_balances_many?: Maybe<Array<Maybe<CoinBalancesMutationResponse>>>;
  /** update data of the table: "coin_infos" */
  update_coin_infos?: Maybe<CoinInfosMutationResponse>;
  /** update single row of the table: "coin_infos" */
  update_coin_infos_by_pk?: Maybe<CoinInfos>;
  /** update multiples rows of table: "coin_infos" */
  update_coin_infos_many?: Maybe<Array<Maybe<CoinInfosMutationResponse>>>;
  /** update data of the table: "coin_supply" */
  update_coin_supply?: Maybe<CoinSupplyMutationResponse>;
  /** update single row of the table: "coin_supply" */
  update_coin_supply_by_pk?: Maybe<CoinSupply>;
  /** update multiples rows of table: "coin_supply" */
  update_coin_supply_many?: Maybe<Array<Maybe<CoinSupplyMutationResponse>>>;
  /** update data of the table: "collection_datas" */
  update_collection_datas?: Maybe<CollectionDatasMutationResponse>;
  /** update single row of the table: "collection_datas" */
  update_collection_datas_by_pk?: Maybe<CollectionDatas>;
  /** update multiples rows of table: "collection_datas" */
  update_collection_datas_many?: Maybe<Array<Maybe<CollectionDatasMutationResponse>>>;
  /** update data of the table: "collections_v2" */
  update_collections_v2?: Maybe<CollectionsV2MutationResponse>;
  /** update single row of the table: "collections_v2" */
  update_collections_v2_by_pk?: Maybe<CollectionsV2>;
  /** update multiples rows of table: "collections_v2" */
  update_collections_v2_many?: Maybe<Array<Maybe<CollectionsV2MutationResponse>>>;
  /** update data of the table: "current_ans_lookup" */
  update_current_ans_lookup?: Maybe<CurrentAnsLookupMutationResponse>;
  /** update single row of the table: "current_ans_lookup" */
  update_current_ans_lookup_by_pk?: Maybe<CurrentAnsLookup>;
  /** update multiples rows of table: "current_ans_lookup" */
  update_current_ans_lookup_many?: Maybe<Array<Maybe<CurrentAnsLookupMutationResponse>>>;
  /** update data of the table: "current_ans_lookup_v2" */
  update_current_ans_lookup_v2?: Maybe<CurrentAnsLookupV2MutationResponse>;
  /** update single row of the table: "current_ans_lookup_v2" */
  update_current_ans_lookup_v2_by_pk?: Maybe<CurrentAnsLookupV2>;
  /** update multiples rows of table: "current_ans_lookup_v2" */
  update_current_ans_lookup_v2_many?: Maybe<Array<Maybe<CurrentAnsLookupV2MutationResponse>>>;
  /** update data of the table: "current_ans_primary_name" */
  update_current_ans_primary_name?: Maybe<CurrentAnsPrimaryNameMutationResponse>;
  /** update single row of the table: "current_ans_primary_name" */
  update_current_ans_primary_name_by_pk?: Maybe<CurrentAnsPrimaryName>;
  /** update multiples rows of table: "current_ans_primary_name" */
  update_current_ans_primary_name_many?: Maybe<Array<Maybe<CurrentAnsPrimaryNameMutationResponse>>>;
  /** update data of the table: "current_ans_primary_name_v2" */
  update_current_ans_primary_name_v2?: Maybe<CurrentAnsPrimaryNameV2MutationResponse>;
  /** update single row of the table: "current_ans_primary_name_v2" */
  update_current_ans_primary_name_v2_by_pk?: Maybe<CurrentAnsPrimaryNameV2>;
  /** update multiples rows of table: "current_ans_primary_name_v2" */
  update_current_ans_primary_name_v2_many?: Maybe<Array<Maybe<CurrentAnsPrimaryNameV2MutationResponse>>>;
  /** update data of the table: "current_coin_balances" */
  update_current_coin_balances?: Maybe<CurrentCoinBalancesMutationResponse>;
  /** update single row of the table: "current_coin_balances" */
  update_current_coin_balances_by_pk?: Maybe<CurrentCoinBalances>;
  /** update multiples rows of table: "current_coin_balances" */
  update_current_coin_balances_many?: Maybe<Array<Maybe<CurrentCoinBalancesMutationResponse>>>;
  /** update data of the table: "current_collection_datas" */
  update_current_collection_datas?: Maybe<CurrentCollectionDatasMutationResponse>;
  /** update single row of the table: "current_collection_datas" */
  update_current_collection_datas_by_pk?: Maybe<CurrentCollectionDatas>;
  /** update multiples rows of table: "current_collection_datas" */
  update_current_collection_datas_many?: Maybe<Array<Maybe<CurrentCollectionDatasMutationResponse>>>;
  /** update data of the table: "current_collections_v2" */
  update_current_collections_v2?: Maybe<CurrentCollectionsV2MutationResponse>;
  /** update single row of the table: "current_collections_v2" */
  update_current_collections_v2_by_pk?: Maybe<CurrentCollectionsV2>;
  /** update multiples rows of table: "current_collections_v2" */
  update_current_collections_v2_many?: Maybe<Array<Maybe<CurrentCollectionsV2MutationResponse>>>;
  /** update data of the table: "current_delegated_staking_pool_balances" */
  update_current_delegated_staking_pool_balances?: Maybe<CurrentDelegatedStakingPoolBalancesMutationResponse>;
  /** update single row of the table: "current_delegated_staking_pool_balances" */
  update_current_delegated_staking_pool_balances_by_pk?: Maybe<CurrentDelegatedStakingPoolBalances>;
  /** update multiples rows of table: "current_delegated_staking_pool_balances" */
  update_current_delegated_staking_pool_balances_many?: Maybe<
    Array<Maybe<CurrentDelegatedStakingPoolBalancesMutationResponse>>
  >;
  /** update data of the table: "current_delegated_voter" */
  update_current_delegated_voter?: Maybe<CurrentDelegatedVoterMutationResponse>;
  /** update single row of the table: "current_delegated_voter" */
  update_current_delegated_voter_by_pk?: Maybe<CurrentDelegatedVoter>;
  /** update multiples rows of table: "current_delegated_voter" */
  update_current_delegated_voter_many?: Maybe<Array<Maybe<CurrentDelegatedVoterMutationResponse>>>;
  /** update data of the table: "current_delegator_balances" */
  update_current_delegator_balances?: Maybe<CurrentDelegatorBalancesMutationResponse>;
  /** update single row of the table: "current_delegator_balances" */
  update_current_delegator_balances_by_pk?: Maybe<CurrentDelegatorBalances>;
  /** update multiples rows of table: "current_delegator_balances" */
  update_current_delegator_balances_many?: Maybe<Array<Maybe<CurrentDelegatorBalancesMutationResponse>>>;
  /** update data of the table: "current_fungible_asset_balances_legacy" */
  update_current_fungible_asset_balances?: Maybe<CurrentFungibleAssetBalancesMutationResponse>;
  /** update single row of the table: "current_fungible_asset_balances_legacy" */
  update_current_fungible_asset_balances_by_pk?: Maybe<CurrentFungibleAssetBalances>;
  /** update multiples rows of table: "current_fungible_asset_balances_legacy" */
  update_current_fungible_asset_balances_many?: Maybe<Array<Maybe<CurrentFungibleAssetBalancesMutationResponse>>>;
  /** update data of the table: "current_fungible_asset_balances" */
  update_current_fungible_asset_balances_new?: Maybe<CurrentFungibleAssetBalancesNewMutationResponse>;
  /** update single row of the table: "current_fungible_asset_balances" */
  update_current_fungible_asset_balances_new_by_pk?: Maybe<CurrentFungibleAssetBalancesNew>;
  /** update multiples rows of table: "current_fungible_asset_balances" */
  update_current_fungible_asset_balances_new_many?: Maybe<
    Array<Maybe<CurrentFungibleAssetBalancesNewMutationResponse>>
  >;
  /** update data of the table: "current_objects" */
  update_current_objects?: Maybe<CurrentObjectsMutationResponse>;
  /** update single row of the table: "current_objects" */
  update_current_objects_by_pk?: Maybe<CurrentObjects>;
  /** update multiples rows of table: "current_objects" */
  update_current_objects_many?: Maybe<Array<Maybe<CurrentObjectsMutationResponse>>>;
  /** update data of the table: "current_staking_pool_voter" */
  update_current_staking_pool_voter?: Maybe<CurrentStakingPoolVoterMutationResponse>;
  /** update single row of the table: "current_staking_pool_voter" */
  update_current_staking_pool_voter_by_pk?: Maybe<CurrentStakingPoolVoter>;
  /** update multiples rows of table: "current_staking_pool_voter" */
  update_current_staking_pool_voter_many?: Maybe<Array<Maybe<CurrentStakingPoolVoterMutationResponse>>>;
  /** update data of the table: "current_table_items" */
  update_current_table_items?: Maybe<CurrentTableItemsMutationResponse>;
  /** update single row of the table: "current_table_items" */
  update_current_table_items_by_pk?: Maybe<CurrentTableItems>;
  /** update multiples rows of table: "current_table_items" */
  update_current_table_items_many?: Maybe<Array<Maybe<CurrentTableItemsMutationResponse>>>;
  /** update data of the table: "current_table_items_view" */
  update_current_table_items_view?: Maybe<CurrentTableItemsViewMutationResponse>;
  /** update multiples rows of table: "current_table_items_view" */
  update_current_table_items_view_many?: Maybe<Array<Maybe<CurrentTableItemsViewMutationResponse>>>;
  /** update data of the table: "current_token_datas" */
  update_current_token_datas?: Maybe<CurrentTokenDatasMutationResponse>;
  /** update single row of the table: "current_token_datas" */
  update_current_token_datas_by_pk?: Maybe<CurrentTokenDatas>;
  /** update multiples rows of table: "current_token_datas" */
  update_current_token_datas_many?: Maybe<Array<Maybe<CurrentTokenDatasMutationResponse>>>;
  /** update data of the table: "current_token_datas_v2" */
  update_current_token_datas_v2?: Maybe<CurrentTokenDatasV2MutationResponse>;
  /** update single row of the table: "current_token_datas_v2" */
  update_current_token_datas_v2_by_pk?: Maybe<CurrentTokenDatasV2>;
  /** update multiples rows of table: "current_token_datas_v2" */
  update_current_token_datas_v2_many?: Maybe<Array<Maybe<CurrentTokenDatasV2MutationResponse>>>;
  /** update data of the table: "current_token_ownerships" */
  update_current_token_ownerships?: Maybe<CurrentTokenOwnershipsMutationResponse>;
  /** update single row of the table: "current_token_ownerships" */
  update_current_token_ownerships_by_pk?: Maybe<CurrentTokenOwnerships>;
  /** update multiples rows of table: "current_token_ownerships" */
  update_current_token_ownerships_many?: Maybe<Array<Maybe<CurrentTokenOwnershipsMutationResponse>>>;
  /** update data of the table: "current_token_ownerships_v2" */
  update_current_token_ownerships_v2?: Maybe<CurrentTokenOwnershipsV2MutationResponse>;
  /** update single row of the table: "current_token_ownerships_v2" */
  update_current_token_ownerships_v2_by_pk?: Maybe<CurrentTokenOwnershipsV2>;
  /** update multiples rows of table: "current_token_ownerships_v2" */
  update_current_token_ownerships_v2_many?: Maybe<Array<Maybe<CurrentTokenOwnershipsV2MutationResponse>>>;
  /** update data of the table: "current_token_pending_claims" */
  update_current_token_pending_claims?: Maybe<CurrentTokenPendingClaimsMutationResponse>;
  /** update single row of the table: "current_token_pending_claims" */
  update_current_token_pending_claims_by_pk?: Maybe<CurrentTokenPendingClaims>;
  /** update multiples rows of table: "current_token_pending_claims" */
  update_current_token_pending_claims_many?: Maybe<Array<Maybe<CurrentTokenPendingClaimsMutationResponse>>>;
  /** update data of the table: "current_token_royalty_v1" */
  update_current_token_royalty_v1?: Maybe<CurrentTokenRoyaltyV1MutationResponse>;
  /** update single row of the table: "current_token_royalty_v1" */
  update_current_token_royalty_v1_by_pk?: Maybe<CurrentTokenRoyaltyV1>;
  /** update multiples rows of table: "current_token_royalty_v1" */
  update_current_token_royalty_v1_many?: Maybe<Array<Maybe<CurrentTokenRoyaltyV1MutationResponse>>>;
  /** update data of the table: "current_token_v2_metadata" */
  update_current_token_v2_metadata?: Maybe<CurrentTokenV2MetadataMutationResponse>;
  /** update single row of the table: "current_token_v2_metadata" */
  update_current_token_v2_metadata_by_pk?: Maybe<CurrentTokenV2Metadata>;
  /** update multiples rows of table: "current_token_v2_metadata" */
  update_current_token_v2_metadata_many?: Maybe<Array<Maybe<CurrentTokenV2MetadataMutationResponse>>>;
  /** update data of the table: "delegated_staking_activities" */
  update_delegated_staking_activities?: Maybe<DelegatedStakingActivitiesMutationResponse>;
  /** update single row of the table: "delegated_staking_activities" */
  update_delegated_staking_activities_by_pk?: Maybe<DelegatedStakingActivities>;
  /** update multiples rows of table: "delegated_staking_activities" */
  update_delegated_staking_activities_many?: Maybe<Array<Maybe<DelegatedStakingActivitiesMutationResponse>>>;
  /** update data of the table: "delegated_staking_pool_balances" */
  update_delegated_staking_pool_balances?: Maybe<DelegatedStakingPoolBalancesMutationResponse>;
  /** update single row of the table: "delegated_staking_pool_balances" */
  update_delegated_staking_pool_balances_by_pk?: Maybe<DelegatedStakingPoolBalances>;
  /** update multiples rows of table: "delegated_staking_pool_balances" */
  update_delegated_staking_pool_balances_many?: Maybe<Array<Maybe<DelegatedStakingPoolBalancesMutationResponse>>>;
  /** update data of the table: "delegated_staking_pools" */
  update_delegated_staking_pools?: Maybe<DelegatedStakingPoolsMutationResponse>;
  /** update single row of the table: "delegated_staking_pools" */
  update_delegated_staking_pools_by_pk?: Maybe<DelegatedStakingPools>;
  /** update multiples rows of table: "delegated_staking_pools" */
  update_delegated_staking_pools_many?: Maybe<Array<Maybe<DelegatedStakingPoolsMutationResponse>>>;
  /** update data of the table: "delegator_balances" */
  update_delegator_balances?: Maybe<DelegatorBalancesMutationResponse>;
  /** update single row of the table: "delegator_balances" */
  update_delegator_balances_by_pk?: Maybe<DelegatorBalances>;
  /** update multiples rows of table: "delegator_balances" */
  update_delegator_balances_many?: Maybe<Array<Maybe<DelegatorBalancesMutationResponse>>>;
  /** update data of the table: "event_size_info" */
  update_event_size_info?: Maybe<EventSizeInfoMutationResponse>;
  /** update single row of the table: "event_size_info" */
  update_event_size_info_by_pk?: Maybe<EventSizeInfo>;
  /** update multiples rows of table: "event_size_info" */
  update_event_size_info_many?: Maybe<Array<Maybe<EventSizeInfoMutationResponse>>>;
  /** update data of the table: "events" */
  update_events?: Maybe<EventsMutationResponse>;
  /** update single row of the table: "events" */
  update_events_by_pk?: Maybe<Events>;
  /** update multiples rows of table: "events" */
  update_events_many?: Maybe<Array<Maybe<EventsMutationResponse>>>;
  /** update data of the table: "events_view" */
  update_events_view?: Maybe<EventsViewMutationResponse>;
  /** update multiples rows of table: "events_view" */
  update_events_view_many?: Maybe<Array<Maybe<EventsViewMutationResponse>>>;
  /** update data of the table: "fungible_asset_activities" */
  update_fungible_asset_activities?: Maybe<FungibleAssetActivitiesMutationResponse>;
  /** update single row of the table: "fungible_asset_activities" */
  update_fungible_asset_activities_by_pk?: Maybe<FungibleAssetActivities>;
  /** update multiples rows of table: "fungible_asset_activities" */
  update_fungible_asset_activities_many?: Maybe<Array<Maybe<FungibleAssetActivitiesMutationResponse>>>;
  /** update data of the table: "fungible_asset_balances" */
  update_fungible_asset_balances?: Maybe<FungibleAssetBalancesMutationResponse>;
  /** update single row of the table: "fungible_asset_balances" */
  update_fungible_asset_balances_by_pk?: Maybe<FungibleAssetBalances>;
  /** update multiples rows of table: "fungible_asset_balances" */
  update_fungible_asset_balances_many?: Maybe<Array<Maybe<FungibleAssetBalancesMutationResponse>>>;
  /** update data of the table: "fungible_asset_metadata" */
  update_fungible_asset_metadata?: Maybe<FungibleAssetMetadataMutationResponse>;
  /** update single row of the table: "fungible_asset_metadata" */
  update_fungible_asset_metadata_by_pk?: Maybe<FungibleAssetMetadata>;
  /** update multiples rows of table: "fungible_asset_metadata" */
  update_fungible_asset_metadata_many?: Maybe<Array<Maybe<FungibleAssetMetadataMutationResponse>>>;
  /** update data of the table: "fungible_asset_to_coin_mappings" */
  update_fungible_asset_to_coin_mappings?: Maybe<FungibleAssetToCoinMappingsMutationResponse>;
  /** update single row of the table: "fungible_asset_to_coin_mappings" */
  update_fungible_asset_to_coin_mappings_by_pk?: Maybe<FungibleAssetToCoinMappings>;
  /** update multiples rows of table: "fungible_asset_to_coin_mappings" */
  update_fungible_asset_to_coin_mappings_many?: Maybe<Array<Maybe<FungibleAssetToCoinMappingsMutationResponse>>>;
  /** update data of the table: "gas_fees" */
  update_gas_fees?: Maybe<GasFeesMutationResponse>;
  /** update single row of the table: "gas_fees" */
  update_gas_fees_by_pk?: Maybe<GasFees>;
  /** update multiples rows of table: "gas_fees" */
  update_gas_fees_many?: Maybe<Array<Maybe<GasFeesMutationResponse>>>;
  /** update data of the table: "indexer_status" */
  update_indexer_status?: Maybe<IndexerStatusMutationResponse>;
  /** update single row of the table: "indexer_status" */
  update_indexer_status_by_pk?: Maybe<IndexerStatus>;
  /** update multiples rows of table: "indexer_status" */
  update_indexer_status_many?: Maybe<Array<Maybe<IndexerStatusMutationResponse>>>;
  /** update data of the table: "move_modules" */
  update_move_modules?: Maybe<MoveModulesMutationResponse>;
  /** update single row of the table: "move_modules" */
  update_move_modules_by_pk?: Maybe<MoveModules>;
  /** update multiples rows of table: "move_modules" */
  update_move_modules_many?: Maybe<Array<Maybe<MoveModulesMutationResponse>>>;
  /** update data of the table: "move_resources" */
  update_move_resources?: Maybe<MoveResourcesMutationResponse>;
  /** update single row of the table: "move_resources" */
  update_move_resources_by_pk?: Maybe<MoveResources>;
  /** update multiples rows of table: "move_resources" */
  update_move_resources_many?: Maybe<Array<Maybe<MoveResourcesMutationResponse>>>;
  /** update data of the table: "move_resources_view" */
  update_move_resources_view?: Maybe<MoveResourcesViewMutationResponse>;
  /** update multiples rows of table: "move_resources_view" */
  update_move_resources_view_many?: Maybe<Array<Maybe<MoveResourcesViewMutationResponse>>>;
  /** update data of the table: "nft_metadata_crawler.parsed_asset_uris" */
  update_nft_metadata_crawler_parsed_asset_uris?: Maybe<NftMetadataCrawlerParsedAssetUrisMutationResponse>;
  /** update single row of the table: "nft_metadata_crawler.parsed_asset_uris" */
  update_nft_metadata_crawler_parsed_asset_uris_by_pk?: Maybe<NftMetadataCrawlerParsedAssetUris>;
  /** update multiples rows of table: "nft_metadata_crawler.parsed_asset_uris" */
  update_nft_metadata_crawler_parsed_asset_uris_many?: Maybe<
    Array<Maybe<NftMetadataCrawlerParsedAssetUrisMutationResponse>>
  >;
  /** update data of the table: "nft_points" */
  update_nft_points?: Maybe<NftPointsMutationResponse>;
  /** update single row of the table: "nft_points" */
  update_nft_points_by_pk?: Maybe<NftPoints>;
  /** update multiples rows of table: "nft_points" */
  update_nft_points_many?: Maybe<Array<Maybe<NftPointsMutationResponse>>>;
  /** update data of the table: "objects" */
  update_objects?: Maybe<ObjectsMutationResponse>;
  /** update single row of the table: "objects" */
  update_objects_by_pk?: Maybe<Objects>;
  /** update multiples rows of table: "objects" */
  update_objects_many?: Maybe<Array<Maybe<ObjectsMutationResponse>>>;
  /** update data of the table: "processor_metadata.processor_status" */
  update_processor_metadata_processor_status?: Maybe<ProcessorMetadataProcessorStatusMutationResponse>;
  /** update single row of the table: "processor_metadata.processor_status" */
  update_processor_metadata_processor_status_by_pk?: Maybe<ProcessorMetadataProcessorStatus>;
  /** update multiples rows of table: "processor_metadata.processor_status" */
  update_processor_metadata_processor_status_many?: Maybe<
    Array<Maybe<ProcessorMetadataProcessorStatusMutationResponse>>
  >;
  /** update data of the table: "processor_status" */
  update_processor_status?: Maybe<ProcessorStatusMutationResponse>;
  /** update single row of the table: "processor_status" */
  update_processor_status_by_pk?: Maybe<ProcessorStatus>;
  /** update multiples rows of table: "processor_status" */
  update_processor_status_many?: Maybe<Array<Maybe<ProcessorStatusMutationResponse>>>;
  /** update data of the table: "proposal_votes" */
  update_proposal_votes?: Maybe<ProposalVotesMutationResponse>;
  /** update single row of the table: "proposal_votes" */
  update_proposal_votes_by_pk?: Maybe<ProposalVotes>;
  /** update multiples rows of table: "proposal_votes" */
  update_proposal_votes_many?: Maybe<Array<Maybe<ProposalVotesMutationResponse>>>;
  /** update data of the table: "public_key_auth_keys" */
  update_public_key_auth_keys?: Maybe<PublicKeyAuthKeysMutationResponse>;
  /** update single row of the table: "public_key_auth_keys" */
  update_public_key_auth_keys_by_pk?: Maybe<PublicKeyAuthKeys>;
  /** update multiples rows of table: "public_key_auth_keys" */
  update_public_key_auth_keys_many?: Maybe<Array<Maybe<PublicKeyAuthKeysMutationResponse>>>;
  /** update data of the table: "signatures" */
  update_signatures?: Maybe<SignaturesMutationResponse>;
  /** update single row of the table: "signatures" */
  update_signatures_by_pk?: Maybe<Signatures>;
  /** update multiples rows of table: "signatures" */
  update_signatures_many?: Maybe<Array<Maybe<SignaturesMutationResponse>>>;
  /** update data of the table: "spam_assets" */
  update_spam_assets?: Maybe<SpamAssetsMutationResponse>;
  /** update single row of the table: "spam_assets" */
  update_spam_assets_by_pk?: Maybe<SpamAssets>;
  /** update multiples rows of table: "spam_assets" */
  update_spam_assets_many?: Maybe<Array<Maybe<SpamAssetsMutationResponse>>>;
  /** update data of the table: "table_items" */
  update_table_items?: Maybe<TableItemsMutationResponse>;
  /** update single row of the table: "table_items" */
  update_table_items_by_pk?: Maybe<TableItems>;
  /** update multiples rows of table: "table_items" */
  update_table_items_many?: Maybe<Array<Maybe<TableItemsMutationResponse>>>;
  /** update data of the table: "table_items_view" */
  update_table_items_view?: Maybe<TableItemsViewMutationResponse>;
  /** update multiples rows of table: "table_items_view" */
  update_table_items_view_many?: Maybe<Array<Maybe<TableItemsViewMutationResponse>>>;
  /** update data of the table: "table_metadatas" */
  update_table_metadatas?: Maybe<TableMetadatasMutationResponse>;
  /** update single row of the table: "table_metadatas" */
  update_table_metadatas_by_pk?: Maybe<TableMetadatas>;
  /** update multiples rows of table: "table_metadatas" */
  update_table_metadatas_many?: Maybe<Array<Maybe<TableMetadatasMutationResponse>>>;
  /** update data of the table: "token_activities" */
  update_token_activities?: Maybe<TokenActivitiesMutationResponse>;
  /** update single row of the table: "token_activities" */
  update_token_activities_by_pk?: Maybe<TokenActivities>;
  /** update multiples rows of table: "token_activities" */
  update_token_activities_many?: Maybe<Array<Maybe<TokenActivitiesMutationResponse>>>;
  /** update data of the table: "token_activities_v2" */
  update_token_activities_v2?: Maybe<TokenActivitiesV2MutationResponse>;
  /** update single row of the table: "token_activities_v2" */
  update_token_activities_v2_by_pk?: Maybe<TokenActivitiesV2>;
  /** update multiples rows of table: "token_activities_v2" */
  update_token_activities_v2_many?: Maybe<Array<Maybe<TokenActivitiesV2MutationResponse>>>;
  /** update data of the table: "token_datas" */
  update_token_datas?: Maybe<TokenDatasMutationResponse>;
  /** update single row of the table: "token_datas" */
  update_token_datas_by_pk?: Maybe<TokenDatas>;
  /** update multiples rows of table: "token_datas" */
  update_token_datas_many?: Maybe<Array<Maybe<TokenDatasMutationResponse>>>;
  /** update data of the table: "token_datas_v2" */
  update_token_datas_v2?: Maybe<TokenDatasV2MutationResponse>;
  /** update single row of the table: "token_datas_v2" */
  update_token_datas_v2_by_pk?: Maybe<TokenDatasV2>;
  /** update multiples rows of table: "token_datas_v2" */
  update_token_datas_v2_many?: Maybe<Array<Maybe<TokenDatasV2MutationResponse>>>;
  /** update data of the table: "token_ownerships" */
  update_token_ownerships?: Maybe<TokenOwnershipsMutationResponse>;
  /** update single row of the table: "token_ownerships" */
  update_token_ownerships_by_pk?: Maybe<TokenOwnerships>;
  /** update multiples rows of table: "token_ownerships" */
  update_token_ownerships_many?: Maybe<Array<Maybe<TokenOwnershipsMutationResponse>>>;
  /** update data of the table: "token_ownerships_v2" */
  update_token_ownerships_v2?: Maybe<TokenOwnershipsV2MutationResponse>;
  /** update single row of the table: "token_ownerships_v2" */
  update_token_ownerships_v2_by_pk?: Maybe<TokenOwnershipsV2>;
  /** update multiples rows of table: "token_ownerships_v2" */
  update_token_ownerships_v2_many?: Maybe<Array<Maybe<TokenOwnershipsV2MutationResponse>>>;
  /** update data of the table: "tokens" */
  update_tokens?: Maybe<TokensMutationResponse>;
  /** update single row of the table: "tokens" */
  update_tokens_by_pk?: Maybe<Tokens>;
  /** update multiples rows of table: "tokens" */
  update_tokens_many?: Maybe<Array<Maybe<TokensMutationResponse>>>;
  /** update data of the table: "transaction_size_info" */
  update_transaction_size_info?: Maybe<TransactionSizeInfoMutationResponse>;
  /** update single row of the table: "transaction_size_info" */
  update_transaction_size_info_by_pk?: Maybe<TransactionSizeInfo>;
  /** update multiples rows of table: "transaction_size_info" */
  update_transaction_size_info_many?: Maybe<Array<Maybe<TransactionSizeInfoMutationResponse>>>;
  /** update data of the table: "transactions_view" */
  update_transactions_view?: Maybe<TransactionsViewMutationResponse>;
  /** update multiples rows of table: "transactions_view" */
  update_transactions_view_many?: Maybe<Array<Maybe<TransactionsViewMutationResponse>>>;
  /** update data of the table: "user_transactions" */
  update_user_transactions?: Maybe<UserTransactionsMutationResponse>;
  /** update single row of the table: "user_transactions" */
  update_user_transactions_by_pk?: Maybe<UserTransactions>;
  /** update multiples rows of table: "user_transactions" */
  update_user_transactions_many?: Maybe<Array<Maybe<UserTransactionsMutationResponse>>>;
};

/** mutation root */
export type MutationRootDeleteAccountTransactionsArgs = {
  where: AccountTransactionsBoolExp;
};

/** mutation root */
export type MutationRootDeleteAccountTransactionsByPkArgs = {
  account_address: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteAnsLookupArgs = {
  where: AnsLookupBoolExp;
};

/** mutation root */
export type MutationRootDeleteAnsLookupByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteAnsLookupV2Args = {
  where: AnsLookupV2BoolExp;
};

/** mutation root */
export type MutationRootDeleteAnsLookupV2ByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteAnsPrimaryNameArgs = {
  where: AnsPrimaryNameBoolExp;
};

/** mutation root */
export type MutationRootDeleteAnsPrimaryNameByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteAnsPrimaryNameV2Args = {
  where: AnsPrimaryNameV2BoolExp;
};

/** mutation root */
export type MutationRootDeleteAnsPrimaryNameV2ByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteAuthKeyAccountAddressesArgs = {
  where: AuthKeyAccountAddressesBoolExp;
};

/** mutation root */
export type MutationRootDeleteAuthKeyAccountAddressesByPkArgs = {
  account_address: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteBlockMetadataTransactionsArgs = {
  where: BlockMetadataTransactionsBoolExp;
};

/** mutation root */
export type MutationRootDeleteBlockMetadataTransactionsByPkArgs = {
  version: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteCoinActivitiesArgs = {
  where: CoinActivitiesBoolExp;
};

/** mutation root */
export type MutationRootDeleteCoinActivitiesByPkArgs = {
  event_account_address: Scalars["String"]["input"];
  event_creation_number: Scalars["bigint"]["input"];
  event_sequence_number: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteCoinBalancesArgs = {
  where: CoinBalancesBoolExp;
};

/** mutation root */
export type MutationRootDeleteCoinBalancesByPkArgs = {
  coin_type_hash: Scalars["String"]["input"];
  owner_address: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteCoinInfosArgs = {
  where: CoinInfosBoolExp;
};

/** mutation root */
export type MutationRootDeleteCoinInfosByPkArgs = {
  coin_type_hash: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteCoinSupplyArgs = {
  where: CoinSupplyBoolExp;
};

/** mutation root */
export type MutationRootDeleteCoinSupplyByPkArgs = {
  coin_type_hash: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteCollectionDatasArgs = {
  where: CollectionDatasBoolExp;
};

/** mutation root */
export type MutationRootDeleteCollectionDatasByPkArgs = {
  collection_data_id_hash: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteCollectionsV2Args = {
  where: CollectionsV2BoolExp;
};

/** mutation root */
export type MutationRootDeleteCollectionsV2ByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteCurrentAnsLookupArgs = {
  where: CurrentAnsLookupBoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentAnsLookupByPkArgs = {
  domain: Scalars["String"]["input"];
  subdomain: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteCurrentAnsLookupV2Args = {
  where: CurrentAnsLookupV2BoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentAnsLookupV2ByPkArgs = {
  domain: Scalars["String"]["input"];
  subdomain: Scalars["String"]["input"];
  token_standard: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteCurrentAnsPrimaryNameArgs = {
  where: CurrentAnsPrimaryNameBoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentAnsPrimaryNameByPkArgs = {
  registered_address: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteCurrentAnsPrimaryNameV2Args = {
  where: CurrentAnsPrimaryNameV2BoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentAnsPrimaryNameV2ByPkArgs = {
  registered_address: Scalars["String"]["input"];
  token_standard: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteCurrentCoinBalancesArgs = {
  where: CurrentCoinBalancesBoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentCoinBalancesByPkArgs = {
  coin_type_hash: Scalars["String"]["input"];
  owner_address: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteCurrentCollectionDatasArgs = {
  where: CurrentCollectionDatasBoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentCollectionDatasByPkArgs = {
  collection_data_id_hash: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteCurrentCollectionsV2Args = {
  where: CurrentCollectionsV2BoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentCollectionsV2ByPkArgs = {
  collection_id: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteCurrentDelegatedStakingPoolBalancesArgs = {
  where: CurrentDelegatedStakingPoolBalancesBoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentDelegatedStakingPoolBalancesByPkArgs = {
  staking_pool_address: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteCurrentDelegatedVoterArgs = {
  where: CurrentDelegatedVoterBoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentDelegatedVoterByPkArgs = {
  delegation_pool_address: Scalars["String"]["input"];
  delegator_address: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteCurrentDelegatorBalancesArgs = {
  where: CurrentDelegatorBalancesBoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentDelegatorBalancesByPkArgs = {
  delegator_address: Scalars["String"]["input"];
  pool_address: Scalars["String"]["input"];
  pool_type: Scalars["String"]["input"];
  table_handle: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteCurrentFungibleAssetBalancesArgs = {
  where: CurrentFungibleAssetBalancesBoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentFungibleAssetBalancesByPkArgs = {
  storage_id: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteCurrentFungibleAssetBalancesNewArgs = {
  where: CurrentFungibleAssetBalancesNewBoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentFungibleAssetBalancesNewByPkArgs = {
  storage_id: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteCurrentObjectsArgs = {
  where: CurrentObjectsBoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentObjectsByPkArgs = {
  object_address: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteCurrentStakingPoolVoterArgs = {
  where: CurrentStakingPoolVoterBoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentStakingPoolVoterByPkArgs = {
  staking_pool_address: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteCurrentTableItemsArgs = {
  where: CurrentTableItemsBoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentTableItemsByPkArgs = {
  key_hash: Scalars["String"]["input"];
  table_handle: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteCurrentTableItemsViewArgs = {
  where: CurrentTableItemsViewBoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentTokenDatasArgs = {
  where: CurrentTokenDatasBoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentTokenDatasByPkArgs = {
  token_data_id_hash: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteCurrentTokenDatasV2Args = {
  where: CurrentTokenDatasV2BoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentTokenDatasV2ByPkArgs = {
  token_data_id: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteCurrentTokenOwnershipsArgs = {
  where: CurrentTokenOwnershipsBoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentTokenOwnershipsByPkArgs = {
  owner_address: Scalars["String"]["input"];
  property_version: Scalars["numeric"]["input"];
  token_data_id_hash: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteCurrentTokenOwnershipsV2Args = {
  where: CurrentTokenOwnershipsV2BoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentTokenOwnershipsV2ByPkArgs = {
  owner_address: Scalars["String"]["input"];
  property_version_v1: Scalars["numeric"]["input"];
  storage_id: Scalars["String"]["input"];
  token_data_id: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteCurrentTokenPendingClaimsArgs = {
  where: CurrentTokenPendingClaimsBoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentTokenPendingClaimsByPkArgs = {
  from_address: Scalars["String"]["input"];
  property_version: Scalars["numeric"]["input"];
  to_address: Scalars["String"]["input"];
  token_data_id_hash: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteCurrentTokenRoyaltyV1Args = {
  where: CurrentTokenRoyaltyV1BoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentTokenRoyaltyV1ByPkArgs = {
  token_data_id: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteCurrentTokenV2MetadataArgs = {
  where: CurrentTokenV2MetadataBoolExp;
};

/** mutation root */
export type MutationRootDeleteCurrentTokenV2MetadataByPkArgs = {
  object_address: Scalars["String"]["input"];
  resource_type: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteDelegatedStakingActivitiesArgs = {
  where: DelegatedStakingActivitiesBoolExp;
};

/** mutation root */
export type MutationRootDeleteDelegatedStakingActivitiesByPkArgs = {
  event_index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteDelegatedStakingPoolBalancesArgs = {
  where: DelegatedStakingPoolBalancesBoolExp;
};

/** mutation root */
export type MutationRootDeleteDelegatedStakingPoolBalancesByPkArgs = {
  staking_pool_address: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteDelegatedStakingPoolsArgs = {
  where: DelegatedStakingPoolsBoolExp;
};

/** mutation root */
export type MutationRootDeleteDelegatedStakingPoolsByPkArgs = {
  staking_pool_address: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteDelegatorBalancesArgs = {
  where: DelegatorBalancesBoolExp;
};

/** mutation root */
export type MutationRootDeleteDelegatorBalancesByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteEventSizeInfoArgs = {
  where: EventSizeInfoBoolExp;
};

/** mutation root */
export type MutationRootDeleteEventSizeInfoByPkArgs = {
  index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteEventsArgs = {
  where: EventsBoolExp;
};

/** mutation root */
export type MutationRootDeleteEventsByPkArgs = {
  event_index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteEventsViewArgs = {
  where: EventsViewBoolExp;
};

/** mutation root */
export type MutationRootDeleteFungibleAssetActivitiesArgs = {
  where: FungibleAssetActivitiesBoolExp;
};

/** mutation root */
export type MutationRootDeleteFungibleAssetActivitiesByPkArgs = {
  event_index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteFungibleAssetBalancesArgs = {
  where: FungibleAssetBalancesBoolExp;
};

/** mutation root */
export type MutationRootDeleteFungibleAssetBalancesByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteFungibleAssetMetadataArgs = {
  where: FungibleAssetMetadataBoolExp;
};

/** mutation root */
export type MutationRootDeleteFungibleAssetMetadataByPkArgs = {
  asset_type: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteFungibleAssetToCoinMappingsArgs = {
  where: FungibleAssetToCoinMappingsBoolExp;
};

/** mutation root */
export type MutationRootDeleteFungibleAssetToCoinMappingsByPkArgs = {
  fungible_asset_metadata_address: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteGasFeesArgs = {
  where: GasFeesBoolExp;
};

/** mutation root */
export type MutationRootDeleteGasFeesByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteIndexerStatusArgs = {
  where: IndexerStatusBoolExp;
};

/** mutation root */
export type MutationRootDeleteIndexerStatusByPkArgs = {
  db: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteMoveModulesArgs = {
  where: MoveModulesBoolExp;
};

/** mutation root */
export type MutationRootDeleteMoveModulesByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteMoveResourcesArgs = {
  where: MoveResourcesBoolExp;
};

/** mutation root */
export type MutationRootDeleteMoveResourcesByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteMoveResourcesViewArgs = {
  where: MoveResourcesViewBoolExp;
};

/** mutation root */
export type MutationRootDeleteNftMetadataCrawlerParsedAssetUrisArgs = {
  where: NftMetadataCrawlerParsedAssetUrisBoolExp;
};

/** mutation root */
export type MutationRootDeleteNftMetadataCrawlerParsedAssetUrisByPkArgs = {
  asset_uri: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteNftPointsArgs = {
  where: NftPointsBoolExp;
};

/** mutation root */
export type MutationRootDeleteNftPointsByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteObjectsArgs = {
  where: ObjectsBoolExp;
};

/** mutation root */
export type MutationRootDeleteObjectsByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteProcessorMetadataProcessorStatusArgs = {
  where: ProcessorMetadataProcessorStatusBoolExp;
};

/** mutation root */
export type MutationRootDeleteProcessorMetadataProcessorStatusByPkArgs = {
  processor: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteProcessorStatusArgs = {
  where: ProcessorStatusBoolExp;
};

/** mutation root */
export type MutationRootDeleteProcessorStatusByPkArgs = {
  processor: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteProposalVotesArgs = {
  where: ProposalVotesBoolExp;
};

/** mutation root */
export type MutationRootDeleteProposalVotesByPkArgs = {
  proposal_id: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
  voter_address: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeletePublicKeyAuthKeysArgs = {
  where: PublicKeyAuthKeysBoolExp;
};

/** mutation root */
export type MutationRootDeletePublicKeyAuthKeysByPkArgs = {
  auth_key: Scalars["String"]["input"];
  public_key: Scalars["String"]["input"];
  public_key_type: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteSignaturesArgs = {
  where: SignaturesBoolExp;
};

/** mutation root */
export type MutationRootDeleteSignaturesByPkArgs = {
  is_sender_primary: Scalars["Boolean"]["input"];
  multi_agent_index: Scalars["bigint"]["input"];
  multi_sig_index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteSpamAssetsArgs = {
  where: SpamAssetsBoolExp;
};

/** mutation root */
export type MutationRootDeleteSpamAssetsByPkArgs = {
  asset: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteTableItemsArgs = {
  where: TableItemsBoolExp;
};

/** mutation root */
export type MutationRootDeleteTableItemsByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteTableItemsViewArgs = {
  where: TableItemsViewBoolExp;
};

/** mutation root */
export type MutationRootDeleteTableMetadatasArgs = {
  where: TableMetadatasBoolExp;
};

/** mutation root */
export type MutationRootDeleteTableMetadatasByPkArgs = {
  handle: Scalars["String"]["input"];
};

/** mutation root */
export type MutationRootDeleteTokenActivitiesArgs = {
  where: TokenActivitiesBoolExp;
};

/** mutation root */
export type MutationRootDeleteTokenActivitiesByPkArgs = {
  event_account_address: Scalars["String"]["input"];
  event_creation_number: Scalars["bigint"]["input"];
  event_sequence_number: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteTokenActivitiesV2Args = {
  where: TokenActivitiesV2BoolExp;
};

/** mutation root */
export type MutationRootDeleteTokenActivitiesV2ByPkArgs = {
  event_index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteTokenDatasArgs = {
  where: TokenDatasBoolExp;
};

/** mutation root */
export type MutationRootDeleteTokenDatasByPkArgs = {
  token_data_id_hash: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteTokenDatasV2Args = {
  where: TokenDatasV2BoolExp;
};

/** mutation root */
export type MutationRootDeleteTokenDatasV2ByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteTokenOwnershipsArgs = {
  where: TokenOwnershipsBoolExp;
};

/** mutation root */
export type MutationRootDeleteTokenOwnershipsByPkArgs = {
  property_version: Scalars["numeric"]["input"];
  table_handle: Scalars["String"]["input"];
  token_data_id_hash: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteTokenOwnershipsV2Args = {
  where: TokenOwnershipsV2BoolExp;
};

/** mutation root */
export type MutationRootDeleteTokenOwnershipsV2ByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteTokensArgs = {
  where: TokensBoolExp;
};

/** mutation root */
export type MutationRootDeleteTokensByPkArgs = {
  property_version: Scalars["numeric"]["input"];
  token_data_id_hash: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteTransactionSizeInfoArgs = {
  where: TransactionSizeInfoBoolExp;
};

/** mutation root */
export type MutationRootDeleteTransactionSizeInfoByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootDeleteTransactionsViewArgs = {
  where: TransactionsViewBoolExp;
};

/** mutation root */
export type MutationRootDeleteUserTransactionsArgs = {
  where: UserTransactionsBoolExp;
};

/** mutation root */
export type MutationRootDeleteUserTransactionsByPkArgs = {
  version: Scalars["bigint"]["input"];
};

/** mutation root */
export type MutationRootInsertAccountTransactionsArgs = {
  objects: Array<AccountTransactionsInsertInput>;
  on_conflict?: InputMaybe<AccountTransactionsOnConflict>;
};

/** mutation root */
export type MutationRootInsertAccountTransactionsOneArgs = {
  object: AccountTransactionsInsertInput;
  on_conflict?: InputMaybe<AccountTransactionsOnConflict>;
};

/** mutation root */
export type MutationRootInsertAnsLookupArgs = {
  objects: Array<AnsLookupInsertInput>;
  on_conflict?: InputMaybe<AnsLookupOnConflict>;
};

/** mutation root */
export type MutationRootInsertAnsLookupOneArgs = {
  object: AnsLookupInsertInput;
  on_conflict?: InputMaybe<AnsLookupOnConflict>;
};

/** mutation root */
export type MutationRootInsertAnsLookupV2Args = {
  objects: Array<AnsLookupV2InsertInput>;
  on_conflict?: InputMaybe<AnsLookupV2OnConflict>;
};

/** mutation root */
export type MutationRootInsertAnsLookupV2OneArgs = {
  object: AnsLookupV2InsertInput;
  on_conflict?: InputMaybe<AnsLookupV2OnConflict>;
};

/** mutation root */
export type MutationRootInsertAnsPrimaryNameArgs = {
  objects: Array<AnsPrimaryNameInsertInput>;
  on_conflict?: InputMaybe<AnsPrimaryNameOnConflict>;
};

/** mutation root */
export type MutationRootInsertAnsPrimaryNameOneArgs = {
  object: AnsPrimaryNameInsertInput;
  on_conflict?: InputMaybe<AnsPrimaryNameOnConflict>;
};

/** mutation root */
export type MutationRootInsertAnsPrimaryNameV2Args = {
  objects: Array<AnsPrimaryNameV2InsertInput>;
  on_conflict?: InputMaybe<AnsPrimaryNameV2OnConflict>;
};

/** mutation root */
export type MutationRootInsertAnsPrimaryNameV2OneArgs = {
  object: AnsPrimaryNameV2InsertInput;
  on_conflict?: InputMaybe<AnsPrimaryNameV2OnConflict>;
};

/** mutation root */
export type MutationRootInsertAuthKeyAccountAddressesArgs = {
  objects: Array<AuthKeyAccountAddressesInsertInput>;
  on_conflict?: InputMaybe<AuthKeyAccountAddressesOnConflict>;
};

/** mutation root */
export type MutationRootInsertAuthKeyAccountAddressesOneArgs = {
  object: AuthKeyAccountAddressesInsertInput;
  on_conflict?: InputMaybe<AuthKeyAccountAddressesOnConflict>;
};

/** mutation root */
export type MutationRootInsertBlockMetadataTransactionsArgs = {
  objects: Array<BlockMetadataTransactionsInsertInput>;
  on_conflict?: InputMaybe<BlockMetadataTransactionsOnConflict>;
};

/** mutation root */
export type MutationRootInsertBlockMetadataTransactionsOneArgs = {
  object: BlockMetadataTransactionsInsertInput;
  on_conflict?: InputMaybe<BlockMetadataTransactionsOnConflict>;
};

/** mutation root */
export type MutationRootInsertCoinActivitiesArgs = {
  objects: Array<CoinActivitiesInsertInput>;
  on_conflict?: InputMaybe<CoinActivitiesOnConflict>;
};

/** mutation root */
export type MutationRootInsertCoinActivitiesOneArgs = {
  object: CoinActivitiesInsertInput;
  on_conflict?: InputMaybe<CoinActivitiesOnConflict>;
};

/** mutation root */
export type MutationRootInsertCoinBalancesArgs = {
  objects: Array<CoinBalancesInsertInput>;
  on_conflict?: InputMaybe<CoinBalancesOnConflict>;
};

/** mutation root */
export type MutationRootInsertCoinBalancesOneArgs = {
  object: CoinBalancesInsertInput;
  on_conflict?: InputMaybe<CoinBalancesOnConflict>;
};

/** mutation root */
export type MutationRootInsertCoinInfosArgs = {
  objects: Array<CoinInfosInsertInput>;
  on_conflict?: InputMaybe<CoinInfosOnConflict>;
};

/** mutation root */
export type MutationRootInsertCoinInfosOneArgs = {
  object: CoinInfosInsertInput;
  on_conflict?: InputMaybe<CoinInfosOnConflict>;
};

/** mutation root */
export type MutationRootInsertCoinSupplyArgs = {
  objects: Array<CoinSupplyInsertInput>;
  on_conflict?: InputMaybe<CoinSupplyOnConflict>;
};

/** mutation root */
export type MutationRootInsertCoinSupplyOneArgs = {
  object: CoinSupplyInsertInput;
  on_conflict?: InputMaybe<CoinSupplyOnConflict>;
};

/** mutation root */
export type MutationRootInsertCollectionDatasArgs = {
  objects: Array<CollectionDatasInsertInput>;
  on_conflict?: InputMaybe<CollectionDatasOnConflict>;
};

/** mutation root */
export type MutationRootInsertCollectionDatasOneArgs = {
  object: CollectionDatasInsertInput;
  on_conflict?: InputMaybe<CollectionDatasOnConflict>;
};

/** mutation root */
export type MutationRootInsertCollectionsV2Args = {
  objects: Array<CollectionsV2InsertInput>;
  on_conflict?: InputMaybe<CollectionsV2OnConflict>;
};

/** mutation root */
export type MutationRootInsertCollectionsV2OneArgs = {
  object: CollectionsV2InsertInput;
  on_conflict?: InputMaybe<CollectionsV2OnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentAnsLookupArgs = {
  objects: Array<CurrentAnsLookupInsertInput>;
  on_conflict?: InputMaybe<CurrentAnsLookupOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentAnsLookupOneArgs = {
  object: CurrentAnsLookupInsertInput;
  on_conflict?: InputMaybe<CurrentAnsLookupOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentAnsLookupV2Args = {
  objects: Array<CurrentAnsLookupV2InsertInput>;
  on_conflict?: InputMaybe<CurrentAnsLookupV2OnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentAnsLookupV2OneArgs = {
  object: CurrentAnsLookupV2InsertInput;
  on_conflict?: InputMaybe<CurrentAnsLookupV2OnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentAnsPrimaryNameArgs = {
  objects: Array<CurrentAnsPrimaryNameInsertInput>;
  on_conflict?: InputMaybe<CurrentAnsPrimaryNameOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentAnsPrimaryNameOneArgs = {
  object: CurrentAnsPrimaryNameInsertInput;
  on_conflict?: InputMaybe<CurrentAnsPrimaryNameOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentAnsPrimaryNameV2Args = {
  objects: Array<CurrentAnsPrimaryNameV2InsertInput>;
  on_conflict?: InputMaybe<CurrentAnsPrimaryNameV2OnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentAnsPrimaryNameV2OneArgs = {
  object: CurrentAnsPrimaryNameV2InsertInput;
  on_conflict?: InputMaybe<CurrentAnsPrimaryNameV2OnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentCoinBalancesArgs = {
  objects: Array<CurrentCoinBalancesInsertInput>;
  on_conflict?: InputMaybe<CurrentCoinBalancesOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentCoinBalancesOneArgs = {
  object: CurrentCoinBalancesInsertInput;
  on_conflict?: InputMaybe<CurrentCoinBalancesOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentCollectionDatasArgs = {
  objects: Array<CurrentCollectionDatasInsertInput>;
  on_conflict?: InputMaybe<CurrentCollectionDatasOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentCollectionDatasOneArgs = {
  object: CurrentCollectionDatasInsertInput;
  on_conflict?: InputMaybe<CurrentCollectionDatasOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentCollectionsV2Args = {
  objects: Array<CurrentCollectionsV2InsertInput>;
  on_conflict?: InputMaybe<CurrentCollectionsV2OnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentCollectionsV2OneArgs = {
  object: CurrentCollectionsV2InsertInput;
  on_conflict?: InputMaybe<CurrentCollectionsV2OnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentDelegatedStakingPoolBalancesArgs = {
  objects: Array<CurrentDelegatedStakingPoolBalancesInsertInput>;
  on_conflict?: InputMaybe<CurrentDelegatedStakingPoolBalancesOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentDelegatedStakingPoolBalancesOneArgs = {
  object: CurrentDelegatedStakingPoolBalancesInsertInput;
  on_conflict?: InputMaybe<CurrentDelegatedStakingPoolBalancesOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentDelegatedVoterArgs = {
  objects: Array<CurrentDelegatedVoterInsertInput>;
  on_conflict?: InputMaybe<CurrentDelegatedVoterOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentDelegatedVoterOneArgs = {
  object: CurrentDelegatedVoterInsertInput;
  on_conflict?: InputMaybe<CurrentDelegatedVoterOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentDelegatorBalancesArgs = {
  objects: Array<CurrentDelegatorBalancesInsertInput>;
  on_conflict?: InputMaybe<CurrentDelegatorBalancesOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentDelegatorBalancesOneArgs = {
  object: CurrentDelegatorBalancesInsertInput;
  on_conflict?: InputMaybe<CurrentDelegatorBalancesOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentFungibleAssetBalancesArgs = {
  objects: Array<CurrentFungibleAssetBalancesInsertInput>;
  on_conflict?: InputMaybe<CurrentFungibleAssetBalancesOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentFungibleAssetBalancesNewArgs = {
  objects: Array<CurrentFungibleAssetBalancesNewInsertInput>;
  on_conflict?: InputMaybe<CurrentFungibleAssetBalancesNewOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentFungibleAssetBalancesNewOneArgs = {
  object: CurrentFungibleAssetBalancesNewInsertInput;
  on_conflict?: InputMaybe<CurrentFungibleAssetBalancesNewOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentFungibleAssetBalancesOneArgs = {
  object: CurrentFungibleAssetBalancesInsertInput;
  on_conflict?: InputMaybe<CurrentFungibleAssetBalancesOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentObjectsArgs = {
  objects: Array<CurrentObjectsInsertInput>;
  on_conflict?: InputMaybe<CurrentObjectsOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentObjectsOneArgs = {
  object: CurrentObjectsInsertInput;
  on_conflict?: InputMaybe<CurrentObjectsOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentStakingPoolVoterArgs = {
  objects: Array<CurrentStakingPoolVoterInsertInput>;
  on_conflict?: InputMaybe<CurrentStakingPoolVoterOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentStakingPoolVoterOneArgs = {
  object: CurrentStakingPoolVoterInsertInput;
  on_conflict?: InputMaybe<CurrentStakingPoolVoterOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentTableItemsArgs = {
  objects: Array<CurrentTableItemsInsertInput>;
  on_conflict?: InputMaybe<CurrentTableItemsOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentTableItemsOneArgs = {
  object: CurrentTableItemsInsertInput;
  on_conflict?: InputMaybe<CurrentTableItemsOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentTableItemsViewArgs = {
  objects: Array<CurrentTableItemsViewInsertInput>;
};

/** mutation root */
export type MutationRootInsertCurrentTableItemsViewOneArgs = {
  object: CurrentTableItemsViewInsertInput;
};

/** mutation root */
export type MutationRootInsertCurrentTokenDatasArgs = {
  objects: Array<CurrentTokenDatasInsertInput>;
  on_conflict?: InputMaybe<CurrentTokenDatasOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentTokenDatasOneArgs = {
  object: CurrentTokenDatasInsertInput;
  on_conflict?: InputMaybe<CurrentTokenDatasOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentTokenDatasV2Args = {
  objects: Array<CurrentTokenDatasV2InsertInput>;
  on_conflict?: InputMaybe<CurrentTokenDatasV2OnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentTokenDatasV2OneArgs = {
  object: CurrentTokenDatasV2InsertInput;
  on_conflict?: InputMaybe<CurrentTokenDatasV2OnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentTokenOwnershipsArgs = {
  objects: Array<CurrentTokenOwnershipsInsertInput>;
  on_conflict?: InputMaybe<CurrentTokenOwnershipsOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentTokenOwnershipsOneArgs = {
  object: CurrentTokenOwnershipsInsertInput;
  on_conflict?: InputMaybe<CurrentTokenOwnershipsOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentTokenOwnershipsV2Args = {
  objects: Array<CurrentTokenOwnershipsV2InsertInput>;
  on_conflict?: InputMaybe<CurrentTokenOwnershipsV2OnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentTokenOwnershipsV2OneArgs = {
  object: CurrentTokenOwnershipsV2InsertInput;
  on_conflict?: InputMaybe<CurrentTokenOwnershipsV2OnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentTokenPendingClaimsArgs = {
  objects: Array<CurrentTokenPendingClaimsInsertInput>;
  on_conflict?: InputMaybe<CurrentTokenPendingClaimsOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentTokenPendingClaimsOneArgs = {
  object: CurrentTokenPendingClaimsInsertInput;
  on_conflict?: InputMaybe<CurrentTokenPendingClaimsOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentTokenRoyaltyV1Args = {
  objects: Array<CurrentTokenRoyaltyV1InsertInput>;
  on_conflict?: InputMaybe<CurrentTokenRoyaltyV1OnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentTokenRoyaltyV1OneArgs = {
  object: CurrentTokenRoyaltyV1InsertInput;
  on_conflict?: InputMaybe<CurrentTokenRoyaltyV1OnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentTokenV2MetadataArgs = {
  objects: Array<CurrentTokenV2MetadataInsertInput>;
  on_conflict?: InputMaybe<CurrentTokenV2MetadataOnConflict>;
};

/** mutation root */
export type MutationRootInsertCurrentTokenV2MetadataOneArgs = {
  object: CurrentTokenV2MetadataInsertInput;
  on_conflict?: InputMaybe<CurrentTokenV2MetadataOnConflict>;
};

/** mutation root */
export type MutationRootInsertDelegatedStakingActivitiesArgs = {
  objects: Array<DelegatedStakingActivitiesInsertInput>;
  on_conflict?: InputMaybe<DelegatedStakingActivitiesOnConflict>;
};

/** mutation root */
export type MutationRootInsertDelegatedStakingActivitiesOneArgs = {
  object: DelegatedStakingActivitiesInsertInput;
  on_conflict?: InputMaybe<DelegatedStakingActivitiesOnConflict>;
};

/** mutation root */
export type MutationRootInsertDelegatedStakingPoolBalancesArgs = {
  objects: Array<DelegatedStakingPoolBalancesInsertInput>;
  on_conflict?: InputMaybe<DelegatedStakingPoolBalancesOnConflict>;
};

/** mutation root */
export type MutationRootInsertDelegatedStakingPoolBalancesOneArgs = {
  object: DelegatedStakingPoolBalancesInsertInput;
  on_conflict?: InputMaybe<DelegatedStakingPoolBalancesOnConflict>;
};

/** mutation root */
export type MutationRootInsertDelegatedStakingPoolsArgs = {
  objects: Array<DelegatedStakingPoolsInsertInput>;
  on_conflict?: InputMaybe<DelegatedStakingPoolsOnConflict>;
};

/** mutation root */
export type MutationRootInsertDelegatedStakingPoolsOneArgs = {
  object: DelegatedStakingPoolsInsertInput;
  on_conflict?: InputMaybe<DelegatedStakingPoolsOnConflict>;
};

/** mutation root */
export type MutationRootInsertDelegatorBalancesArgs = {
  objects: Array<DelegatorBalancesInsertInput>;
  on_conflict?: InputMaybe<DelegatorBalancesOnConflict>;
};

/** mutation root */
export type MutationRootInsertDelegatorBalancesOneArgs = {
  object: DelegatorBalancesInsertInput;
  on_conflict?: InputMaybe<DelegatorBalancesOnConflict>;
};

/** mutation root */
export type MutationRootInsertEventSizeInfoArgs = {
  objects: Array<EventSizeInfoInsertInput>;
  on_conflict?: InputMaybe<EventSizeInfoOnConflict>;
};

/** mutation root */
export type MutationRootInsertEventSizeInfoOneArgs = {
  object: EventSizeInfoInsertInput;
  on_conflict?: InputMaybe<EventSizeInfoOnConflict>;
};

/** mutation root */
export type MutationRootInsertEventsArgs = {
  objects: Array<EventsInsertInput>;
  on_conflict?: InputMaybe<EventsOnConflict>;
};

/** mutation root */
export type MutationRootInsertEventsOneArgs = {
  object: EventsInsertInput;
  on_conflict?: InputMaybe<EventsOnConflict>;
};

/** mutation root */
export type MutationRootInsertEventsViewArgs = {
  objects: Array<EventsViewInsertInput>;
};

/** mutation root */
export type MutationRootInsertEventsViewOneArgs = {
  object: EventsViewInsertInput;
};

/** mutation root */
export type MutationRootInsertFungibleAssetActivitiesArgs = {
  objects: Array<FungibleAssetActivitiesInsertInput>;
  on_conflict?: InputMaybe<FungibleAssetActivitiesOnConflict>;
};

/** mutation root */
export type MutationRootInsertFungibleAssetActivitiesOneArgs = {
  object: FungibleAssetActivitiesInsertInput;
  on_conflict?: InputMaybe<FungibleAssetActivitiesOnConflict>;
};

/** mutation root */
export type MutationRootInsertFungibleAssetBalancesArgs = {
  objects: Array<FungibleAssetBalancesInsertInput>;
  on_conflict?: InputMaybe<FungibleAssetBalancesOnConflict>;
};

/** mutation root */
export type MutationRootInsertFungibleAssetBalancesOneArgs = {
  object: FungibleAssetBalancesInsertInput;
  on_conflict?: InputMaybe<FungibleAssetBalancesOnConflict>;
};

/** mutation root */
export type MutationRootInsertFungibleAssetMetadataArgs = {
  objects: Array<FungibleAssetMetadataInsertInput>;
  on_conflict?: InputMaybe<FungibleAssetMetadataOnConflict>;
};

/** mutation root */
export type MutationRootInsertFungibleAssetMetadataOneArgs = {
  object: FungibleAssetMetadataInsertInput;
  on_conflict?: InputMaybe<FungibleAssetMetadataOnConflict>;
};

/** mutation root */
export type MutationRootInsertFungibleAssetToCoinMappingsArgs = {
  objects: Array<FungibleAssetToCoinMappingsInsertInput>;
  on_conflict?: InputMaybe<FungibleAssetToCoinMappingsOnConflict>;
};

/** mutation root */
export type MutationRootInsertFungibleAssetToCoinMappingsOneArgs = {
  object: FungibleAssetToCoinMappingsInsertInput;
  on_conflict?: InputMaybe<FungibleAssetToCoinMappingsOnConflict>;
};

/** mutation root */
export type MutationRootInsertGasFeesArgs = {
  objects: Array<GasFeesInsertInput>;
  on_conflict?: InputMaybe<GasFeesOnConflict>;
};

/** mutation root */
export type MutationRootInsertGasFeesOneArgs = {
  object: GasFeesInsertInput;
  on_conflict?: InputMaybe<GasFeesOnConflict>;
};

/** mutation root */
export type MutationRootInsertIndexerStatusArgs = {
  objects: Array<IndexerStatusInsertInput>;
  on_conflict?: InputMaybe<IndexerStatusOnConflict>;
};

/** mutation root */
export type MutationRootInsertIndexerStatusOneArgs = {
  object: IndexerStatusInsertInput;
  on_conflict?: InputMaybe<IndexerStatusOnConflict>;
};

/** mutation root */
export type MutationRootInsertMoveModulesArgs = {
  objects: Array<MoveModulesInsertInput>;
  on_conflict?: InputMaybe<MoveModulesOnConflict>;
};

/** mutation root */
export type MutationRootInsertMoveModulesOneArgs = {
  object: MoveModulesInsertInput;
  on_conflict?: InputMaybe<MoveModulesOnConflict>;
};

/** mutation root */
export type MutationRootInsertMoveResourcesArgs = {
  objects: Array<MoveResourcesInsertInput>;
  on_conflict?: InputMaybe<MoveResourcesOnConflict>;
};

/** mutation root */
export type MutationRootInsertMoveResourcesOneArgs = {
  object: MoveResourcesInsertInput;
  on_conflict?: InputMaybe<MoveResourcesOnConflict>;
};

/** mutation root */
export type MutationRootInsertMoveResourcesViewArgs = {
  objects: Array<MoveResourcesViewInsertInput>;
};

/** mutation root */
export type MutationRootInsertMoveResourcesViewOneArgs = {
  object: MoveResourcesViewInsertInput;
};

/** mutation root */
export type MutationRootInsertNftMetadataCrawlerParsedAssetUrisArgs = {
  objects: Array<NftMetadataCrawlerParsedAssetUrisInsertInput>;
  on_conflict?: InputMaybe<NftMetadataCrawlerParsedAssetUrisOnConflict>;
};

/** mutation root */
export type MutationRootInsertNftMetadataCrawlerParsedAssetUrisOneArgs = {
  object: NftMetadataCrawlerParsedAssetUrisInsertInput;
  on_conflict?: InputMaybe<NftMetadataCrawlerParsedAssetUrisOnConflict>;
};

/** mutation root */
export type MutationRootInsertNftPointsArgs = {
  objects: Array<NftPointsInsertInput>;
  on_conflict?: InputMaybe<NftPointsOnConflict>;
};

/** mutation root */
export type MutationRootInsertNftPointsOneArgs = {
  object: NftPointsInsertInput;
  on_conflict?: InputMaybe<NftPointsOnConflict>;
};

/** mutation root */
export type MutationRootInsertObjectsArgs = {
  objects: Array<ObjectsInsertInput>;
  on_conflict?: InputMaybe<ObjectsOnConflict>;
};

/** mutation root */
export type MutationRootInsertObjectsOneArgs = {
  object: ObjectsInsertInput;
  on_conflict?: InputMaybe<ObjectsOnConflict>;
};

/** mutation root */
export type MutationRootInsertProcessorMetadataProcessorStatusArgs = {
  objects: Array<ProcessorMetadataProcessorStatusInsertInput>;
  on_conflict?: InputMaybe<ProcessorMetadataProcessorStatusOnConflict>;
};

/** mutation root */
export type MutationRootInsertProcessorMetadataProcessorStatusOneArgs = {
  object: ProcessorMetadataProcessorStatusInsertInput;
  on_conflict?: InputMaybe<ProcessorMetadataProcessorStatusOnConflict>;
};

/** mutation root */
export type MutationRootInsertProcessorStatusArgs = {
  objects: Array<ProcessorStatusInsertInput>;
  on_conflict?: InputMaybe<ProcessorStatusOnConflict>;
};

/** mutation root */
export type MutationRootInsertProcessorStatusOneArgs = {
  object: ProcessorStatusInsertInput;
  on_conflict?: InputMaybe<ProcessorStatusOnConflict>;
};

/** mutation root */
export type MutationRootInsertProposalVotesArgs = {
  objects: Array<ProposalVotesInsertInput>;
  on_conflict?: InputMaybe<ProposalVotesOnConflict>;
};

/** mutation root */
export type MutationRootInsertProposalVotesOneArgs = {
  object: ProposalVotesInsertInput;
  on_conflict?: InputMaybe<ProposalVotesOnConflict>;
};

/** mutation root */
export type MutationRootInsertPublicKeyAuthKeysArgs = {
  objects: Array<PublicKeyAuthKeysInsertInput>;
  on_conflict?: InputMaybe<PublicKeyAuthKeysOnConflict>;
};

/** mutation root */
export type MutationRootInsertPublicKeyAuthKeysOneArgs = {
  object: PublicKeyAuthKeysInsertInput;
  on_conflict?: InputMaybe<PublicKeyAuthKeysOnConflict>;
};

/** mutation root */
export type MutationRootInsertSignaturesArgs = {
  objects: Array<SignaturesInsertInput>;
  on_conflict?: InputMaybe<SignaturesOnConflict>;
};

/** mutation root */
export type MutationRootInsertSignaturesOneArgs = {
  object: SignaturesInsertInput;
  on_conflict?: InputMaybe<SignaturesOnConflict>;
};

/** mutation root */
export type MutationRootInsertSpamAssetsArgs = {
  objects: Array<SpamAssetsInsertInput>;
  on_conflict?: InputMaybe<SpamAssetsOnConflict>;
};

/** mutation root */
export type MutationRootInsertSpamAssetsOneArgs = {
  object: SpamAssetsInsertInput;
  on_conflict?: InputMaybe<SpamAssetsOnConflict>;
};

/** mutation root */
export type MutationRootInsertTableItemsArgs = {
  objects: Array<TableItemsInsertInput>;
  on_conflict?: InputMaybe<TableItemsOnConflict>;
};

/** mutation root */
export type MutationRootInsertTableItemsOneArgs = {
  object: TableItemsInsertInput;
  on_conflict?: InputMaybe<TableItemsOnConflict>;
};

/** mutation root */
export type MutationRootInsertTableItemsViewArgs = {
  objects: Array<TableItemsViewInsertInput>;
};

/** mutation root */
export type MutationRootInsertTableItemsViewOneArgs = {
  object: TableItemsViewInsertInput;
};

/** mutation root */
export type MutationRootInsertTableMetadatasArgs = {
  objects: Array<TableMetadatasInsertInput>;
  on_conflict?: InputMaybe<TableMetadatasOnConflict>;
};

/** mutation root */
export type MutationRootInsertTableMetadatasOneArgs = {
  object: TableMetadatasInsertInput;
  on_conflict?: InputMaybe<TableMetadatasOnConflict>;
};

/** mutation root */
export type MutationRootInsertTokenActivitiesArgs = {
  objects: Array<TokenActivitiesInsertInput>;
  on_conflict?: InputMaybe<TokenActivitiesOnConflict>;
};

/** mutation root */
export type MutationRootInsertTokenActivitiesOneArgs = {
  object: TokenActivitiesInsertInput;
  on_conflict?: InputMaybe<TokenActivitiesOnConflict>;
};

/** mutation root */
export type MutationRootInsertTokenActivitiesV2Args = {
  objects: Array<TokenActivitiesV2InsertInput>;
  on_conflict?: InputMaybe<TokenActivitiesV2OnConflict>;
};

/** mutation root */
export type MutationRootInsertTokenActivitiesV2OneArgs = {
  object: TokenActivitiesV2InsertInput;
  on_conflict?: InputMaybe<TokenActivitiesV2OnConflict>;
};

/** mutation root */
export type MutationRootInsertTokenDatasArgs = {
  objects: Array<TokenDatasInsertInput>;
  on_conflict?: InputMaybe<TokenDatasOnConflict>;
};

/** mutation root */
export type MutationRootInsertTokenDatasOneArgs = {
  object: TokenDatasInsertInput;
  on_conflict?: InputMaybe<TokenDatasOnConflict>;
};

/** mutation root */
export type MutationRootInsertTokenDatasV2Args = {
  objects: Array<TokenDatasV2InsertInput>;
  on_conflict?: InputMaybe<TokenDatasV2OnConflict>;
};

/** mutation root */
export type MutationRootInsertTokenDatasV2OneArgs = {
  object: TokenDatasV2InsertInput;
  on_conflict?: InputMaybe<TokenDatasV2OnConflict>;
};

/** mutation root */
export type MutationRootInsertTokenOwnershipsArgs = {
  objects: Array<TokenOwnershipsInsertInput>;
  on_conflict?: InputMaybe<TokenOwnershipsOnConflict>;
};

/** mutation root */
export type MutationRootInsertTokenOwnershipsOneArgs = {
  object: TokenOwnershipsInsertInput;
  on_conflict?: InputMaybe<TokenOwnershipsOnConflict>;
};

/** mutation root */
export type MutationRootInsertTokenOwnershipsV2Args = {
  objects: Array<TokenOwnershipsV2InsertInput>;
  on_conflict?: InputMaybe<TokenOwnershipsV2OnConflict>;
};

/** mutation root */
export type MutationRootInsertTokenOwnershipsV2OneArgs = {
  object: TokenOwnershipsV2InsertInput;
  on_conflict?: InputMaybe<TokenOwnershipsV2OnConflict>;
};

/** mutation root */
export type MutationRootInsertTokensArgs = {
  objects: Array<TokensInsertInput>;
  on_conflict?: InputMaybe<TokensOnConflict>;
};

/** mutation root */
export type MutationRootInsertTokensOneArgs = {
  object: TokensInsertInput;
  on_conflict?: InputMaybe<TokensOnConflict>;
};

/** mutation root */
export type MutationRootInsertTransactionSizeInfoArgs = {
  objects: Array<TransactionSizeInfoInsertInput>;
  on_conflict?: InputMaybe<TransactionSizeInfoOnConflict>;
};

/** mutation root */
export type MutationRootInsertTransactionSizeInfoOneArgs = {
  object: TransactionSizeInfoInsertInput;
  on_conflict?: InputMaybe<TransactionSizeInfoOnConflict>;
};

/** mutation root */
export type MutationRootInsertTransactionsViewArgs = {
  objects: Array<TransactionsViewInsertInput>;
};

/** mutation root */
export type MutationRootInsertTransactionsViewOneArgs = {
  object: TransactionsViewInsertInput;
};

/** mutation root */
export type MutationRootInsertUserTransactionsArgs = {
  objects: Array<UserTransactionsInsertInput>;
  on_conflict?: InputMaybe<UserTransactionsOnConflict>;
};

/** mutation root */
export type MutationRootInsertUserTransactionsOneArgs = {
  object: UserTransactionsInsertInput;
  on_conflict?: InputMaybe<UserTransactionsOnConflict>;
};

/** mutation root */
export type MutationRootUpdateAccountTransactionsArgs = {
  _inc?: InputMaybe<AccountTransactionsIncInput>;
  _set?: InputMaybe<AccountTransactionsSetInput>;
  where: AccountTransactionsBoolExp;
};

/** mutation root */
export type MutationRootUpdateAccountTransactionsByPkArgs = {
  _inc?: InputMaybe<AccountTransactionsIncInput>;
  _set?: InputMaybe<AccountTransactionsSetInput>;
  pk_columns: AccountTransactionsPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateAccountTransactionsManyArgs = {
  updates: Array<AccountTransactionsUpdates>;
};

/** mutation root */
export type MutationRootUpdateAnsLookupArgs = {
  _inc?: InputMaybe<AnsLookupIncInput>;
  _set?: InputMaybe<AnsLookupSetInput>;
  where: AnsLookupBoolExp;
};

/** mutation root */
export type MutationRootUpdateAnsLookupByPkArgs = {
  _inc?: InputMaybe<AnsLookupIncInput>;
  _set?: InputMaybe<AnsLookupSetInput>;
  pk_columns: AnsLookupPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateAnsLookupManyArgs = {
  updates: Array<AnsLookupUpdates>;
};

/** mutation root */
export type MutationRootUpdateAnsLookupV2Args = {
  _inc?: InputMaybe<AnsLookupV2IncInput>;
  _set?: InputMaybe<AnsLookupV2SetInput>;
  where: AnsLookupV2BoolExp;
};

/** mutation root */
export type MutationRootUpdateAnsLookupV2ByPkArgs = {
  _inc?: InputMaybe<AnsLookupV2IncInput>;
  _set?: InputMaybe<AnsLookupV2SetInput>;
  pk_columns: AnsLookupV2PkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateAnsLookupV2ManyArgs = {
  updates: Array<AnsLookupV2Updates>;
};

/** mutation root */
export type MutationRootUpdateAnsPrimaryNameArgs = {
  _inc?: InputMaybe<AnsPrimaryNameIncInput>;
  _set?: InputMaybe<AnsPrimaryNameSetInput>;
  where: AnsPrimaryNameBoolExp;
};

/** mutation root */
export type MutationRootUpdateAnsPrimaryNameByPkArgs = {
  _inc?: InputMaybe<AnsPrimaryNameIncInput>;
  _set?: InputMaybe<AnsPrimaryNameSetInput>;
  pk_columns: AnsPrimaryNamePkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateAnsPrimaryNameManyArgs = {
  updates: Array<AnsPrimaryNameUpdates>;
};

/** mutation root */
export type MutationRootUpdateAnsPrimaryNameV2Args = {
  _inc?: InputMaybe<AnsPrimaryNameV2IncInput>;
  _set?: InputMaybe<AnsPrimaryNameV2SetInput>;
  where: AnsPrimaryNameV2BoolExp;
};

/** mutation root */
export type MutationRootUpdateAnsPrimaryNameV2ByPkArgs = {
  _inc?: InputMaybe<AnsPrimaryNameV2IncInput>;
  _set?: InputMaybe<AnsPrimaryNameV2SetInput>;
  pk_columns: AnsPrimaryNameV2PkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateAnsPrimaryNameV2ManyArgs = {
  updates: Array<AnsPrimaryNameV2Updates>;
};

/** mutation root */
export type MutationRootUpdateAuthKeyAccountAddressesArgs = {
  _inc?: InputMaybe<AuthKeyAccountAddressesIncInput>;
  _set?: InputMaybe<AuthKeyAccountAddressesSetInput>;
  where: AuthKeyAccountAddressesBoolExp;
};

/** mutation root */
export type MutationRootUpdateAuthKeyAccountAddressesByPkArgs = {
  _inc?: InputMaybe<AuthKeyAccountAddressesIncInput>;
  _set?: InputMaybe<AuthKeyAccountAddressesSetInput>;
  pk_columns: AuthKeyAccountAddressesPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateAuthKeyAccountAddressesManyArgs = {
  updates: Array<AuthKeyAccountAddressesUpdates>;
};

/** mutation root */
export type MutationRootUpdateBlockMetadataTransactionsArgs = {
  _append?: InputMaybe<BlockMetadataTransactionsAppendInput>;
  _delete_at_path?: InputMaybe<BlockMetadataTransactionsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<BlockMetadataTransactionsDeleteElemInput>;
  _delete_key?: InputMaybe<BlockMetadataTransactionsDeleteKeyInput>;
  _inc?: InputMaybe<BlockMetadataTransactionsIncInput>;
  _prepend?: InputMaybe<BlockMetadataTransactionsPrependInput>;
  _set?: InputMaybe<BlockMetadataTransactionsSetInput>;
  where: BlockMetadataTransactionsBoolExp;
};

/** mutation root */
export type MutationRootUpdateBlockMetadataTransactionsByPkArgs = {
  _append?: InputMaybe<BlockMetadataTransactionsAppendInput>;
  _delete_at_path?: InputMaybe<BlockMetadataTransactionsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<BlockMetadataTransactionsDeleteElemInput>;
  _delete_key?: InputMaybe<BlockMetadataTransactionsDeleteKeyInput>;
  _inc?: InputMaybe<BlockMetadataTransactionsIncInput>;
  _prepend?: InputMaybe<BlockMetadataTransactionsPrependInput>;
  _set?: InputMaybe<BlockMetadataTransactionsSetInput>;
  pk_columns: BlockMetadataTransactionsPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateBlockMetadataTransactionsManyArgs = {
  updates: Array<BlockMetadataTransactionsUpdates>;
};

/** mutation root */
export type MutationRootUpdateCoinActivitiesArgs = {
  _inc?: InputMaybe<CoinActivitiesIncInput>;
  _set?: InputMaybe<CoinActivitiesSetInput>;
  where: CoinActivitiesBoolExp;
};

/** mutation root */
export type MutationRootUpdateCoinActivitiesByPkArgs = {
  _inc?: InputMaybe<CoinActivitiesIncInput>;
  _set?: InputMaybe<CoinActivitiesSetInput>;
  pk_columns: CoinActivitiesPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCoinActivitiesManyArgs = {
  updates: Array<CoinActivitiesUpdates>;
};

/** mutation root */
export type MutationRootUpdateCoinBalancesArgs = {
  _inc?: InputMaybe<CoinBalancesIncInput>;
  _set?: InputMaybe<CoinBalancesSetInput>;
  where: CoinBalancesBoolExp;
};

/** mutation root */
export type MutationRootUpdateCoinBalancesByPkArgs = {
  _inc?: InputMaybe<CoinBalancesIncInput>;
  _set?: InputMaybe<CoinBalancesSetInput>;
  pk_columns: CoinBalancesPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCoinBalancesManyArgs = {
  updates: Array<CoinBalancesUpdates>;
};

/** mutation root */
export type MutationRootUpdateCoinInfosArgs = {
  _inc?: InputMaybe<CoinInfosIncInput>;
  _set?: InputMaybe<CoinInfosSetInput>;
  where: CoinInfosBoolExp;
};

/** mutation root */
export type MutationRootUpdateCoinInfosByPkArgs = {
  _inc?: InputMaybe<CoinInfosIncInput>;
  _set?: InputMaybe<CoinInfosSetInput>;
  pk_columns: CoinInfosPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCoinInfosManyArgs = {
  updates: Array<CoinInfosUpdates>;
};

/** mutation root */
export type MutationRootUpdateCoinSupplyArgs = {
  _inc?: InputMaybe<CoinSupplyIncInput>;
  _set?: InputMaybe<CoinSupplySetInput>;
  where: CoinSupplyBoolExp;
};

/** mutation root */
export type MutationRootUpdateCoinSupplyByPkArgs = {
  _inc?: InputMaybe<CoinSupplyIncInput>;
  _set?: InputMaybe<CoinSupplySetInput>;
  pk_columns: CoinSupplyPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCoinSupplyManyArgs = {
  updates: Array<CoinSupplyUpdates>;
};

/** mutation root */
export type MutationRootUpdateCollectionDatasArgs = {
  _inc?: InputMaybe<CollectionDatasIncInput>;
  _set?: InputMaybe<CollectionDatasSetInput>;
  where: CollectionDatasBoolExp;
};

/** mutation root */
export type MutationRootUpdateCollectionDatasByPkArgs = {
  _inc?: InputMaybe<CollectionDatasIncInput>;
  _set?: InputMaybe<CollectionDatasSetInput>;
  pk_columns: CollectionDatasPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCollectionDatasManyArgs = {
  updates: Array<CollectionDatasUpdates>;
};

/** mutation root */
export type MutationRootUpdateCollectionsV2Args = {
  _append?: InputMaybe<CollectionsV2AppendInput>;
  _delete_at_path?: InputMaybe<CollectionsV2DeleteAtPathInput>;
  _delete_elem?: InputMaybe<CollectionsV2DeleteElemInput>;
  _delete_key?: InputMaybe<CollectionsV2DeleteKeyInput>;
  _inc?: InputMaybe<CollectionsV2IncInput>;
  _prepend?: InputMaybe<CollectionsV2PrependInput>;
  _set?: InputMaybe<CollectionsV2SetInput>;
  where: CollectionsV2BoolExp;
};

/** mutation root */
export type MutationRootUpdateCollectionsV2ByPkArgs = {
  _append?: InputMaybe<CollectionsV2AppendInput>;
  _delete_at_path?: InputMaybe<CollectionsV2DeleteAtPathInput>;
  _delete_elem?: InputMaybe<CollectionsV2DeleteElemInput>;
  _delete_key?: InputMaybe<CollectionsV2DeleteKeyInput>;
  _inc?: InputMaybe<CollectionsV2IncInput>;
  _prepend?: InputMaybe<CollectionsV2PrependInput>;
  _set?: InputMaybe<CollectionsV2SetInput>;
  pk_columns: CollectionsV2PkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCollectionsV2ManyArgs = {
  updates: Array<CollectionsV2Updates>;
};

/** mutation root */
export type MutationRootUpdateCurrentAnsLookupArgs = {
  _inc?: InputMaybe<CurrentAnsLookupIncInput>;
  _set?: InputMaybe<CurrentAnsLookupSetInput>;
  where: CurrentAnsLookupBoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentAnsLookupByPkArgs = {
  _inc?: InputMaybe<CurrentAnsLookupIncInput>;
  _set?: InputMaybe<CurrentAnsLookupSetInput>;
  pk_columns: CurrentAnsLookupPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCurrentAnsLookupManyArgs = {
  updates: Array<CurrentAnsLookupUpdates>;
};

/** mutation root */
export type MutationRootUpdateCurrentAnsLookupV2Args = {
  _inc?: InputMaybe<CurrentAnsLookupV2IncInput>;
  _set?: InputMaybe<CurrentAnsLookupV2SetInput>;
  where: CurrentAnsLookupV2BoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentAnsLookupV2ByPkArgs = {
  _inc?: InputMaybe<CurrentAnsLookupV2IncInput>;
  _set?: InputMaybe<CurrentAnsLookupV2SetInput>;
  pk_columns: CurrentAnsLookupV2PkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCurrentAnsLookupV2ManyArgs = {
  updates: Array<CurrentAnsLookupV2Updates>;
};

/** mutation root */
export type MutationRootUpdateCurrentAnsPrimaryNameArgs = {
  _inc?: InputMaybe<CurrentAnsPrimaryNameIncInput>;
  _set?: InputMaybe<CurrentAnsPrimaryNameSetInput>;
  where: CurrentAnsPrimaryNameBoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentAnsPrimaryNameByPkArgs = {
  _inc?: InputMaybe<CurrentAnsPrimaryNameIncInput>;
  _set?: InputMaybe<CurrentAnsPrimaryNameSetInput>;
  pk_columns: CurrentAnsPrimaryNamePkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCurrentAnsPrimaryNameManyArgs = {
  updates: Array<CurrentAnsPrimaryNameUpdates>;
};

/** mutation root */
export type MutationRootUpdateCurrentAnsPrimaryNameV2Args = {
  _inc?: InputMaybe<CurrentAnsPrimaryNameV2IncInput>;
  _set?: InputMaybe<CurrentAnsPrimaryNameV2SetInput>;
  where: CurrentAnsPrimaryNameV2BoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentAnsPrimaryNameV2ByPkArgs = {
  _inc?: InputMaybe<CurrentAnsPrimaryNameV2IncInput>;
  _set?: InputMaybe<CurrentAnsPrimaryNameV2SetInput>;
  pk_columns: CurrentAnsPrimaryNameV2PkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCurrentAnsPrimaryNameV2ManyArgs = {
  updates: Array<CurrentAnsPrimaryNameV2Updates>;
};

/** mutation root */
export type MutationRootUpdateCurrentCoinBalancesArgs = {
  _inc?: InputMaybe<CurrentCoinBalancesIncInput>;
  _set?: InputMaybe<CurrentCoinBalancesSetInput>;
  where: CurrentCoinBalancesBoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentCoinBalancesByPkArgs = {
  _inc?: InputMaybe<CurrentCoinBalancesIncInput>;
  _set?: InputMaybe<CurrentCoinBalancesSetInput>;
  pk_columns: CurrentCoinBalancesPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCurrentCoinBalancesManyArgs = {
  updates: Array<CurrentCoinBalancesUpdates>;
};

/** mutation root */
export type MutationRootUpdateCurrentCollectionDatasArgs = {
  _inc?: InputMaybe<CurrentCollectionDatasIncInput>;
  _set?: InputMaybe<CurrentCollectionDatasSetInput>;
  where: CurrentCollectionDatasBoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentCollectionDatasByPkArgs = {
  _inc?: InputMaybe<CurrentCollectionDatasIncInput>;
  _set?: InputMaybe<CurrentCollectionDatasSetInput>;
  pk_columns: CurrentCollectionDatasPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCurrentCollectionDatasManyArgs = {
  updates: Array<CurrentCollectionDatasUpdates>;
};

/** mutation root */
export type MutationRootUpdateCurrentCollectionsV2Args = {
  _append?: InputMaybe<CurrentCollectionsV2AppendInput>;
  _delete_at_path?: InputMaybe<CurrentCollectionsV2DeleteAtPathInput>;
  _delete_elem?: InputMaybe<CurrentCollectionsV2DeleteElemInput>;
  _delete_key?: InputMaybe<CurrentCollectionsV2DeleteKeyInput>;
  _inc?: InputMaybe<CurrentCollectionsV2IncInput>;
  _prepend?: InputMaybe<CurrentCollectionsV2PrependInput>;
  _set?: InputMaybe<CurrentCollectionsV2SetInput>;
  where: CurrentCollectionsV2BoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentCollectionsV2ByPkArgs = {
  _append?: InputMaybe<CurrentCollectionsV2AppendInput>;
  _delete_at_path?: InputMaybe<CurrentCollectionsV2DeleteAtPathInput>;
  _delete_elem?: InputMaybe<CurrentCollectionsV2DeleteElemInput>;
  _delete_key?: InputMaybe<CurrentCollectionsV2DeleteKeyInput>;
  _inc?: InputMaybe<CurrentCollectionsV2IncInput>;
  _prepend?: InputMaybe<CurrentCollectionsV2PrependInput>;
  _set?: InputMaybe<CurrentCollectionsV2SetInput>;
  pk_columns: CurrentCollectionsV2PkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCurrentCollectionsV2ManyArgs = {
  updates: Array<CurrentCollectionsV2Updates>;
};

/** mutation root */
export type MutationRootUpdateCurrentDelegatedStakingPoolBalancesArgs = {
  _inc?: InputMaybe<CurrentDelegatedStakingPoolBalancesIncInput>;
  _set?: InputMaybe<CurrentDelegatedStakingPoolBalancesSetInput>;
  where: CurrentDelegatedStakingPoolBalancesBoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentDelegatedStakingPoolBalancesByPkArgs = {
  _inc?: InputMaybe<CurrentDelegatedStakingPoolBalancesIncInput>;
  _set?: InputMaybe<CurrentDelegatedStakingPoolBalancesSetInput>;
  pk_columns: CurrentDelegatedStakingPoolBalancesPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCurrentDelegatedStakingPoolBalancesManyArgs = {
  updates: Array<CurrentDelegatedStakingPoolBalancesUpdates>;
};

/** mutation root */
export type MutationRootUpdateCurrentDelegatedVoterArgs = {
  _inc?: InputMaybe<CurrentDelegatedVoterIncInput>;
  _set?: InputMaybe<CurrentDelegatedVoterSetInput>;
  where: CurrentDelegatedVoterBoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentDelegatedVoterByPkArgs = {
  _inc?: InputMaybe<CurrentDelegatedVoterIncInput>;
  _set?: InputMaybe<CurrentDelegatedVoterSetInput>;
  pk_columns: CurrentDelegatedVoterPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCurrentDelegatedVoterManyArgs = {
  updates: Array<CurrentDelegatedVoterUpdates>;
};

/** mutation root */
export type MutationRootUpdateCurrentDelegatorBalancesArgs = {
  _inc?: InputMaybe<CurrentDelegatorBalancesIncInput>;
  _set?: InputMaybe<CurrentDelegatorBalancesSetInput>;
  where: CurrentDelegatorBalancesBoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentDelegatorBalancesByPkArgs = {
  _inc?: InputMaybe<CurrentDelegatorBalancesIncInput>;
  _set?: InputMaybe<CurrentDelegatorBalancesSetInput>;
  pk_columns: CurrentDelegatorBalancesPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCurrentDelegatorBalancesManyArgs = {
  updates: Array<CurrentDelegatorBalancesUpdates>;
};

/** mutation root */
export type MutationRootUpdateCurrentFungibleAssetBalancesArgs = {
  _inc?: InputMaybe<CurrentFungibleAssetBalancesIncInput>;
  _set?: InputMaybe<CurrentFungibleAssetBalancesSetInput>;
  where: CurrentFungibleAssetBalancesBoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentFungibleAssetBalancesByPkArgs = {
  _inc?: InputMaybe<CurrentFungibleAssetBalancesIncInput>;
  _set?: InputMaybe<CurrentFungibleAssetBalancesSetInput>;
  pk_columns: CurrentFungibleAssetBalancesPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCurrentFungibleAssetBalancesManyArgs = {
  updates: Array<CurrentFungibleAssetBalancesUpdates>;
};

/** mutation root */
export type MutationRootUpdateCurrentFungibleAssetBalancesNewArgs = {
  _inc?: InputMaybe<CurrentFungibleAssetBalancesNewIncInput>;
  _set?: InputMaybe<CurrentFungibleAssetBalancesNewSetInput>;
  where: CurrentFungibleAssetBalancesNewBoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentFungibleAssetBalancesNewByPkArgs = {
  _inc?: InputMaybe<CurrentFungibleAssetBalancesNewIncInput>;
  _set?: InputMaybe<CurrentFungibleAssetBalancesNewSetInput>;
  pk_columns: CurrentFungibleAssetBalancesNewPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCurrentFungibleAssetBalancesNewManyArgs = {
  updates: Array<CurrentFungibleAssetBalancesNewUpdates>;
};

/** mutation root */
export type MutationRootUpdateCurrentObjectsArgs = {
  _inc?: InputMaybe<CurrentObjectsIncInput>;
  _set?: InputMaybe<CurrentObjectsSetInput>;
  where: CurrentObjectsBoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentObjectsByPkArgs = {
  _inc?: InputMaybe<CurrentObjectsIncInput>;
  _set?: InputMaybe<CurrentObjectsSetInput>;
  pk_columns: CurrentObjectsPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCurrentObjectsManyArgs = {
  updates: Array<CurrentObjectsUpdates>;
};

/** mutation root */
export type MutationRootUpdateCurrentStakingPoolVoterArgs = {
  _inc?: InputMaybe<CurrentStakingPoolVoterIncInput>;
  _set?: InputMaybe<CurrentStakingPoolVoterSetInput>;
  where: CurrentStakingPoolVoterBoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentStakingPoolVoterByPkArgs = {
  _inc?: InputMaybe<CurrentStakingPoolVoterIncInput>;
  _set?: InputMaybe<CurrentStakingPoolVoterSetInput>;
  pk_columns: CurrentStakingPoolVoterPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCurrentStakingPoolVoterManyArgs = {
  updates: Array<CurrentStakingPoolVoterUpdates>;
};

/** mutation root */
export type MutationRootUpdateCurrentTableItemsArgs = {
  _append?: InputMaybe<CurrentTableItemsAppendInput>;
  _delete_at_path?: InputMaybe<CurrentTableItemsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<CurrentTableItemsDeleteElemInput>;
  _delete_key?: InputMaybe<CurrentTableItemsDeleteKeyInput>;
  _inc?: InputMaybe<CurrentTableItemsIncInput>;
  _prepend?: InputMaybe<CurrentTableItemsPrependInput>;
  _set?: InputMaybe<CurrentTableItemsSetInput>;
  where: CurrentTableItemsBoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentTableItemsByPkArgs = {
  _append?: InputMaybe<CurrentTableItemsAppendInput>;
  _delete_at_path?: InputMaybe<CurrentTableItemsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<CurrentTableItemsDeleteElemInput>;
  _delete_key?: InputMaybe<CurrentTableItemsDeleteKeyInput>;
  _inc?: InputMaybe<CurrentTableItemsIncInput>;
  _prepend?: InputMaybe<CurrentTableItemsPrependInput>;
  _set?: InputMaybe<CurrentTableItemsSetInput>;
  pk_columns: CurrentTableItemsPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCurrentTableItemsManyArgs = {
  updates: Array<CurrentTableItemsUpdates>;
};

/** mutation root */
export type MutationRootUpdateCurrentTableItemsViewArgs = {
  _inc?: InputMaybe<CurrentTableItemsViewIncInput>;
  _set?: InputMaybe<CurrentTableItemsViewSetInput>;
  where: CurrentTableItemsViewBoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentTableItemsViewManyArgs = {
  updates: Array<CurrentTableItemsViewUpdates>;
};

/** mutation root */
export type MutationRootUpdateCurrentTokenDatasArgs = {
  _append?: InputMaybe<CurrentTokenDatasAppendInput>;
  _delete_at_path?: InputMaybe<CurrentTokenDatasDeleteAtPathInput>;
  _delete_elem?: InputMaybe<CurrentTokenDatasDeleteElemInput>;
  _delete_key?: InputMaybe<CurrentTokenDatasDeleteKeyInput>;
  _inc?: InputMaybe<CurrentTokenDatasIncInput>;
  _prepend?: InputMaybe<CurrentTokenDatasPrependInput>;
  _set?: InputMaybe<CurrentTokenDatasSetInput>;
  where: CurrentTokenDatasBoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentTokenDatasByPkArgs = {
  _append?: InputMaybe<CurrentTokenDatasAppendInput>;
  _delete_at_path?: InputMaybe<CurrentTokenDatasDeleteAtPathInput>;
  _delete_elem?: InputMaybe<CurrentTokenDatasDeleteElemInput>;
  _delete_key?: InputMaybe<CurrentTokenDatasDeleteKeyInput>;
  _inc?: InputMaybe<CurrentTokenDatasIncInput>;
  _prepend?: InputMaybe<CurrentTokenDatasPrependInput>;
  _set?: InputMaybe<CurrentTokenDatasSetInput>;
  pk_columns: CurrentTokenDatasPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCurrentTokenDatasManyArgs = {
  updates: Array<CurrentTokenDatasUpdates>;
};

/** mutation root */
export type MutationRootUpdateCurrentTokenDatasV2Args = {
  _append?: InputMaybe<CurrentTokenDatasV2AppendInput>;
  _delete_at_path?: InputMaybe<CurrentTokenDatasV2DeleteAtPathInput>;
  _delete_elem?: InputMaybe<CurrentTokenDatasV2DeleteElemInput>;
  _delete_key?: InputMaybe<CurrentTokenDatasV2DeleteKeyInput>;
  _inc?: InputMaybe<CurrentTokenDatasV2IncInput>;
  _prepend?: InputMaybe<CurrentTokenDatasV2PrependInput>;
  _set?: InputMaybe<CurrentTokenDatasV2SetInput>;
  where: CurrentTokenDatasV2BoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentTokenDatasV2ByPkArgs = {
  _append?: InputMaybe<CurrentTokenDatasV2AppendInput>;
  _delete_at_path?: InputMaybe<CurrentTokenDatasV2DeleteAtPathInput>;
  _delete_elem?: InputMaybe<CurrentTokenDatasV2DeleteElemInput>;
  _delete_key?: InputMaybe<CurrentTokenDatasV2DeleteKeyInput>;
  _inc?: InputMaybe<CurrentTokenDatasV2IncInput>;
  _prepend?: InputMaybe<CurrentTokenDatasV2PrependInput>;
  _set?: InputMaybe<CurrentTokenDatasV2SetInput>;
  pk_columns: CurrentTokenDatasV2PkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCurrentTokenDatasV2ManyArgs = {
  updates: Array<CurrentTokenDatasV2Updates>;
};

/** mutation root */
export type MutationRootUpdateCurrentTokenOwnershipsArgs = {
  _append?: InputMaybe<CurrentTokenOwnershipsAppendInput>;
  _delete_at_path?: InputMaybe<CurrentTokenOwnershipsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<CurrentTokenOwnershipsDeleteElemInput>;
  _delete_key?: InputMaybe<CurrentTokenOwnershipsDeleteKeyInput>;
  _inc?: InputMaybe<CurrentTokenOwnershipsIncInput>;
  _prepend?: InputMaybe<CurrentTokenOwnershipsPrependInput>;
  _set?: InputMaybe<CurrentTokenOwnershipsSetInput>;
  where: CurrentTokenOwnershipsBoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentTokenOwnershipsByPkArgs = {
  _append?: InputMaybe<CurrentTokenOwnershipsAppendInput>;
  _delete_at_path?: InputMaybe<CurrentTokenOwnershipsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<CurrentTokenOwnershipsDeleteElemInput>;
  _delete_key?: InputMaybe<CurrentTokenOwnershipsDeleteKeyInput>;
  _inc?: InputMaybe<CurrentTokenOwnershipsIncInput>;
  _prepend?: InputMaybe<CurrentTokenOwnershipsPrependInput>;
  _set?: InputMaybe<CurrentTokenOwnershipsSetInput>;
  pk_columns: CurrentTokenOwnershipsPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCurrentTokenOwnershipsManyArgs = {
  updates: Array<CurrentTokenOwnershipsUpdates>;
};

/** mutation root */
export type MutationRootUpdateCurrentTokenOwnershipsV2Args = {
  _append?: InputMaybe<CurrentTokenOwnershipsV2AppendInput>;
  _delete_at_path?: InputMaybe<CurrentTokenOwnershipsV2DeleteAtPathInput>;
  _delete_elem?: InputMaybe<CurrentTokenOwnershipsV2DeleteElemInput>;
  _delete_key?: InputMaybe<CurrentTokenOwnershipsV2DeleteKeyInput>;
  _inc?: InputMaybe<CurrentTokenOwnershipsV2IncInput>;
  _prepend?: InputMaybe<CurrentTokenOwnershipsV2PrependInput>;
  _set?: InputMaybe<CurrentTokenOwnershipsV2SetInput>;
  where: CurrentTokenOwnershipsV2BoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentTokenOwnershipsV2ByPkArgs = {
  _append?: InputMaybe<CurrentTokenOwnershipsV2AppendInput>;
  _delete_at_path?: InputMaybe<CurrentTokenOwnershipsV2DeleteAtPathInput>;
  _delete_elem?: InputMaybe<CurrentTokenOwnershipsV2DeleteElemInput>;
  _delete_key?: InputMaybe<CurrentTokenOwnershipsV2DeleteKeyInput>;
  _inc?: InputMaybe<CurrentTokenOwnershipsV2IncInput>;
  _prepend?: InputMaybe<CurrentTokenOwnershipsV2PrependInput>;
  _set?: InputMaybe<CurrentTokenOwnershipsV2SetInput>;
  pk_columns: CurrentTokenOwnershipsV2PkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCurrentTokenOwnershipsV2ManyArgs = {
  updates: Array<CurrentTokenOwnershipsV2Updates>;
};

/** mutation root */
export type MutationRootUpdateCurrentTokenPendingClaimsArgs = {
  _inc?: InputMaybe<CurrentTokenPendingClaimsIncInput>;
  _set?: InputMaybe<CurrentTokenPendingClaimsSetInput>;
  where: CurrentTokenPendingClaimsBoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentTokenPendingClaimsByPkArgs = {
  _inc?: InputMaybe<CurrentTokenPendingClaimsIncInput>;
  _set?: InputMaybe<CurrentTokenPendingClaimsSetInput>;
  pk_columns: CurrentTokenPendingClaimsPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCurrentTokenPendingClaimsManyArgs = {
  updates: Array<CurrentTokenPendingClaimsUpdates>;
};

/** mutation root */
export type MutationRootUpdateCurrentTokenRoyaltyV1Args = {
  _inc?: InputMaybe<CurrentTokenRoyaltyV1IncInput>;
  _set?: InputMaybe<CurrentTokenRoyaltyV1SetInput>;
  where: CurrentTokenRoyaltyV1BoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentTokenRoyaltyV1ByPkArgs = {
  _inc?: InputMaybe<CurrentTokenRoyaltyV1IncInput>;
  _set?: InputMaybe<CurrentTokenRoyaltyV1SetInput>;
  pk_columns: CurrentTokenRoyaltyV1PkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCurrentTokenRoyaltyV1ManyArgs = {
  updates: Array<CurrentTokenRoyaltyV1Updates>;
};

/** mutation root */
export type MutationRootUpdateCurrentTokenV2MetadataArgs = {
  _append?: InputMaybe<CurrentTokenV2MetadataAppendInput>;
  _delete_at_path?: InputMaybe<CurrentTokenV2MetadataDeleteAtPathInput>;
  _delete_elem?: InputMaybe<CurrentTokenV2MetadataDeleteElemInput>;
  _delete_key?: InputMaybe<CurrentTokenV2MetadataDeleteKeyInput>;
  _inc?: InputMaybe<CurrentTokenV2MetadataIncInput>;
  _prepend?: InputMaybe<CurrentTokenV2MetadataPrependInput>;
  _set?: InputMaybe<CurrentTokenV2MetadataSetInput>;
  where: CurrentTokenV2MetadataBoolExp;
};

/** mutation root */
export type MutationRootUpdateCurrentTokenV2MetadataByPkArgs = {
  _append?: InputMaybe<CurrentTokenV2MetadataAppendInput>;
  _delete_at_path?: InputMaybe<CurrentTokenV2MetadataDeleteAtPathInput>;
  _delete_elem?: InputMaybe<CurrentTokenV2MetadataDeleteElemInput>;
  _delete_key?: InputMaybe<CurrentTokenV2MetadataDeleteKeyInput>;
  _inc?: InputMaybe<CurrentTokenV2MetadataIncInput>;
  _prepend?: InputMaybe<CurrentTokenV2MetadataPrependInput>;
  _set?: InputMaybe<CurrentTokenV2MetadataSetInput>;
  pk_columns: CurrentTokenV2MetadataPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateCurrentTokenV2MetadataManyArgs = {
  updates: Array<CurrentTokenV2MetadataUpdates>;
};

/** mutation root */
export type MutationRootUpdateDelegatedStakingActivitiesArgs = {
  _inc?: InputMaybe<DelegatedStakingActivitiesIncInput>;
  _set?: InputMaybe<DelegatedStakingActivitiesSetInput>;
  where: DelegatedStakingActivitiesBoolExp;
};

/** mutation root */
export type MutationRootUpdateDelegatedStakingActivitiesByPkArgs = {
  _inc?: InputMaybe<DelegatedStakingActivitiesIncInput>;
  _set?: InputMaybe<DelegatedStakingActivitiesSetInput>;
  pk_columns: DelegatedStakingActivitiesPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateDelegatedStakingActivitiesManyArgs = {
  updates: Array<DelegatedStakingActivitiesUpdates>;
};

/** mutation root */
export type MutationRootUpdateDelegatedStakingPoolBalancesArgs = {
  _inc?: InputMaybe<DelegatedStakingPoolBalancesIncInput>;
  _set?: InputMaybe<DelegatedStakingPoolBalancesSetInput>;
  where: DelegatedStakingPoolBalancesBoolExp;
};

/** mutation root */
export type MutationRootUpdateDelegatedStakingPoolBalancesByPkArgs = {
  _inc?: InputMaybe<DelegatedStakingPoolBalancesIncInput>;
  _set?: InputMaybe<DelegatedStakingPoolBalancesSetInput>;
  pk_columns: DelegatedStakingPoolBalancesPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateDelegatedStakingPoolBalancesManyArgs = {
  updates: Array<DelegatedStakingPoolBalancesUpdates>;
};

/** mutation root */
export type MutationRootUpdateDelegatedStakingPoolsArgs = {
  _inc?: InputMaybe<DelegatedStakingPoolsIncInput>;
  _set?: InputMaybe<DelegatedStakingPoolsSetInput>;
  where: DelegatedStakingPoolsBoolExp;
};

/** mutation root */
export type MutationRootUpdateDelegatedStakingPoolsByPkArgs = {
  _inc?: InputMaybe<DelegatedStakingPoolsIncInput>;
  _set?: InputMaybe<DelegatedStakingPoolsSetInput>;
  pk_columns: DelegatedStakingPoolsPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateDelegatedStakingPoolsManyArgs = {
  updates: Array<DelegatedStakingPoolsUpdates>;
};

/** mutation root */
export type MutationRootUpdateDelegatorBalancesArgs = {
  _inc?: InputMaybe<DelegatorBalancesIncInput>;
  _set?: InputMaybe<DelegatorBalancesSetInput>;
  where: DelegatorBalancesBoolExp;
};

/** mutation root */
export type MutationRootUpdateDelegatorBalancesByPkArgs = {
  _inc?: InputMaybe<DelegatorBalancesIncInput>;
  _set?: InputMaybe<DelegatorBalancesSetInput>;
  pk_columns: DelegatorBalancesPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateDelegatorBalancesManyArgs = {
  updates: Array<DelegatorBalancesUpdates>;
};

/** mutation root */
export type MutationRootUpdateEventSizeInfoArgs = {
  _inc?: InputMaybe<EventSizeInfoIncInput>;
  _set?: InputMaybe<EventSizeInfoSetInput>;
  where: EventSizeInfoBoolExp;
};

/** mutation root */
export type MutationRootUpdateEventSizeInfoByPkArgs = {
  _inc?: InputMaybe<EventSizeInfoIncInput>;
  _set?: InputMaybe<EventSizeInfoSetInput>;
  pk_columns: EventSizeInfoPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateEventSizeInfoManyArgs = {
  updates: Array<EventSizeInfoUpdates>;
};

/** mutation root */
export type MutationRootUpdateEventsArgs = {
  _append?: InputMaybe<EventsAppendInput>;
  _delete_at_path?: InputMaybe<EventsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<EventsDeleteElemInput>;
  _delete_key?: InputMaybe<EventsDeleteKeyInput>;
  _inc?: InputMaybe<EventsIncInput>;
  _prepend?: InputMaybe<EventsPrependInput>;
  _set?: InputMaybe<EventsSetInput>;
  where: EventsBoolExp;
};

/** mutation root */
export type MutationRootUpdateEventsByPkArgs = {
  _append?: InputMaybe<EventsAppendInput>;
  _delete_at_path?: InputMaybe<EventsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<EventsDeleteElemInput>;
  _delete_key?: InputMaybe<EventsDeleteKeyInput>;
  _inc?: InputMaybe<EventsIncInput>;
  _prepend?: InputMaybe<EventsPrependInput>;
  _set?: InputMaybe<EventsSetInput>;
  pk_columns: EventsPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateEventsManyArgs = {
  updates: Array<EventsUpdates>;
};

/** mutation root */
export type MutationRootUpdateEventsViewArgs = {
  _inc?: InputMaybe<EventsViewIncInput>;
  _set?: InputMaybe<EventsViewSetInput>;
  where: EventsViewBoolExp;
};

/** mutation root */
export type MutationRootUpdateEventsViewManyArgs = {
  updates: Array<EventsViewUpdates>;
};

/** mutation root */
export type MutationRootUpdateFungibleAssetActivitiesArgs = {
  _inc?: InputMaybe<FungibleAssetActivitiesIncInput>;
  _set?: InputMaybe<FungibleAssetActivitiesSetInput>;
  where: FungibleAssetActivitiesBoolExp;
};

/** mutation root */
export type MutationRootUpdateFungibleAssetActivitiesByPkArgs = {
  _inc?: InputMaybe<FungibleAssetActivitiesIncInput>;
  _set?: InputMaybe<FungibleAssetActivitiesSetInput>;
  pk_columns: FungibleAssetActivitiesPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateFungibleAssetActivitiesManyArgs = {
  updates: Array<FungibleAssetActivitiesUpdates>;
};

/** mutation root */
export type MutationRootUpdateFungibleAssetBalancesArgs = {
  _inc?: InputMaybe<FungibleAssetBalancesIncInput>;
  _set?: InputMaybe<FungibleAssetBalancesSetInput>;
  where: FungibleAssetBalancesBoolExp;
};

/** mutation root */
export type MutationRootUpdateFungibleAssetBalancesByPkArgs = {
  _inc?: InputMaybe<FungibleAssetBalancesIncInput>;
  _set?: InputMaybe<FungibleAssetBalancesSetInput>;
  pk_columns: FungibleAssetBalancesPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateFungibleAssetBalancesManyArgs = {
  updates: Array<FungibleAssetBalancesUpdates>;
};

/** mutation root */
export type MutationRootUpdateFungibleAssetMetadataArgs = {
  _inc?: InputMaybe<FungibleAssetMetadataIncInput>;
  _set?: InputMaybe<FungibleAssetMetadataSetInput>;
  where: FungibleAssetMetadataBoolExp;
};

/** mutation root */
export type MutationRootUpdateFungibleAssetMetadataByPkArgs = {
  _inc?: InputMaybe<FungibleAssetMetadataIncInput>;
  _set?: InputMaybe<FungibleAssetMetadataSetInput>;
  pk_columns: FungibleAssetMetadataPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateFungibleAssetMetadataManyArgs = {
  updates: Array<FungibleAssetMetadataUpdates>;
};

/** mutation root */
export type MutationRootUpdateFungibleAssetToCoinMappingsArgs = {
  _inc?: InputMaybe<FungibleAssetToCoinMappingsIncInput>;
  _set?: InputMaybe<FungibleAssetToCoinMappingsSetInput>;
  where: FungibleAssetToCoinMappingsBoolExp;
};

/** mutation root */
export type MutationRootUpdateFungibleAssetToCoinMappingsByPkArgs = {
  _inc?: InputMaybe<FungibleAssetToCoinMappingsIncInput>;
  _set?: InputMaybe<FungibleAssetToCoinMappingsSetInput>;
  pk_columns: FungibleAssetToCoinMappingsPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateFungibleAssetToCoinMappingsManyArgs = {
  updates: Array<FungibleAssetToCoinMappingsUpdates>;
};

/** mutation root */
export type MutationRootUpdateGasFeesArgs = {
  _inc?: InputMaybe<GasFeesIncInput>;
  _set?: InputMaybe<GasFeesSetInput>;
  where: GasFeesBoolExp;
};

/** mutation root */
export type MutationRootUpdateGasFeesByPkArgs = {
  _inc?: InputMaybe<GasFeesIncInput>;
  _set?: InputMaybe<GasFeesSetInput>;
  pk_columns: GasFeesPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateGasFeesManyArgs = {
  updates: Array<GasFeesUpdates>;
};

/** mutation root */
export type MutationRootUpdateIndexerStatusArgs = {
  _set?: InputMaybe<IndexerStatusSetInput>;
  where: IndexerStatusBoolExp;
};

/** mutation root */
export type MutationRootUpdateIndexerStatusByPkArgs = {
  _set?: InputMaybe<IndexerStatusSetInput>;
  pk_columns: IndexerStatusPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateIndexerStatusManyArgs = {
  updates: Array<IndexerStatusUpdates>;
};

/** mutation root */
export type MutationRootUpdateMoveModulesArgs = {
  _append?: InputMaybe<MoveModulesAppendInput>;
  _delete_at_path?: InputMaybe<MoveModulesDeleteAtPathInput>;
  _delete_elem?: InputMaybe<MoveModulesDeleteElemInput>;
  _delete_key?: InputMaybe<MoveModulesDeleteKeyInput>;
  _inc?: InputMaybe<MoveModulesIncInput>;
  _prepend?: InputMaybe<MoveModulesPrependInput>;
  _set?: InputMaybe<MoveModulesSetInput>;
  where: MoveModulesBoolExp;
};

/** mutation root */
export type MutationRootUpdateMoveModulesByPkArgs = {
  _append?: InputMaybe<MoveModulesAppendInput>;
  _delete_at_path?: InputMaybe<MoveModulesDeleteAtPathInput>;
  _delete_elem?: InputMaybe<MoveModulesDeleteElemInput>;
  _delete_key?: InputMaybe<MoveModulesDeleteKeyInput>;
  _inc?: InputMaybe<MoveModulesIncInput>;
  _prepend?: InputMaybe<MoveModulesPrependInput>;
  _set?: InputMaybe<MoveModulesSetInput>;
  pk_columns: MoveModulesPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateMoveModulesManyArgs = {
  updates: Array<MoveModulesUpdates>;
};

/** mutation root */
export type MutationRootUpdateMoveResourcesArgs = {
  _append?: InputMaybe<MoveResourcesAppendInput>;
  _delete_at_path?: InputMaybe<MoveResourcesDeleteAtPathInput>;
  _delete_elem?: InputMaybe<MoveResourcesDeleteElemInput>;
  _delete_key?: InputMaybe<MoveResourcesDeleteKeyInput>;
  _inc?: InputMaybe<MoveResourcesIncInput>;
  _prepend?: InputMaybe<MoveResourcesPrependInput>;
  _set?: InputMaybe<MoveResourcesSetInput>;
  where: MoveResourcesBoolExp;
};

/** mutation root */
export type MutationRootUpdateMoveResourcesByPkArgs = {
  _append?: InputMaybe<MoveResourcesAppendInput>;
  _delete_at_path?: InputMaybe<MoveResourcesDeleteAtPathInput>;
  _delete_elem?: InputMaybe<MoveResourcesDeleteElemInput>;
  _delete_key?: InputMaybe<MoveResourcesDeleteKeyInput>;
  _inc?: InputMaybe<MoveResourcesIncInput>;
  _prepend?: InputMaybe<MoveResourcesPrependInput>;
  _set?: InputMaybe<MoveResourcesSetInput>;
  pk_columns: MoveResourcesPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateMoveResourcesManyArgs = {
  updates: Array<MoveResourcesUpdates>;
};

/** mutation root */
export type MutationRootUpdateMoveResourcesViewArgs = {
  _append?: InputMaybe<MoveResourcesViewAppendInput>;
  _delete_at_path?: InputMaybe<MoveResourcesViewDeleteAtPathInput>;
  _delete_elem?: InputMaybe<MoveResourcesViewDeleteElemInput>;
  _delete_key?: InputMaybe<MoveResourcesViewDeleteKeyInput>;
  _inc?: InputMaybe<MoveResourcesViewIncInput>;
  _prepend?: InputMaybe<MoveResourcesViewPrependInput>;
  _set?: InputMaybe<MoveResourcesViewSetInput>;
  where: MoveResourcesViewBoolExp;
};

/** mutation root */
export type MutationRootUpdateMoveResourcesViewManyArgs = {
  updates: Array<MoveResourcesViewUpdates>;
};

/** mutation root */
export type MutationRootUpdateNftMetadataCrawlerParsedAssetUrisArgs = {
  _inc?: InputMaybe<NftMetadataCrawlerParsedAssetUrisIncInput>;
  _set?: InputMaybe<NftMetadataCrawlerParsedAssetUrisSetInput>;
  where: NftMetadataCrawlerParsedAssetUrisBoolExp;
};

/** mutation root */
export type MutationRootUpdateNftMetadataCrawlerParsedAssetUrisByPkArgs = {
  _inc?: InputMaybe<NftMetadataCrawlerParsedAssetUrisIncInput>;
  _set?: InputMaybe<NftMetadataCrawlerParsedAssetUrisSetInput>;
  pk_columns: NftMetadataCrawlerParsedAssetUrisPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateNftMetadataCrawlerParsedAssetUrisManyArgs = {
  updates: Array<NftMetadataCrawlerParsedAssetUrisUpdates>;
};

/** mutation root */
export type MutationRootUpdateNftPointsArgs = {
  _inc?: InputMaybe<NftPointsIncInput>;
  _set?: InputMaybe<NftPointsSetInput>;
  where: NftPointsBoolExp;
};

/** mutation root */
export type MutationRootUpdateNftPointsByPkArgs = {
  _inc?: InputMaybe<NftPointsIncInput>;
  _set?: InputMaybe<NftPointsSetInput>;
  pk_columns: NftPointsPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateNftPointsManyArgs = {
  updates: Array<NftPointsUpdates>;
};

/** mutation root */
export type MutationRootUpdateObjectsArgs = {
  _inc?: InputMaybe<ObjectsIncInput>;
  _set?: InputMaybe<ObjectsSetInput>;
  where: ObjectsBoolExp;
};

/** mutation root */
export type MutationRootUpdateObjectsByPkArgs = {
  _inc?: InputMaybe<ObjectsIncInput>;
  _set?: InputMaybe<ObjectsSetInput>;
  pk_columns: ObjectsPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateObjectsManyArgs = {
  updates: Array<ObjectsUpdates>;
};

/** mutation root */
export type MutationRootUpdateProcessorMetadataProcessorStatusArgs = {
  _inc?: InputMaybe<ProcessorMetadataProcessorStatusIncInput>;
  _set?: InputMaybe<ProcessorMetadataProcessorStatusSetInput>;
  where: ProcessorMetadataProcessorStatusBoolExp;
};

/** mutation root */
export type MutationRootUpdateProcessorMetadataProcessorStatusByPkArgs = {
  _inc?: InputMaybe<ProcessorMetadataProcessorStatusIncInput>;
  _set?: InputMaybe<ProcessorMetadataProcessorStatusSetInput>;
  pk_columns: ProcessorMetadataProcessorStatusPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateProcessorMetadataProcessorStatusManyArgs = {
  updates: Array<ProcessorMetadataProcessorStatusUpdates>;
};

/** mutation root */
export type MutationRootUpdateProcessorStatusArgs = {
  _inc?: InputMaybe<ProcessorStatusIncInput>;
  _set?: InputMaybe<ProcessorStatusSetInput>;
  where: ProcessorStatusBoolExp;
};

/** mutation root */
export type MutationRootUpdateProcessorStatusByPkArgs = {
  _inc?: InputMaybe<ProcessorStatusIncInput>;
  _set?: InputMaybe<ProcessorStatusSetInput>;
  pk_columns: ProcessorStatusPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateProcessorStatusManyArgs = {
  updates: Array<ProcessorStatusUpdates>;
};

/** mutation root */
export type MutationRootUpdateProposalVotesArgs = {
  _inc?: InputMaybe<ProposalVotesIncInput>;
  _set?: InputMaybe<ProposalVotesSetInput>;
  where: ProposalVotesBoolExp;
};

/** mutation root */
export type MutationRootUpdateProposalVotesByPkArgs = {
  _inc?: InputMaybe<ProposalVotesIncInput>;
  _set?: InputMaybe<ProposalVotesSetInput>;
  pk_columns: ProposalVotesPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateProposalVotesManyArgs = {
  updates: Array<ProposalVotesUpdates>;
};

/** mutation root */
export type MutationRootUpdatePublicKeyAuthKeysArgs = {
  _inc?: InputMaybe<PublicKeyAuthKeysIncInput>;
  _set?: InputMaybe<PublicKeyAuthKeysSetInput>;
  where: PublicKeyAuthKeysBoolExp;
};

/** mutation root */
export type MutationRootUpdatePublicKeyAuthKeysByPkArgs = {
  _inc?: InputMaybe<PublicKeyAuthKeysIncInput>;
  _set?: InputMaybe<PublicKeyAuthKeysSetInput>;
  pk_columns: PublicKeyAuthKeysPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdatePublicKeyAuthKeysManyArgs = {
  updates: Array<PublicKeyAuthKeysUpdates>;
};

/** mutation root */
export type MutationRootUpdateSignaturesArgs = {
  _append?: InputMaybe<SignaturesAppendInput>;
  _delete_at_path?: InputMaybe<SignaturesDeleteAtPathInput>;
  _delete_elem?: InputMaybe<SignaturesDeleteElemInput>;
  _delete_key?: InputMaybe<SignaturesDeleteKeyInput>;
  _inc?: InputMaybe<SignaturesIncInput>;
  _prepend?: InputMaybe<SignaturesPrependInput>;
  _set?: InputMaybe<SignaturesSetInput>;
  where: SignaturesBoolExp;
};

/** mutation root */
export type MutationRootUpdateSignaturesByPkArgs = {
  _append?: InputMaybe<SignaturesAppendInput>;
  _delete_at_path?: InputMaybe<SignaturesDeleteAtPathInput>;
  _delete_elem?: InputMaybe<SignaturesDeleteElemInput>;
  _delete_key?: InputMaybe<SignaturesDeleteKeyInput>;
  _inc?: InputMaybe<SignaturesIncInput>;
  _prepend?: InputMaybe<SignaturesPrependInput>;
  _set?: InputMaybe<SignaturesSetInput>;
  pk_columns: SignaturesPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateSignaturesManyArgs = {
  updates: Array<SignaturesUpdates>;
};

/** mutation root */
export type MutationRootUpdateSpamAssetsArgs = {
  _set?: InputMaybe<SpamAssetsSetInput>;
  where: SpamAssetsBoolExp;
};

/** mutation root */
export type MutationRootUpdateSpamAssetsByPkArgs = {
  _set?: InputMaybe<SpamAssetsSetInput>;
  pk_columns: SpamAssetsPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateSpamAssetsManyArgs = {
  updates: Array<SpamAssetsUpdates>;
};

/** mutation root */
export type MutationRootUpdateTableItemsArgs = {
  _append?: InputMaybe<TableItemsAppendInput>;
  _delete_at_path?: InputMaybe<TableItemsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<TableItemsDeleteElemInput>;
  _delete_key?: InputMaybe<TableItemsDeleteKeyInput>;
  _inc?: InputMaybe<TableItemsIncInput>;
  _prepend?: InputMaybe<TableItemsPrependInput>;
  _set?: InputMaybe<TableItemsSetInput>;
  where: TableItemsBoolExp;
};

/** mutation root */
export type MutationRootUpdateTableItemsByPkArgs = {
  _append?: InputMaybe<TableItemsAppendInput>;
  _delete_at_path?: InputMaybe<TableItemsDeleteAtPathInput>;
  _delete_elem?: InputMaybe<TableItemsDeleteElemInput>;
  _delete_key?: InputMaybe<TableItemsDeleteKeyInput>;
  _inc?: InputMaybe<TableItemsIncInput>;
  _prepend?: InputMaybe<TableItemsPrependInput>;
  _set?: InputMaybe<TableItemsSetInput>;
  pk_columns: TableItemsPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateTableItemsManyArgs = {
  updates: Array<TableItemsUpdates>;
};

/** mutation root */
export type MutationRootUpdateTableItemsViewArgs = {
  _inc?: InputMaybe<TableItemsViewIncInput>;
  _set?: InputMaybe<TableItemsViewSetInput>;
  where: TableItemsViewBoolExp;
};

/** mutation root */
export type MutationRootUpdateTableItemsViewManyArgs = {
  updates: Array<TableItemsViewUpdates>;
};

/** mutation root */
export type MutationRootUpdateTableMetadatasArgs = {
  _set?: InputMaybe<TableMetadatasSetInput>;
  where: TableMetadatasBoolExp;
};

/** mutation root */
export type MutationRootUpdateTableMetadatasByPkArgs = {
  _set?: InputMaybe<TableMetadatasSetInput>;
  pk_columns: TableMetadatasPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateTableMetadatasManyArgs = {
  updates: Array<TableMetadatasUpdates>;
};

/** mutation root */
export type MutationRootUpdateTokenActivitiesArgs = {
  _inc?: InputMaybe<TokenActivitiesIncInput>;
  _set?: InputMaybe<TokenActivitiesSetInput>;
  where: TokenActivitiesBoolExp;
};

/** mutation root */
export type MutationRootUpdateTokenActivitiesByPkArgs = {
  _inc?: InputMaybe<TokenActivitiesIncInput>;
  _set?: InputMaybe<TokenActivitiesSetInput>;
  pk_columns: TokenActivitiesPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateTokenActivitiesManyArgs = {
  updates: Array<TokenActivitiesUpdates>;
};

/** mutation root */
export type MutationRootUpdateTokenActivitiesV2Args = {
  _inc?: InputMaybe<TokenActivitiesV2IncInput>;
  _set?: InputMaybe<TokenActivitiesV2SetInput>;
  where: TokenActivitiesV2BoolExp;
};

/** mutation root */
export type MutationRootUpdateTokenActivitiesV2ByPkArgs = {
  _inc?: InputMaybe<TokenActivitiesV2IncInput>;
  _set?: InputMaybe<TokenActivitiesV2SetInput>;
  pk_columns: TokenActivitiesV2PkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateTokenActivitiesV2ManyArgs = {
  updates: Array<TokenActivitiesV2Updates>;
};

/** mutation root */
export type MutationRootUpdateTokenDatasArgs = {
  _append?: InputMaybe<TokenDatasAppendInput>;
  _delete_at_path?: InputMaybe<TokenDatasDeleteAtPathInput>;
  _delete_elem?: InputMaybe<TokenDatasDeleteElemInput>;
  _delete_key?: InputMaybe<TokenDatasDeleteKeyInput>;
  _inc?: InputMaybe<TokenDatasIncInput>;
  _prepend?: InputMaybe<TokenDatasPrependInput>;
  _set?: InputMaybe<TokenDatasSetInput>;
  where: TokenDatasBoolExp;
};

/** mutation root */
export type MutationRootUpdateTokenDatasByPkArgs = {
  _append?: InputMaybe<TokenDatasAppendInput>;
  _delete_at_path?: InputMaybe<TokenDatasDeleteAtPathInput>;
  _delete_elem?: InputMaybe<TokenDatasDeleteElemInput>;
  _delete_key?: InputMaybe<TokenDatasDeleteKeyInput>;
  _inc?: InputMaybe<TokenDatasIncInput>;
  _prepend?: InputMaybe<TokenDatasPrependInput>;
  _set?: InputMaybe<TokenDatasSetInput>;
  pk_columns: TokenDatasPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateTokenDatasManyArgs = {
  updates: Array<TokenDatasUpdates>;
};

/** mutation root */
export type MutationRootUpdateTokenDatasV2Args = {
  _append?: InputMaybe<TokenDatasV2AppendInput>;
  _delete_at_path?: InputMaybe<TokenDatasV2DeleteAtPathInput>;
  _delete_elem?: InputMaybe<TokenDatasV2DeleteElemInput>;
  _delete_key?: InputMaybe<TokenDatasV2DeleteKeyInput>;
  _inc?: InputMaybe<TokenDatasV2IncInput>;
  _prepend?: InputMaybe<TokenDatasV2PrependInput>;
  _set?: InputMaybe<TokenDatasV2SetInput>;
  where: TokenDatasV2BoolExp;
};

/** mutation root */
export type MutationRootUpdateTokenDatasV2ByPkArgs = {
  _append?: InputMaybe<TokenDatasV2AppendInput>;
  _delete_at_path?: InputMaybe<TokenDatasV2DeleteAtPathInput>;
  _delete_elem?: InputMaybe<TokenDatasV2DeleteElemInput>;
  _delete_key?: InputMaybe<TokenDatasV2DeleteKeyInput>;
  _inc?: InputMaybe<TokenDatasV2IncInput>;
  _prepend?: InputMaybe<TokenDatasV2PrependInput>;
  _set?: InputMaybe<TokenDatasV2SetInput>;
  pk_columns: TokenDatasV2PkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateTokenDatasV2ManyArgs = {
  updates: Array<TokenDatasV2Updates>;
};

/** mutation root */
export type MutationRootUpdateTokenOwnershipsArgs = {
  _inc?: InputMaybe<TokenOwnershipsIncInput>;
  _set?: InputMaybe<TokenOwnershipsSetInput>;
  where: TokenOwnershipsBoolExp;
};

/** mutation root */
export type MutationRootUpdateTokenOwnershipsByPkArgs = {
  _inc?: InputMaybe<TokenOwnershipsIncInput>;
  _set?: InputMaybe<TokenOwnershipsSetInput>;
  pk_columns: TokenOwnershipsPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateTokenOwnershipsManyArgs = {
  updates: Array<TokenOwnershipsUpdates>;
};

/** mutation root */
export type MutationRootUpdateTokenOwnershipsV2Args = {
  _append?: InputMaybe<TokenOwnershipsV2AppendInput>;
  _delete_at_path?: InputMaybe<TokenOwnershipsV2DeleteAtPathInput>;
  _delete_elem?: InputMaybe<TokenOwnershipsV2DeleteElemInput>;
  _delete_key?: InputMaybe<TokenOwnershipsV2DeleteKeyInput>;
  _inc?: InputMaybe<TokenOwnershipsV2IncInput>;
  _prepend?: InputMaybe<TokenOwnershipsV2PrependInput>;
  _set?: InputMaybe<TokenOwnershipsV2SetInput>;
  where: TokenOwnershipsV2BoolExp;
};

/** mutation root */
export type MutationRootUpdateTokenOwnershipsV2ByPkArgs = {
  _append?: InputMaybe<TokenOwnershipsV2AppendInput>;
  _delete_at_path?: InputMaybe<TokenOwnershipsV2DeleteAtPathInput>;
  _delete_elem?: InputMaybe<TokenOwnershipsV2DeleteElemInput>;
  _delete_key?: InputMaybe<TokenOwnershipsV2DeleteKeyInput>;
  _inc?: InputMaybe<TokenOwnershipsV2IncInput>;
  _prepend?: InputMaybe<TokenOwnershipsV2PrependInput>;
  _set?: InputMaybe<TokenOwnershipsV2SetInput>;
  pk_columns: TokenOwnershipsV2PkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateTokenOwnershipsV2ManyArgs = {
  updates: Array<TokenOwnershipsV2Updates>;
};

/** mutation root */
export type MutationRootUpdateTokensArgs = {
  _append?: InputMaybe<TokensAppendInput>;
  _delete_at_path?: InputMaybe<TokensDeleteAtPathInput>;
  _delete_elem?: InputMaybe<TokensDeleteElemInput>;
  _delete_key?: InputMaybe<TokensDeleteKeyInput>;
  _inc?: InputMaybe<TokensIncInput>;
  _prepend?: InputMaybe<TokensPrependInput>;
  _set?: InputMaybe<TokensSetInput>;
  where: TokensBoolExp;
};

/** mutation root */
export type MutationRootUpdateTokensByPkArgs = {
  _append?: InputMaybe<TokensAppendInput>;
  _delete_at_path?: InputMaybe<TokensDeleteAtPathInput>;
  _delete_elem?: InputMaybe<TokensDeleteElemInput>;
  _delete_key?: InputMaybe<TokensDeleteKeyInput>;
  _inc?: InputMaybe<TokensIncInput>;
  _prepend?: InputMaybe<TokensPrependInput>;
  _set?: InputMaybe<TokensSetInput>;
  pk_columns: TokensPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateTokensManyArgs = {
  updates: Array<TokensUpdates>;
};

/** mutation root */
export type MutationRootUpdateTransactionSizeInfoArgs = {
  _inc?: InputMaybe<TransactionSizeInfoIncInput>;
  _set?: InputMaybe<TransactionSizeInfoSetInput>;
  where: TransactionSizeInfoBoolExp;
};

/** mutation root */
export type MutationRootUpdateTransactionSizeInfoByPkArgs = {
  _inc?: InputMaybe<TransactionSizeInfoIncInput>;
  _set?: InputMaybe<TransactionSizeInfoSetInput>;
  pk_columns: TransactionSizeInfoPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateTransactionSizeInfoManyArgs = {
  updates: Array<TransactionSizeInfoUpdates>;
};

/** mutation root */
export type MutationRootUpdateTransactionsViewArgs = {
  _inc?: InputMaybe<TransactionsViewIncInput>;
  _set?: InputMaybe<TransactionsViewSetInput>;
  where: TransactionsViewBoolExp;
};

/** mutation root */
export type MutationRootUpdateTransactionsViewManyArgs = {
  updates: Array<TransactionsViewUpdates>;
};

/** mutation root */
export type MutationRootUpdateUserTransactionsArgs = {
  _inc?: InputMaybe<UserTransactionsIncInput>;
  _set?: InputMaybe<UserTransactionsSetInput>;
  where: UserTransactionsBoolExp;
};

/** mutation root */
export type MutationRootUpdateUserTransactionsByPkArgs = {
  _inc?: InputMaybe<UserTransactionsIncInput>;
  _set?: InputMaybe<UserTransactionsSetInput>;
  pk_columns: UserTransactionsPkColumnsInput;
};

/** mutation root */
export type MutationRootUpdateUserTransactionsManyArgs = {
  updates: Array<UserTransactionsUpdates>;
};

/** columns and relationships of "nft_metadata_crawler.parsed_asset_uris" */
export type NftMetadataCrawlerParsedAssetUris = {
  animation_optimizer_retry_count: Scalars["Int"]["output"];
  asset_uri: Scalars["String"]["output"];
  cdn_animation_uri?: Maybe<Scalars["String"]["output"]>;
  cdn_image_uri?: Maybe<Scalars["String"]["output"]>;
  cdn_json_uri?: Maybe<Scalars["String"]["output"]>;
  image_optimizer_retry_count: Scalars["Int"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  json_parser_retry_count: Scalars["Int"]["output"];
  raw_animation_uri?: Maybe<Scalars["String"]["output"]>;
  raw_image_uri?: Maybe<Scalars["String"]["output"]>;
};

/** aggregated selection of "nft_metadata_crawler.parsed_asset_uris" */
export type NftMetadataCrawlerParsedAssetUrisAggregate = {
  aggregate?: Maybe<NftMetadataCrawlerParsedAssetUrisAggregateFields>;
  nodes: Array<NftMetadataCrawlerParsedAssetUris>;
};

/** aggregate fields of "nft_metadata_crawler.parsed_asset_uris" */
export type NftMetadataCrawlerParsedAssetUrisAggregateFields = {
  avg?: Maybe<NftMetadataCrawlerParsedAssetUrisAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<NftMetadataCrawlerParsedAssetUrisMaxFields>;
  min?: Maybe<NftMetadataCrawlerParsedAssetUrisMinFields>;
  stddev?: Maybe<NftMetadataCrawlerParsedAssetUrisStddevFields>;
  stddev_pop?: Maybe<NftMetadataCrawlerParsedAssetUrisStddevPopFields>;
  stddev_samp?: Maybe<NftMetadataCrawlerParsedAssetUrisStddevSampFields>;
  sum?: Maybe<NftMetadataCrawlerParsedAssetUrisSumFields>;
  var_pop?: Maybe<NftMetadataCrawlerParsedAssetUrisVarPopFields>;
  var_samp?: Maybe<NftMetadataCrawlerParsedAssetUrisVarSampFields>;
  variance?: Maybe<NftMetadataCrawlerParsedAssetUrisVarianceFields>;
};

/** aggregate fields of "nft_metadata_crawler.parsed_asset_uris" */
export type NftMetadataCrawlerParsedAssetUrisAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type NftMetadataCrawlerParsedAssetUrisAvgFields = {
  animation_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
  image_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
  json_parser_retry_count?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "nft_metadata_crawler.parsed_asset_uris". All fields are combined with a logical 'AND'. */
export type NftMetadataCrawlerParsedAssetUrisBoolExp = {
  _and?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisBoolExp>>;
  _not?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;
  _or?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisBoolExp>>;
  animation_optimizer_retry_count?: InputMaybe<IntComparisonExp>;
  asset_uri?: InputMaybe<StringComparisonExp>;
  cdn_animation_uri?: InputMaybe<StringComparisonExp>;
  cdn_image_uri?: InputMaybe<StringComparisonExp>;
  cdn_json_uri?: InputMaybe<StringComparisonExp>;
  image_optimizer_retry_count?: InputMaybe<IntComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  json_parser_retry_count?: InputMaybe<IntComparisonExp>;
  raw_animation_uri?: InputMaybe<StringComparisonExp>;
  raw_image_uri?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "nft_metadata_crawler.parsed_asset_uris" */
export enum NftMetadataCrawlerParsedAssetUrisConstraint {
  /** unique or primary key constraint on columns "asset_uri" */
  ParsedAssetUrisPkey = "parsed_asset_uris_pkey",
}

/** input type for incrementing numeric columns in table "nft_metadata_crawler.parsed_asset_uris" */
export type NftMetadataCrawlerParsedAssetUrisIncInput = {
  animation_optimizer_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
  image_optimizer_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
  json_parser_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
};

/** input type for inserting data into table "nft_metadata_crawler.parsed_asset_uris" */
export type NftMetadataCrawlerParsedAssetUrisInsertInput = {
  animation_optimizer_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
  asset_uri?: InputMaybe<Scalars["String"]["input"]>;
  cdn_animation_uri?: InputMaybe<Scalars["String"]["input"]>;
  cdn_image_uri?: InputMaybe<Scalars["String"]["input"]>;
  cdn_json_uri?: InputMaybe<Scalars["String"]["input"]>;
  image_optimizer_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  json_parser_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
  raw_animation_uri?: InputMaybe<Scalars["String"]["input"]>;
  raw_image_uri?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type NftMetadataCrawlerParsedAssetUrisMaxFields = {
  animation_optimizer_retry_count?: Maybe<Scalars["Int"]["output"]>;
  asset_uri?: Maybe<Scalars["String"]["output"]>;
  cdn_animation_uri?: Maybe<Scalars["String"]["output"]>;
  cdn_image_uri?: Maybe<Scalars["String"]["output"]>;
  cdn_json_uri?: Maybe<Scalars["String"]["output"]>;
  image_optimizer_retry_count?: Maybe<Scalars["Int"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  json_parser_retry_count?: Maybe<Scalars["Int"]["output"]>;
  raw_animation_uri?: Maybe<Scalars["String"]["output"]>;
  raw_image_uri?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type NftMetadataCrawlerParsedAssetUrisMinFields = {
  animation_optimizer_retry_count?: Maybe<Scalars["Int"]["output"]>;
  asset_uri?: Maybe<Scalars["String"]["output"]>;
  cdn_animation_uri?: Maybe<Scalars["String"]["output"]>;
  cdn_image_uri?: Maybe<Scalars["String"]["output"]>;
  cdn_json_uri?: Maybe<Scalars["String"]["output"]>;
  image_optimizer_retry_count?: Maybe<Scalars["Int"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  json_parser_retry_count?: Maybe<Scalars["Int"]["output"]>;
  raw_animation_uri?: Maybe<Scalars["String"]["output"]>;
  raw_image_uri?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "nft_metadata_crawler.parsed_asset_uris" */
export type NftMetadataCrawlerParsedAssetUrisMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<NftMetadataCrawlerParsedAssetUris>;
};

/** input type for inserting object relation for remote table "nft_metadata_crawler.parsed_asset_uris" */
export type NftMetadataCrawlerParsedAssetUrisObjRelInsertInput = {
  data: NftMetadataCrawlerParsedAssetUrisInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<NftMetadataCrawlerParsedAssetUrisOnConflict>;
};

/** on_conflict condition type for table "nft_metadata_crawler.parsed_asset_uris" */
export type NftMetadataCrawlerParsedAssetUrisOnConflict = {
  constraint: NftMetadataCrawlerParsedAssetUrisConstraint;
  update_columns?: Array<NftMetadataCrawlerParsedAssetUrisUpdateColumn>;
  where?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;
};

/** Ordering options when selecting data from "nft_metadata_crawler.parsed_asset_uris". */
export type NftMetadataCrawlerParsedAssetUrisOrderBy = {
  animation_optimizer_retry_count?: InputMaybe<OrderBy>;
  asset_uri?: InputMaybe<OrderBy>;
  cdn_animation_uri?: InputMaybe<OrderBy>;
  cdn_image_uri?: InputMaybe<OrderBy>;
  cdn_json_uri?: InputMaybe<OrderBy>;
  image_optimizer_retry_count?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  json_parser_retry_count?: InputMaybe<OrderBy>;
  raw_animation_uri?: InputMaybe<OrderBy>;
  raw_image_uri?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: nft_metadata_crawler.parsed_asset_uris */
export type NftMetadataCrawlerParsedAssetUrisPkColumnsInput = {
  asset_uri: Scalars["String"]["input"];
};

/** select columns of table "nft_metadata_crawler.parsed_asset_uris" */
export enum NftMetadataCrawlerParsedAssetUrisSelectColumn {
  /** column name */
  AnimationOptimizerRetryCount = "animation_optimizer_retry_count",
  /** column name */
  AssetUri = "asset_uri",
  /** column name */
  CdnAnimationUri = "cdn_animation_uri",
  /** column name */
  CdnImageUri = "cdn_image_uri",
  /** column name */
  CdnJsonUri = "cdn_json_uri",
  /** column name */
  ImageOptimizerRetryCount = "image_optimizer_retry_count",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  JsonParserRetryCount = "json_parser_retry_count",
  /** column name */
  RawAnimationUri = "raw_animation_uri",
  /** column name */
  RawImageUri = "raw_image_uri",
}

/** input type for updating data in table "nft_metadata_crawler.parsed_asset_uris" */
export type NftMetadataCrawlerParsedAssetUrisSetInput = {
  animation_optimizer_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
  asset_uri?: InputMaybe<Scalars["String"]["input"]>;
  cdn_animation_uri?: InputMaybe<Scalars["String"]["input"]>;
  cdn_image_uri?: InputMaybe<Scalars["String"]["input"]>;
  cdn_json_uri?: InputMaybe<Scalars["String"]["input"]>;
  image_optimizer_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  json_parser_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
  raw_animation_uri?: InputMaybe<Scalars["String"]["input"]>;
  raw_image_uri?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type NftMetadataCrawlerParsedAssetUrisStddevFields = {
  animation_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
  image_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
  json_parser_retry_count?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type NftMetadataCrawlerParsedAssetUrisStddevPopFields = {
  animation_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
  image_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
  json_parser_retry_count?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type NftMetadataCrawlerParsedAssetUrisStddevSampFields = {
  animation_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
  image_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
  json_parser_retry_count?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "nft_metadata_crawler_parsed_asset_uris" */
export type NftMetadataCrawlerParsedAssetUrisStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: NftMetadataCrawlerParsedAssetUrisStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type NftMetadataCrawlerParsedAssetUrisStreamCursorValueInput = {
  animation_optimizer_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
  asset_uri?: InputMaybe<Scalars["String"]["input"]>;
  cdn_animation_uri?: InputMaybe<Scalars["String"]["input"]>;
  cdn_image_uri?: InputMaybe<Scalars["String"]["input"]>;
  cdn_json_uri?: InputMaybe<Scalars["String"]["input"]>;
  image_optimizer_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  json_parser_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
  raw_animation_uri?: InputMaybe<Scalars["String"]["input"]>;
  raw_image_uri?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type NftMetadataCrawlerParsedAssetUrisSumFields = {
  animation_optimizer_retry_count?: Maybe<Scalars["Int"]["output"]>;
  image_optimizer_retry_count?: Maybe<Scalars["Int"]["output"]>;
  json_parser_retry_count?: Maybe<Scalars["Int"]["output"]>;
};

/** update columns of table "nft_metadata_crawler.parsed_asset_uris" */
export enum NftMetadataCrawlerParsedAssetUrisUpdateColumn {
  /** column name */
  AnimationOptimizerRetryCount = "animation_optimizer_retry_count",
  /** column name */
  AssetUri = "asset_uri",
  /** column name */
  CdnAnimationUri = "cdn_animation_uri",
  /** column name */
  CdnImageUri = "cdn_image_uri",
  /** column name */
  CdnJsonUri = "cdn_json_uri",
  /** column name */
  ImageOptimizerRetryCount = "image_optimizer_retry_count",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  JsonParserRetryCount = "json_parser_retry_count",
  /** column name */
  RawAnimationUri = "raw_animation_uri",
  /** column name */
  RawImageUri = "raw_image_uri",
}

export type NftMetadataCrawlerParsedAssetUrisUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<NftMetadataCrawlerParsedAssetUrisIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<NftMetadataCrawlerParsedAssetUrisSetInput>;
  /** filter the rows which have to be updated */
  where: NftMetadataCrawlerParsedAssetUrisBoolExp;
};

/** aggregate var_pop on columns */
export type NftMetadataCrawlerParsedAssetUrisVarPopFields = {
  animation_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
  image_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
  json_parser_retry_count?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type NftMetadataCrawlerParsedAssetUrisVarSampFields = {
  animation_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
  image_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
  json_parser_retry_count?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type NftMetadataCrawlerParsedAssetUrisVarianceFields = {
  animation_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
  image_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
  json_parser_retry_count?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "nft_points" */
export type NftPoints = {
  amount: Scalars["numeric"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  owner_address: Scalars["String"]["output"];
  point_type: Scalars["String"]["output"];
  token_name: Scalars["String"]["output"];
  transaction_timestamp: Scalars["timestamp"]["output"];
  transaction_version: Scalars["bigint"]["output"];
};

/** aggregated selection of "nft_points" */
export type NftPointsAggregate = {
  aggregate?: Maybe<NftPointsAggregateFields>;
  nodes: Array<NftPoints>;
};

/** aggregate fields of "nft_points" */
export type NftPointsAggregateFields = {
  avg?: Maybe<NftPointsAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<NftPointsMaxFields>;
  min?: Maybe<NftPointsMinFields>;
  stddev?: Maybe<NftPointsStddevFields>;
  stddev_pop?: Maybe<NftPointsStddevPopFields>;
  stddev_samp?: Maybe<NftPointsStddevSampFields>;
  sum?: Maybe<NftPointsSumFields>;
  var_pop?: Maybe<NftPointsVarPopFields>;
  var_samp?: Maybe<NftPointsVarSampFields>;
  variance?: Maybe<NftPointsVarianceFields>;
};

/** aggregate fields of "nft_points" */
export type NftPointsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<NftPointsSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type NftPointsAvgFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "nft_points". All fields are combined with a logical 'AND'. */
export type NftPointsBoolExp = {
  _and?: InputMaybe<Array<NftPointsBoolExp>>;
  _not?: InputMaybe<NftPointsBoolExp>;
  _or?: InputMaybe<Array<NftPointsBoolExp>>;
  amount?: InputMaybe<NumericComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  owner_address?: InputMaybe<StringComparisonExp>;
  point_type?: InputMaybe<StringComparisonExp>;
  token_name?: InputMaybe<StringComparisonExp>;
  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "nft_points" */
export enum NftPointsConstraint {
  /** unique or primary key constraint on columns "transaction_version" */
  NftPointsPkey = "nft_points_pkey",
}

/** input type for incrementing numeric columns in table "nft_points" */
export type NftPointsIncInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "nft_points" */
export type NftPointsInsertInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  point_type?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type NftPointsMaxFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  point_type?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type NftPointsMinFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  point_type?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "nft_points" */
export type NftPointsMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<NftPoints>;
};

/** on_conflict condition type for table "nft_points" */
export type NftPointsOnConflict = {
  constraint: NftPointsConstraint;
  update_columns?: Array<NftPointsUpdateColumn>;
  where?: InputMaybe<NftPointsBoolExp>;
};

/** Ordering options when selecting data from "nft_points". */
export type NftPointsOrderBy = {
  amount?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  owner_address?: InputMaybe<OrderBy>;
  point_type?: InputMaybe<OrderBy>;
  token_name?: InputMaybe<OrderBy>;
  transaction_timestamp?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: nft_points */
export type NftPointsPkColumnsInput = {
  transaction_version: Scalars["bigint"]["input"];
};

/** select columns of table "nft_points" */
export enum NftPointsSelectColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  PointType = "point_type",
  /** column name */
  TokenName = "token_name",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
}

/** input type for updating data in table "nft_points" */
export type NftPointsSetInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  point_type?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type NftPointsStddevFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type NftPointsStddevPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type NftPointsStddevSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "nft_points" */
export type NftPointsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: NftPointsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type NftPointsStreamCursorValueInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  point_type?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type NftPointsSumFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "nft_points" */
export enum NftPointsUpdateColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  PointType = "point_type",
  /** column name */
  TokenName = "token_name",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
}

export type NftPointsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<NftPointsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<NftPointsSetInput>;
  /** filter the rows which have to be updated */
  where: NftPointsBoolExp;
};

/** aggregate var_pop on columns */
export type NftPointsVarPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type NftPointsVarSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type NftPointsVarianceFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "num_active_delegator_per_pool" */
export type NumActiveDelegatorPerPool = {
  num_active_delegator?: Maybe<Scalars["bigint"]["output"]>;
  pool_address?: Maybe<Scalars["String"]["output"]>;
};

/** aggregated selection of "num_active_delegator_per_pool" */
export type NumActiveDelegatorPerPoolAggregate = {
  aggregate?: Maybe<NumActiveDelegatorPerPoolAggregateFields>;
  nodes: Array<NumActiveDelegatorPerPool>;
};

/** aggregate fields of "num_active_delegator_per_pool" */
export type NumActiveDelegatorPerPoolAggregateFields = {
  avg?: Maybe<NumActiveDelegatorPerPoolAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<NumActiveDelegatorPerPoolMaxFields>;
  min?: Maybe<NumActiveDelegatorPerPoolMinFields>;
  stddev?: Maybe<NumActiveDelegatorPerPoolStddevFields>;
  stddev_pop?: Maybe<NumActiveDelegatorPerPoolStddevPopFields>;
  stddev_samp?: Maybe<NumActiveDelegatorPerPoolStddevSampFields>;
  sum?: Maybe<NumActiveDelegatorPerPoolSumFields>;
  var_pop?: Maybe<NumActiveDelegatorPerPoolVarPopFields>;
  var_samp?: Maybe<NumActiveDelegatorPerPoolVarSampFields>;
  variance?: Maybe<NumActiveDelegatorPerPoolVarianceFields>;
};

/** aggregate fields of "num_active_delegator_per_pool" */
export type NumActiveDelegatorPerPoolAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<NumActiveDelegatorPerPoolSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type NumActiveDelegatorPerPoolAvgFields = {
  num_active_delegator?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "num_active_delegator_per_pool". All fields are combined with a logical 'AND'. */
export type NumActiveDelegatorPerPoolBoolExp = {
  _and?: InputMaybe<Array<NumActiveDelegatorPerPoolBoolExp>>;
  _not?: InputMaybe<NumActiveDelegatorPerPoolBoolExp>;
  _or?: InputMaybe<Array<NumActiveDelegatorPerPoolBoolExp>>;
  num_active_delegator?: InputMaybe<BigintComparisonExp>;
  pool_address?: InputMaybe<StringComparisonExp>;
};

/** aggregate max on columns */
export type NumActiveDelegatorPerPoolMaxFields = {
  num_active_delegator?: Maybe<Scalars["bigint"]["output"]>;
  pool_address?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type NumActiveDelegatorPerPoolMinFields = {
  num_active_delegator?: Maybe<Scalars["bigint"]["output"]>;
  pool_address?: Maybe<Scalars["String"]["output"]>;
};

/** Ordering options when selecting data from "num_active_delegator_per_pool". */
export type NumActiveDelegatorPerPoolOrderBy = {
  num_active_delegator?: InputMaybe<OrderBy>;
  pool_address?: InputMaybe<OrderBy>;
};

/** select columns of table "num_active_delegator_per_pool" */
export enum NumActiveDelegatorPerPoolSelectColumn {
  /** column name */
  NumActiveDelegator = "num_active_delegator",
  /** column name */
  PoolAddress = "pool_address",
}

/** aggregate stddev on columns */
export type NumActiveDelegatorPerPoolStddevFields = {
  num_active_delegator?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type NumActiveDelegatorPerPoolStddevPopFields = {
  num_active_delegator?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type NumActiveDelegatorPerPoolStddevSampFields = {
  num_active_delegator?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "num_active_delegator_per_pool" */
export type NumActiveDelegatorPerPoolStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: NumActiveDelegatorPerPoolStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type NumActiveDelegatorPerPoolStreamCursorValueInput = {
  num_active_delegator?: InputMaybe<Scalars["bigint"]["input"]>;
  pool_address?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type NumActiveDelegatorPerPoolSumFields = {
  num_active_delegator?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate var_pop on columns */
export type NumActiveDelegatorPerPoolVarPopFields = {
  num_active_delegator?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type NumActiveDelegatorPerPoolVarSampFields = {
  num_active_delegator?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type NumActiveDelegatorPerPoolVarianceFields = {
  num_active_delegator?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'. */
export type NumericComparisonExp = {
  _eq?: InputMaybe<Scalars["numeric"]["input"]>;
  _gt?: InputMaybe<Scalars["numeric"]["input"]>;
  _gte?: InputMaybe<Scalars["numeric"]["input"]>;
  _in?: InputMaybe<Array<Scalars["numeric"]["input"]>>;
  _is_null?: InputMaybe<Scalars["Boolean"]["input"]>;
  _lt?: InputMaybe<Scalars["numeric"]["input"]>;
  _lte?: InputMaybe<Scalars["numeric"]["input"]>;
  _neq?: InputMaybe<Scalars["numeric"]["input"]>;
  _nin?: InputMaybe<Array<Scalars["numeric"]["input"]>>;
};

/** columns and relationships of "objects" */
export type Objects = {
  allow_ungated_transfer: Scalars["Boolean"]["output"];
  guid_creation_num: Scalars["numeric"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  is_deleted: Scalars["Boolean"]["output"];
  object_address: Scalars["String"]["output"];
  owner_address: Scalars["String"]["output"];
  state_key_hash: Scalars["String"]["output"];
  transaction_version: Scalars["bigint"]["output"];
  untransferrable: Scalars["Boolean"]["output"];
  write_set_change_index: Scalars["bigint"]["output"];
};

/** aggregated selection of "objects" */
export type ObjectsAggregate = {
  aggregate?: Maybe<ObjectsAggregateFields>;
  nodes: Array<Objects>;
};

/** aggregate fields of "objects" */
export type ObjectsAggregateFields = {
  avg?: Maybe<ObjectsAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<ObjectsMaxFields>;
  min?: Maybe<ObjectsMinFields>;
  stddev?: Maybe<ObjectsStddevFields>;
  stddev_pop?: Maybe<ObjectsStddevPopFields>;
  stddev_samp?: Maybe<ObjectsStddevSampFields>;
  sum?: Maybe<ObjectsSumFields>;
  var_pop?: Maybe<ObjectsVarPopFields>;
  var_samp?: Maybe<ObjectsVarSampFields>;
  variance?: Maybe<ObjectsVarianceFields>;
};

/** aggregate fields of "objects" */
export type ObjectsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ObjectsSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type ObjectsAvgFields = {
  guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "objects". All fields are combined with a logical 'AND'. */
export type ObjectsBoolExp = {
  _and?: InputMaybe<Array<ObjectsBoolExp>>;
  _not?: InputMaybe<ObjectsBoolExp>;
  _or?: InputMaybe<Array<ObjectsBoolExp>>;
  allow_ungated_transfer?: InputMaybe<BooleanComparisonExp>;
  guid_creation_num?: InputMaybe<NumericComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_deleted?: InputMaybe<BooleanComparisonExp>;
  object_address?: InputMaybe<StringComparisonExp>;
  owner_address?: InputMaybe<StringComparisonExp>;
  state_key_hash?: InputMaybe<StringComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  untransferrable?: InputMaybe<BooleanComparisonExp>;
  write_set_change_index?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "objects" */
export enum ObjectsConstraint {
  /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
  ObjectsPkey = "objects_pkey",
}

/** input type for incrementing numeric columns in table "objects" */
export type ObjectsIncInput = {
  guid_creation_num?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "objects" */
export type ObjectsInsertInput = {
  allow_ungated_transfer?: InputMaybe<Scalars["Boolean"]["input"]>;
  guid_creation_num?: InputMaybe<Scalars["numeric"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  object_address?: InputMaybe<Scalars["String"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  untransferrable?: InputMaybe<Scalars["Boolean"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type ObjectsMaxFields = {
  guid_creation_num?: Maybe<Scalars["numeric"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  object_address?: Maybe<Scalars["String"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  state_key_hash?: Maybe<Scalars["String"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type ObjectsMinFields = {
  guid_creation_num?: Maybe<Scalars["numeric"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  object_address?: Maybe<Scalars["String"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  state_key_hash?: Maybe<Scalars["String"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "objects" */
export type ObjectsMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<Objects>;
};

/** on_conflict condition type for table "objects" */
export type ObjectsOnConflict = {
  constraint: ObjectsConstraint;
  update_columns?: Array<ObjectsUpdateColumn>;
  where?: InputMaybe<ObjectsBoolExp>;
};

/** Ordering options when selecting data from "objects". */
export type ObjectsOrderBy = {
  allow_ungated_transfer?: InputMaybe<OrderBy>;
  guid_creation_num?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_deleted?: InputMaybe<OrderBy>;
  object_address?: InputMaybe<OrderBy>;
  owner_address?: InputMaybe<OrderBy>;
  state_key_hash?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  untransferrable?: InputMaybe<OrderBy>;
  write_set_change_index?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: objects */
export type ObjectsPkColumnsInput = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** select columns of table "objects" */
export enum ObjectsSelectColumn {
  /** column name */
  AllowUngatedTransfer = "allow_ungated_transfer",
  /** column name */
  GuidCreationNum = "guid_creation_num",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  ObjectAddress = "object_address",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  StateKeyHash = "state_key_hash",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  Untransferrable = "untransferrable",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

/** input type for updating data in table "objects" */
export type ObjectsSetInput = {
  allow_ungated_transfer?: InputMaybe<Scalars["Boolean"]["input"]>;
  guid_creation_num?: InputMaybe<Scalars["numeric"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  object_address?: InputMaybe<Scalars["String"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  untransferrable?: InputMaybe<Scalars["Boolean"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type ObjectsStddevFields = {
  guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type ObjectsStddevPopFields = {
  guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type ObjectsStddevSampFields = {
  guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "objects" */
export type ObjectsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ObjectsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ObjectsStreamCursorValueInput = {
  allow_ungated_transfer?: InputMaybe<Scalars["Boolean"]["input"]>;
  guid_creation_num?: InputMaybe<Scalars["numeric"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  object_address?: InputMaybe<Scalars["String"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  untransferrable?: InputMaybe<Scalars["Boolean"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type ObjectsSumFields = {
  guid_creation_num?: Maybe<Scalars["numeric"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "objects" */
export enum ObjectsUpdateColumn {
  /** column name */
  AllowUngatedTransfer = "allow_ungated_transfer",
  /** column name */
  GuidCreationNum = "guid_creation_num",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  ObjectAddress = "object_address",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  StateKeyHash = "state_key_hash",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  Untransferrable = "untransferrable",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

export type ObjectsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ObjectsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ObjectsSetInput>;
  /** filter the rows which have to be updated */
  where: ObjectsBoolExp;
};

/** aggregate var_pop on columns */
export type ObjectsVarPopFields = {
  guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type ObjectsVarSampFields = {
  guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type ObjectsVarianceFields = {
  guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** column ordering options */
export enum OrderBy {
  /** in ascending order, nulls last */
  Asc = "asc",
  /** in ascending order, nulls first */
  AscNullsFirst = "asc_nulls_first",
  /** in ascending order, nulls last */
  AscNullsLast = "asc_nulls_last",
  /** in descending order, nulls first */
  Desc = "desc",
  /** in descending order, nulls first */
  DescNullsFirst = "desc_nulls_first",
  /** in descending order, nulls last */
  DescNullsLast = "desc_nulls_last",
}

/** columns and relationships of "processor_metadata.processor_status" */
export type ProcessorMetadataProcessorStatus = {
  last_success_version: Scalars["bigint"]["output"];
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_updated: Scalars["timestamp"]["output"];
  processor: Scalars["String"]["output"];
};

/** aggregated selection of "processor_metadata.processor_status" */
export type ProcessorMetadataProcessorStatusAggregate = {
  aggregate?: Maybe<ProcessorMetadataProcessorStatusAggregateFields>;
  nodes: Array<ProcessorMetadataProcessorStatus>;
};

/** aggregate fields of "processor_metadata.processor_status" */
export type ProcessorMetadataProcessorStatusAggregateFields = {
  avg?: Maybe<ProcessorMetadataProcessorStatusAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<ProcessorMetadataProcessorStatusMaxFields>;
  min?: Maybe<ProcessorMetadataProcessorStatusMinFields>;
  stddev?: Maybe<ProcessorMetadataProcessorStatusStddevFields>;
  stddev_pop?: Maybe<ProcessorMetadataProcessorStatusStddevPopFields>;
  stddev_samp?: Maybe<ProcessorMetadataProcessorStatusStddevSampFields>;
  sum?: Maybe<ProcessorMetadataProcessorStatusSumFields>;
  var_pop?: Maybe<ProcessorMetadataProcessorStatusVarPopFields>;
  var_samp?: Maybe<ProcessorMetadataProcessorStatusVarSampFields>;
  variance?: Maybe<ProcessorMetadataProcessorStatusVarianceFields>;
};

/** aggregate fields of "processor_metadata.processor_status" */
export type ProcessorMetadataProcessorStatusAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ProcessorMetadataProcessorStatusSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type ProcessorMetadataProcessorStatusAvgFields = {
  last_success_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "processor_metadata.processor_status". All fields are combined with a logical 'AND'. */
export type ProcessorMetadataProcessorStatusBoolExp = {
  _and?: InputMaybe<Array<ProcessorMetadataProcessorStatusBoolExp>>;
  _not?: InputMaybe<ProcessorMetadataProcessorStatusBoolExp>;
  _or?: InputMaybe<Array<ProcessorMetadataProcessorStatusBoolExp>>;
  last_success_version?: InputMaybe<BigintComparisonExp>;
  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  last_updated?: InputMaybe<TimestampComparisonExp>;
  processor?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "processor_metadata.processor_status" */
export enum ProcessorMetadataProcessorStatusConstraint {
  /** unique or primary key constraint on columns "processor" */
  ProcessorStatusPkey = "processor_status_pkey",
}

/** input type for incrementing numeric columns in table "processor_metadata.processor_status" */
export type ProcessorMetadataProcessorStatusIncInput = {
  last_success_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "processor_metadata.processor_status" */
export type ProcessorMetadataProcessorStatusInsertInput = {
  last_success_version?: InputMaybe<Scalars["bigint"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_updated?: InputMaybe<Scalars["timestamp"]["input"]>;
  processor?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type ProcessorMetadataProcessorStatusMaxFields = {
  last_success_version?: Maybe<Scalars["bigint"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_updated?: Maybe<Scalars["timestamp"]["output"]>;
  processor?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type ProcessorMetadataProcessorStatusMinFields = {
  last_success_version?: Maybe<Scalars["bigint"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_updated?: Maybe<Scalars["timestamp"]["output"]>;
  processor?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "processor_metadata.processor_status" */
export type ProcessorMetadataProcessorStatusMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<ProcessorMetadataProcessorStatus>;
};

/** on_conflict condition type for table "processor_metadata.processor_status" */
export type ProcessorMetadataProcessorStatusOnConflict = {
  constraint: ProcessorMetadataProcessorStatusConstraint;
  update_columns?: Array<ProcessorMetadataProcessorStatusUpdateColumn>;
  where?: InputMaybe<ProcessorMetadataProcessorStatusBoolExp>;
};

/** Ordering options when selecting data from "processor_metadata.processor_status". */
export type ProcessorMetadataProcessorStatusOrderBy = {
  last_success_version?: InputMaybe<OrderBy>;
  last_transaction_timestamp?: InputMaybe<OrderBy>;
  last_updated?: InputMaybe<OrderBy>;
  processor?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: processor_metadata.processor_status */
export type ProcessorMetadataProcessorStatusPkColumnsInput = {
  processor: Scalars["String"]["input"];
};

/** select columns of table "processor_metadata.processor_status" */
export enum ProcessorMetadataProcessorStatusSelectColumn {
  /** column name */
  LastSuccessVersion = "last_success_version",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastUpdated = "last_updated",
  /** column name */
  Processor = "processor",
}

/** input type for updating data in table "processor_metadata.processor_status" */
export type ProcessorMetadataProcessorStatusSetInput = {
  last_success_version?: InputMaybe<Scalars["bigint"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_updated?: InputMaybe<Scalars["timestamp"]["input"]>;
  processor?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type ProcessorMetadataProcessorStatusStddevFields = {
  last_success_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type ProcessorMetadataProcessorStatusStddevPopFields = {
  last_success_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type ProcessorMetadataProcessorStatusStddevSampFields = {
  last_success_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "processor_metadata_processor_status" */
export type ProcessorMetadataProcessorStatusStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ProcessorMetadataProcessorStatusStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ProcessorMetadataProcessorStatusStreamCursorValueInput = {
  last_success_version?: InputMaybe<Scalars["bigint"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_updated?: InputMaybe<Scalars["timestamp"]["input"]>;
  processor?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type ProcessorMetadataProcessorStatusSumFields = {
  last_success_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "processor_metadata.processor_status" */
export enum ProcessorMetadataProcessorStatusUpdateColumn {
  /** column name */
  LastSuccessVersion = "last_success_version",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastUpdated = "last_updated",
  /** column name */
  Processor = "processor",
}

export type ProcessorMetadataProcessorStatusUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ProcessorMetadataProcessorStatusIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ProcessorMetadataProcessorStatusSetInput>;
  /** filter the rows which have to be updated */
  where: ProcessorMetadataProcessorStatusBoolExp;
};

/** aggregate var_pop on columns */
export type ProcessorMetadataProcessorStatusVarPopFields = {
  last_success_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type ProcessorMetadataProcessorStatusVarSampFields = {
  last_success_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type ProcessorMetadataProcessorStatusVarianceFields = {
  last_success_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "processor_status" */
export type ProcessorStatus = {
  last_success_version: Scalars["bigint"]["output"];
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_updated: Scalars["timestamp"]["output"];
  processor: Scalars["String"]["output"];
};

/** aggregated selection of "processor_status" */
export type ProcessorStatusAggregate = {
  aggregate?: Maybe<ProcessorStatusAggregateFields>;
  nodes: Array<ProcessorStatus>;
};

/** aggregate fields of "processor_status" */
export type ProcessorStatusAggregateFields = {
  avg?: Maybe<ProcessorStatusAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<ProcessorStatusMaxFields>;
  min?: Maybe<ProcessorStatusMinFields>;
  stddev?: Maybe<ProcessorStatusStddevFields>;
  stddev_pop?: Maybe<ProcessorStatusStddevPopFields>;
  stddev_samp?: Maybe<ProcessorStatusStddevSampFields>;
  sum?: Maybe<ProcessorStatusSumFields>;
  var_pop?: Maybe<ProcessorStatusVarPopFields>;
  var_samp?: Maybe<ProcessorStatusVarSampFields>;
  variance?: Maybe<ProcessorStatusVarianceFields>;
};

/** aggregate fields of "processor_status" */
export type ProcessorStatusAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ProcessorStatusSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type ProcessorStatusAvgFields = {
  last_success_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "processor_status". All fields are combined with a logical 'AND'. */
export type ProcessorStatusBoolExp = {
  _and?: InputMaybe<Array<ProcessorStatusBoolExp>>;
  _not?: InputMaybe<ProcessorStatusBoolExp>;
  _or?: InputMaybe<Array<ProcessorStatusBoolExp>>;
  last_success_version?: InputMaybe<BigintComparisonExp>;
  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  last_updated?: InputMaybe<TimestampComparisonExp>;
  processor?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "processor_status" */
export enum ProcessorStatusConstraint {
  /** unique or primary key constraint on columns "processor" */
  ProcessorStatusPkey = "processor_status_pkey",
  /** unique or primary key constraint on columns "processor" */
  ProcessorStatusPkey1 = "processor_status_pkey1",
}

/** input type for incrementing numeric columns in table "processor_status" */
export type ProcessorStatusIncInput = {
  last_success_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "processor_status" */
export type ProcessorStatusInsertInput = {
  last_success_version?: InputMaybe<Scalars["bigint"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_updated?: InputMaybe<Scalars["timestamp"]["input"]>;
  processor?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type ProcessorStatusMaxFields = {
  last_success_version?: Maybe<Scalars["bigint"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_updated?: Maybe<Scalars["timestamp"]["output"]>;
  processor?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type ProcessorStatusMinFields = {
  last_success_version?: Maybe<Scalars["bigint"]["output"]>;
  last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  last_updated?: Maybe<Scalars["timestamp"]["output"]>;
  processor?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "processor_status" */
export type ProcessorStatusMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<ProcessorStatus>;
};

/** on_conflict condition type for table "processor_status" */
export type ProcessorStatusOnConflict = {
  constraint: ProcessorStatusConstraint;
  update_columns?: Array<ProcessorStatusUpdateColumn>;
  where?: InputMaybe<ProcessorStatusBoolExp>;
};

/** Ordering options when selecting data from "processor_status". */
export type ProcessorStatusOrderBy = {
  last_success_version?: InputMaybe<OrderBy>;
  last_transaction_timestamp?: InputMaybe<OrderBy>;
  last_updated?: InputMaybe<OrderBy>;
  processor?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: processor_status */
export type ProcessorStatusPkColumnsInput = {
  processor: Scalars["String"]["input"];
};

/** select columns of table "processor_status" */
export enum ProcessorStatusSelectColumn {
  /** column name */
  LastSuccessVersion = "last_success_version",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastUpdated = "last_updated",
  /** column name */
  Processor = "processor",
}

/** input type for updating data in table "processor_status" */
export type ProcessorStatusSetInput = {
  last_success_version?: InputMaybe<Scalars["bigint"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_updated?: InputMaybe<Scalars["timestamp"]["input"]>;
  processor?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type ProcessorStatusStddevFields = {
  last_success_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type ProcessorStatusStddevPopFields = {
  last_success_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type ProcessorStatusStddevSampFields = {
  last_success_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "processor_status" */
export type ProcessorStatusStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ProcessorStatusStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ProcessorStatusStreamCursorValueInput = {
  last_success_version?: InputMaybe<Scalars["bigint"]["input"]>;
  last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  last_updated?: InputMaybe<Scalars["timestamp"]["input"]>;
  processor?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type ProcessorStatusSumFields = {
  last_success_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "processor_status" */
export enum ProcessorStatusUpdateColumn {
  /** column name */
  LastSuccessVersion = "last_success_version",
  /** column name */
  LastTransactionTimestamp = "last_transaction_timestamp",
  /** column name */
  LastUpdated = "last_updated",
  /** column name */
  Processor = "processor",
}

export type ProcessorStatusUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ProcessorStatusIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ProcessorStatusSetInput>;
  /** filter the rows which have to be updated */
  where: ProcessorStatusBoolExp;
};

/** aggregate var_pop on columns */
export type ProcessorStatusVarPopFields = {
  last_success_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type ProcessorStatusVarSampFields = {
  last_success_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type ProcessorStatusVarianceFields = {
  last_success_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "proposal_votes" */
export type ProposalVotes = {
  inserted_at: Scalars["timestamp"]["output"];
  num_votes: Scalars["numeric"]["output"];
  proposal_id: Scalars["bigint"]["output"];
  should_pass: Scalars["Boolean"]["output"];
  staking_pool_address: Scalars["String"]["output"];
  transaction_timestamp: Scalars["timestamp"]["output"];
  transaction_version: Scalars["bigint"]["output"];
  voter_address: Scalars["String"]["output"];
};

/** aggregated selection of "proposal_votes" */
export type ProposalVotesAggregate = {
  aggregate?: Maybe<ProposalVotesAggregateFields>;
  nodes: Array<ProposalVotes>;
};

/** aggregate fields of "proposal_votes" */
export type ProposalVotesAggregateFields = {
  avg?: Maybe<ProposalVotesAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<ProposalVotesMaxFields>;
  min?: Maybe<ProposalVotesMinFields>;
  stddev?: Maybe<ProposalVotesStddevFields>;
  stddev_pop?: Maybe<ProposalVotesStddevPopFields>;
  stddev_samp?: Maybe<ProposalVotesStddevSampFields>;
  sum?: Maybe<ProposalVotesSumFields>;
  var_pop?: Maybe<ProposalVotesVarPopFields>;
  var_samp?: Maybe<ProposalVotesVarSampFields>;
  variance?: Maybe<ProposalVotesVarianceFields>;
};

/** aggregate fields of "proposal_votes" */
export type ProposalVotesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ProposalVotesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type ProposalVotesAvgFields = {
  num_votes?: Maybe<Scalars["Float"]["output"]>;
  proposal_id?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "proposal_votes". All fields are combined with a logical 'AND'. */
export type ProposalVotesBoolExp = {
  _and?: InputMaybe<Array<ProposalVotesBoolExp>>;
  _not?: InputMaybe<ProposalVotesBoolExp>;
  _or?: InputMaybe<Array<ProposalVotesBoolExp>>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  num_votes?: InputMaybe<NumericComparisonExp>;
  proposal_id?: InputMaybe<BigintComparisonExp>;
  should_pass?: InputMaybe<BooleanComparisonExp>;
  staking_pool_address?: InputMaybe<StringComparisonExp>;
  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  voter_address?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "proposal_votes" */
export enum ProposalVotesConstraint {
  /** unique or primary key constraint on columns "voter_address", "transaction_version", "proposal_id" */
  ProposalVotesPkey = "proposal_votes_pkey",
}

/** input type for incrementing numeric columns in table "proposal_votes" */
export type ProposalVotesIncInput = {
  num_votes?: InputMaybe<Scalars["numeric"]["input"]>;
  proposal_id?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "proposal_votes" */
export type ProposalVotesInsertInput = {
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  num_votes?: InputMaybe<Scalars["numeric"]["input"]>;
  proposal_id?: InputMaybe<Scalars["bigint"]["input"]>;
  should_pass?: InputMaybe<Scalars["Boolean"]["input"]>;
  staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  voter_address?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type ProposalVotesMaxFields = {
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  num_votes?: Maybe<Scalars["numeric"]["output"]>;
  proposal_id?: Maybe<Scalars["bigint"]["output"]>;
  staking_pool_address?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  voter_address?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type ProposalVotesMinFields = {
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  num_votes?: Maybe<Scalars["numeric"]["output"]>;
  proposal_id?: Maybe<Scalars["bigint"]["output"]>;
  staking_pool_address?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  voter_address?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "proposal_votes" */
export type ProposalVotesMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<ProposalVotes>;
};

/** on_conflict condition type for table "proposal_votes" */
export type ProposalVotesOnConflict = {
  constraint: ProposalVotesConstraint;
  update_columns?: Array<ProposalVotesUpdateColumn>;
  where?: InputMaybe<ProposalVotesBoolExp>;
};

/** Ordering options when selecting data from "proposal_votes". */
export type ProposalVotesOrderBy = {
  inserted_at?: InputMaybe<OrderBy>;
  num_votes?: InputMaybe<OrderBy>;
  proposal_id?: InputMaybe<OrderBy>;
  should_pass?: InputMaybe<OrderBy>;
  staking_pool_address?: InputMaybe<OrderBy>;
  transaction_timestamp?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  voter_address?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: proposal_votes */
export type ProposalVotesPkColumnsInput = {
  proposal_id: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
  voter_address: Scalars["String"]["input"];
};

/** select columns of table "proposal_votes" */
export enum ProposalVotesSelectColumn {
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  NumVotes = "num_votes",
  /** column name */
  ProposalId = "proposal_id",
  /** column name */
  ShouldPass = "should_pass",
  /** column name */
  StakingPoolAddress = "staking_pool_address",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  VoterAddress = "voter_address",
}

/** input type for updating data in table "proposal_votes" */
export type ProposalVotesSetInput = {
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  num_votes?: InputMaybe<Scalars["numeric"]["input"]>;
  proposal_id?: InputMaybe<Scalars["bigint"]["input"]>;
  should_pass?: InputMaybe<Scalars["Boolean"]["input"]>;
  staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  voter_address?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type ProposalVotesStddevFields = {
  num_votes?: Maybe<Scalars["Float"]["output"]>;
  proposal_id?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type ProposalVotesStddevPopFields = {
  num_votes?: Maybe<Scalars["Float"]["output"]>;
  proposal_id?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type ProposalVotesStddevSampFields = {
  num_votes?: Maybe<Scalars["Float"]["output"]>;
  proposal_id?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "proposal_votes" */
export type ProposalVotesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: ProposalVotesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ProposalVotesStreamCursorValueInput = {
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  num_votes?: InputMaybe<Scalars["numeric"]["input"]>;
  proposal_id?: InputMaybe<Scalars["bigint"]["input"]>;
  should_pass?: InputMaybe<Scalars["Boolean"]["input"]>;
  staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  voter_address?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type ProposalVotesSumFields = {
  num_votes?: Maybe<Scalars["numeric"]["output"]>;
  proposal_id?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "proposal_votes" */
export enum ProposalVotesUpdateColumn {
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  NumVotes = "num_votes",
  /** column name */
  ProposalId = "proposal_id",
  /** column name */
  ShouldPass = "should_pass",
  /** column name */
  StakingPoolAddress = "staking_pool_address",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  VoterAddress = "voter_address",
}

export type ProposalVotesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ProposalVotesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ProposalVotesSetInput>;
  /** filter the rows which have to be updated */
  where: ProposalVotesBoolExp;
};

/** aggregate var_pop on columns */
export type ProposalVotesVarPopFields = {
  num_votes?: Maybe<Scalars["Float"]["output"]>;
  proposal_id?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type ProposalVotesVarSampFields = {
  num_votes?: Maybe<Scalars["Float"]["output"]>;
  proposal_id?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type ProposalVotesVarianceFields = {
  num_votes?: Maybe<Scalars["Float"]["output"]>;
  proposal_id?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "public_key_auth_keys" */
export type PublicKeyAuthKeys = {
  account_public_key?: Maybe<Scalars["String"]["output"]>;
  auth_key: Scalars["String"]["output"];
  is_public_key_used: Scalars["Boolean"]["output"];
  last_transaction_version: Scalars["bigint"]["output"];
  public_key: Scalars["String"]["output"];
  public_key_type: Scalars["String"]["output"];
  signature_type: Scalars["String"]["output"];
};

/** aggregated selection of "public_key_auth_keys" */
export type PublicKeyAuthKeysAggregate = {
  aggregate?: Maybe<PublicKeyAuthKeysAggregateFields>;
  nodes: Array<PublicKeyAuthKeys>;
};

/** aggregate fields of "public_key_auth_keys" */
export type PublicKeyAuthKeysAggregateFields = {
  avg?: Maybe<PublicKeyAuthKeysAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<PublicKeyAuthKeysMaxFields>;
  min?: Maybe<PublicKeyAuthKeysMinFields>;
  stddev?: Maybe<PublicKeyAuthKeysStddevFields>;
  stddev_pop?: Maybe<PublicKeyAuthKeysStddevPopFields>;
  stddev_samp?: Maybe<PublicKeyAuthKeysStddevSampFields>;
  sum?: Maybe<PublicKeyAuthKeysSumFields>;
  var_pop?: Maybe<PublicKeyAuthKeysVarPopFields>;
  var_samp?: Maybe<PublicKeyAuthKeysVarSampFields>;
  variance?: Maybe<PublicKeyAuthKeysVarianceFields>;
};

/** aggregate fields of "public_key_auth_keys" */
export type PublicKeyAuthKeysAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PublicKeyAuthKeysSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type PublicKeyAuthKeysAvgFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "public_key_auth_keys". All fields are combined with a logical 'AND'. */
export type PublicKeyAuthKeysBoolExp = {
  _and?: InputMaybe<Array<PublicKeyAuthKeysBoolExp>>;
  _not?: InputMaybe<PublicKeyAuthKeysBoolExp>;
  _or?: InputMaybe<Array<PublicKeyAuthKeysBoolExp>>;
  account_public_key?: InputMaybe<StringComparisonExp>;
  auth_key?: InputMaybe<StringComparisonExp>;
  is_public_key_used?: InputMaybe<BooleanComparisonExp>;
  last_transaction_version?: InputMaybe<BigintComparisonExp>;
  public_key?: InputMaybe<StringComparisonExp>;
  public_key_type?: InputMaybe<StringComparisonExp>;
  signature_type?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "public_key_auth_keys" */
export enum PublicKeyAuthKeysConstraint {
  /** unique or primary key constraint on columns "public_key_type", "auth_key", "public_key" */
  PublicKeyAuthKeysPkey = "public_key_auth_keys_pkey",
}

/** input type for incrementing numeric columns in table "public_key_auth_keys" */
export type PublicKeyAuthKeysIncInput = {
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "public_key_auth_keys" */
export type PublicKeyAuthKeysInsertInput = {
  account_public_key?: InputMaybe<Scalars["String"]["input"]>;
  auth_key?: InputMaybe<Scalars["String"]["input"]>;
  is_public_key_used?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  public_key?: InputMaybe<Scalars["String"]["input"]>;
  public_key_type?: InputMaybe<Scalars["String"]["input"]>;
  signature_type?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type PublicKeyAuthKeysMaxFields = {
  account_public_key?: Maybe<Scalars["String"]["output"]>;
  auth_key?: Maybe<Scalars["String"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  public_key?: Maybe<Scalars["String"]["output"]>;
  public_key_type?: Maybe<Scalars["String"]["output"]>;
  signature_type?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type PublicKeyAuthKeysMinFields = {
  account_public_key?: Maybe<Scalars["String"]["output"]>;
  auth_key?: Maybe<Scalars["String"]["output"]>;
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  public_key?: Maybe<Scalars["String"]["output"]>;
  public_key_type?: Maybe<Scalars["String"]["output"]>;
  signature_type?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "public_key_auth_keys" */
export type PublicKeyAuthKeysMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<PublicKeyAuthKeys>;
};

/** on_conflict condition type for table "public_key_auth_keys" */
export type PublicKeyAuthKeysOnConflict = {
  constraint: PublicKeyAuthKeysConstraint;
  update_columns?: Array<PublicKeyAuthKeysUpdateColumn>;
  where?: InputMaybe<PublicKeyAuthKeysBoolExp>;
};

/** Ordering options when selecting data from "public_key_auth_keys". */
export type PublicKeyAuthKeysOrderBy = {
  account_public_key?: InputMaybe<OrderBy>;
  auth_key?: InputMaybe<OrderBy>;
  is_public_key_used?: InputMaybe<OrderBy>;
  last_transaction_version?: InputMaybe<OrderBy>;
  public_key?: InputMaybe<OrderBy>;
  public_key_type?: InputMaybe<OrderBy>;
  signature_type?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: public_key_auth_keys */
export type PublicKeyAuthKeysPkColumnsInput = {
  auth_key: Scalars["String"]["input"];
  public_key: Scalars["String"]["input"];
  public_key_type: Scalars["String"]["input"];
};

/** select columns of table "public_key_auth_keys" */
export enum PublicKeyAuthKeysSelectColumn {
  /** column name */
  AccountPublicKey = "account_public_key",
  /** column name */
  AuthKey = "auth_key",
  /** column name */
  IsPublicKeyUsed = "is_public_key_used",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  PublicKey = "public_key",
  /** column name */
  PublicKeyType = "public_key_type",
  /** column name */
  SignatureType = "signature_type",
}

/** input type for updating data in table "public_key_auth_keys" */
export type PublicKeyAuthKeysSetInput = {
  account_public_key?: InputMaybe<Scalars["String"]["input"]>;
  auth_key?: InputMaybe<Scalars["String"]["input"]>;
  is_public_key_used?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  public_key?: InputMaybe<Scalars["String"]["input"]>;
  public_key_type?: InputMaybe<Scalars["String"]["input"]>;
  signature_type?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type PublicKeyAuthKeysStddevFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type PublicKeyAuthKeysStddevPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type PublicKeyAuthKeysStddevSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "public_key_auth_keys" */
export type PublicKeyAuthKeysStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: PublicKeyAuthKeysStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PublicKeyAuthKeysStreamCursorValueInput = {
  account_public_key?: InputMaybe<Scalars["String"]["input"]>;
  auth_key?: InputMaybe<Scalars["String"]["input"]>;
  is_public_key_used?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  public_key?: InputMaybe<Scalars["String"]["input"]>;
  public_key_type?: InputMaybe<Scalars["String"]["input"]>;
  signature_type?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type PublicKeyAuthKeysSumFields = {
  last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "public_key_auth_keys" */
export enum PublicKeyAuthKeysUpdateColumn {
  /** column name */
  AccountPublicKey = "account_public_key",
  /** column name */
  AuthKey = "auth_key",
  /** column name */
  IsPublicKeyUsed = "is_public_key_used",
  /** column name */
  LastTransactionVersion = "last_transaction_version",
  /** column name */
  PublicKey = "public_key",
  /** column name */
  PublicKeyType = "public_key_type",
  /** column name */
  SignatureType = "signature_type",
}

export type PublicKeyAuthKeysUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PublicKeyAuthKeysIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PublicKeyAuthKeysSetInput>;
  /** filter the rows which have to be updated */
  where: PublicKeyAuthKeysBoolExp;
};

/** aggregate var_pop on columns */
export type PublicKeyAuthKeysVarPopFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type PublicKeyAuthKeysVarSampFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type PublicKeyAuthKeysVarianceFields = {
  last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

export type QueryRoot = {
  /** fetch data from the table: "account_transactions" */
  account_transactions: Array<AccountTransactions>;
  /** fetch aggregated fields from the table: "account_transactions" */
  account_transactions_aggregate: AccountTransactionsAggregate;
  /** fetch data from the table: "account_transactions" using primary key columns */
  account_transactions_by_pk?: Maybe<AccountTransactions>;
  /** fetch data from the table: "address_events_summary" */
  address_events_summary: Array<AddressEventsSummary>;
  /** fetch aggregated fields from the table: "address_events_summary" */
  address_events_summary_aggregate: AddressEventsSummaryAggregate;
  /** fetch data from the table: "address_version_from_events" */
  address_version_from_events: Array<AddressVersionFromEvents>;
  /** fetch aggregated fields from the table: "address_version_from_events" */
  address_version_from_events_aggregate: AddressVersionFromEventsAggregate;
  /** fetch data from the table: "address_version_from_move_resources" */
  address_version_from_move_resources: Array<AddressVersionFromMoveResources>;
  /** fetch aggregated fields from the table: "address_version_from_move_resources" */
  address_version_from_move_resources_aggregate: AddressVersionFromMoveResourcesAggregate;
  /** fetch data from the table: "ans_lookup" */
  ans_lookup: Array<AnsLookup>;
  /** fetch aggregated fields from the table: "ans_lookup" */
  ans_lookup_aggregate: AnsLookupAggregate;
  /** fetch data from the table: "ans_lookup" using primary key columns */
  ans_lookup_by_pk?: Maybe<AnsLookup>;
  /** fetch data from the table: "ans_lookup_v2" */
  ans_lookup_v2: Array<AnsLookupV2>;
  /** fetch aggregated fields from the table: "ans_lookup_v2" */
  ans_lookup_v2_aggregate: AnsLookupV2Aggregate;
  /** fetch data from the table: "ans_lookup_v2" using primary key columns */
  ans_lookup_v2_by_pk?: Maybe<AnsLookupV2>;
  /** fetch data from the table: "ans_primary_name" */
  ans_primary_name: Array<AnsPrimaryName>;
  /** fetch aggregated fields from the table: "ans_primary_name" */
  ans_primary_name_aggregate: AnsPrimaryNameAggregate;
  /** fetch data from the table: "ans_primary_name" using primary key columns */
  ans_primary_name_by_pk?: Maybe<AnsPrimaryName>;
  /** fetch data from the table: "ans_primary_name_v2" */
  ans_primary_name_v2: Array<AnsPrimaryNameV2>;
  /** fetch aggregated fields from the table: "ans_primary_name_v2" */
  ans_primary_name_v2_aggregate: AnsPrimaryNameV2Aggregate;
  /** fetch data from the table: "ans_primary_name_v2" using primary key columns */
  ans_primary_name_v2_by_pk?: Maybe<AnsPrimaryNameV2>;
  /** fetch data from the table: "auth_key_account_addresses" */
  auth_key_account_addresses: Array<AuthKeyAccountAddresses>;
  /** fetch aggregated fields from the table: "auth_key_account_addresses" */
  auth_key_account_addresses_aggregate: AuthKeyAccountAddressesAggregate;
  /** fetch data from the table: "auth_key_account_addresses" using primary key columns */
  auth_key_account_addresses_by_pk?: Maybe<AuthKeyAccountAddresses>;
  /** fetch data from the table: "block_metadata_transactions" */
  block_metadata_transactions: Array<BlockMetadataTransactions>;
  /** fetch aggregated fields from the table: "block_metadata_transactions" */
  block_metadata_transactions_aggregate: BlockMetadataTransactionsAggregate;
  /** fetch data from the table: "block_metadata_transactions" using primary key columns */
  block_metadata_transactions_by_pk?: Maybe<BlockMetadataTransactions>;
  /** fetch data from the table: "coin_activities" */
  coin_activities: Array<CoinActivities>;
  /** fetch aggregated fields from the table: "coin_activities" */
  coin_activities_aggregate: CoinActivitiesAggregate;
  /** fetch data from the table: "coin_activities" using primary key columns */
  coin_activities_by_pk?: Maybe<CoinActivities>;
  /** fetch data from the table: "coin_balances" */
  coin_balances: Array<CoinBalances>;
  /** fetch aggregated fields from the table: "coin_balances" */
  coin_balances_aggregate: CoinBalancesAggregate;
  /** fetch data from the table: "coin_balances" using primary key columns */
  coin_balances_by_pk?: Maybe<CoinBalances>;
  /** fetch data from the table: "coin_infos" */
  coin_infos: Array<CoinInfos>;
  /** fetch aggregated fields from the table: "coin_infos" */
  coin_infos_aggregate: CoinInfosAggregate;
  /** fetch data from the table: "coin_infos" using primary key columns */
  coin_infos_by_pk?: Maybe<CoinInfos>;
  /** fetch data from the table: "coin_supply" */
  coin_supply: Array<CoinSupply>;
  /** fetch aggregated fields from the table: "coin_supply" */
  coin_supply_aggregate: CoinSupplyAggregate;
  /** fetch data from the table: "coin_supply" using primary key columns */
  coin_supply_by_pk?: Maybe<CoinSupply>;
  /** fetch data from the table: "collection_datas" */
  collection_datas: Array<CollectionDatas>;
  /** fetch aggregated fields from the table: "collection_datas" */
  collection_datas_aggregate: CollectionDatasAggregate;
  /** fetch data from the table: "collection_datas" using primary key columns */
  collection_datas_by_pk?: Maybe<CollectionDatas>;
  /** fetch data from the table: "collections_v2" */
  collections_v2: Array<CollectionsV2>;
  /** fetch aggregated fields from the table: "collections_v2" */
  collections_v2_aggregate: CollectionsV2Aggregate;
  /** fetch data from the table: "collections_v2" using primary key columns */
  collections_v2_by_pk?: Maybe<CollectionsV2>;
  /** fetch data from the table: "current_ans_lookup" */
  current_ans_lookup: Array<CurrentAnsLookup>;
  /** fetch aggregated fields from the table: "current_ans_lookup" */
  current_ans_lookup_aggregate: CurrentAnsLookupAggregate;
  /** fetch data from the table: "current_ans_lookup" using primary key columns */
  current_ans_lookup_by_pk?: Maybe<CurrentAnsLookup>;
  /** fetch data from the table: "current_ans_lookup_v2" */
  current_ans_lookup_v2: Array<CurrentAnsLookupV2>;
  /** fetch aggregated fields from the table: "current_ans_lookup_v2" */
  current_ans_lookup_v2_aggregate: CurrentAnsLookupV2Aggregate;
  /** fetch data from the table: "current_ans_lookup_v2" using primary key columns */
  current_ans_lookup_v2_by_pk?: Maybe<CurrentAnsLookupV2>;
  /** fetch data from the table: "current_ans_primary_name" */
  current_ans_primary_name: Array<CurrentAnsPrimaryName>;
  /** fetch aggregated fields from the table: "current_ans_primary_name" */
  current_ans_primary_name_aggregate: CurrentAnsPrimaryNameAggregate;
  /** fetch data from the table: "current_ans_primary_name" using primary key columns */
  current_ans_primary_name_by_pk?: Maybe<CurrentAnsPrimaryName>;
  /** fetch data from the table: "current_ans_primary_name_v2" */
  current_ans_primary_name_v2: Array<CurrentAnsPrimaryNameV2>;
  /** fetch aggregated fields from the table: "current_ans_primary_name_v2" */
  current_ans_primary_name_v2_aggregate: CurrentAnsPrimaryNameV2Aggregate;
  /** fetch data from the table: "current_ans_primary_name_v2" using primary key columns */
  current_ans_primary_name_v2_by_pk?: Maybe<CurrentAnsPrimaryNameV2>;
  /** fetch data from the table: "current_cedra_names" */
  current_cedra_names: Array<CurrentCedraNames>;
  /** fetch aggregated fields from the table: "current_cedra_names" */
  current_cedra_names_aggregate: CurrentCedraNamesAggregate;
  /** fetch data from the table: "current_coin_balances" */
  current_coin_balances: Array<CurrentCoinBalances>;
  /** fetch aggregated fields from the table: "current_coin_balances" */
  current_coin_balances_aggregate: CurrentCoinBalancesAggregate;
  /** fetch data from the table: "current_coin_balances" using primary key columns */
  current_coin_balances_by_pk?: Maybe<CurrentCoinBalances>;
  /** fetch data from the table: "current_collection_datas" */
  current_collection_datas: Array<CurrentCollectionDatas>;
  /** fetch aggregated fields from the table: "current_collection_datas" */
  current_collection_datas_aggregate: CurrentCollectionDatasAggregate;
  /** fetch data from the table: "current_collection_datas" using primary key columns */
  current_collection_datas_by_pk?: Maybe<CurrentCollectionDatas>;
  /** fetch data from the table: "current_collection_ownership_v2_view" */
  current_collection_ownership_v2_view: Array<CurrentCollectionOwnershipV2View>;
  /** fetch aggregated fields from the table: "current_collection_ownership_v2_view" */
  current_collection_ownership_v2_view_aggregate: CurrentCollectionOwnershipV2ViewAggregate;
  /** fetch data from the table: "current_collection_ownership_view" */
  current_collection_ownership_view: Array<CurrentCollectionOwnershipView>;
  /** fetch aggregated fields from the table: "current_collection_ownership_view" */
  current_collection_ownership_view_aggregate: CurrentCollectionOwnershipViewAggregate;
  /** fetch data from the table: "current_collections_v2" */
  current_collections_v2: Array<CurrentCollectionsV2>;
  /** fetch aggregated fields from the table: "current_collections_v2" */
  current_collections_v2_aggregate: CurrentCollectionsV2Aggregate;
  /** fetch data from the table: "current_collections_v2" using primary key columns */
  current_collections_v2_by_pk?: Maybe<CurrentCollectionsV2>;
  /** fetch data from the table: "current_delegated_staking_pool_balances" */
  current_delegated_staking_pool_balances: Array<CurrentDelegatedStakingPoolBalances>;
  /** fetch aggregated fields from the table: "current_delegated_staking_pool_balances" */
  current_delegated_staking_pool_balances_aggregate: CurrentDelegatedStakingPoolBalancesAggregate;
  /** fetch data from the table: "current_delegated_staking_pool_balances" using primary key columns */
  current_delegated_staking_pool_balances_by_pk?: Maybe<CurrentDelegatedStakingPoolBalances>;
  /** fetch data from the table: "current_delegated_voter" */
  current_delegated_voter: Array<CurrentDelegatedVoter>;
  /** fetch aggregated fields from the table: "current_delegated_voter" */
  current_delegated_voter_aggregate: CurrentDelegatedVoterAggregate;
  /** fetch data from the table: "current_delegated_voter" using primary key columns */
  current_delegated_voter_by_pk?: Maybe<CurrentDelegatedVoter>;
  /** fetch data from the table: "current_delegator_balances" */
  current_delegator_balances: Array<CurrentDelegatorBalances>;
  /** fetch aggregated fields from the table: "current_delegator_balances" */
  current_delegator_balances_aggregate: CurrentDelegatorBalancesAggregate;
  /** fetch data from the table: "current_delegator_balances" using primary key columns */
  current_delegator_balances_by_pk?: Maybe<CurrentDelegatorBalances>;
  /** fetch data from the table: "current_fungible_asset_balances_legacy" */
  current_fungible_asset_balances: Array<CurrentFungibleAssetBalances>;
  /** fetch aggregated fields from the table: "current_fungible_asset_balances_legacy" */
  current_fungible_asset_balances_aggregate: CurrentFungibleAssetBalancesAggregate;
  /** fetch data from the table: "current_fungible_asset_balances_legacy" using primary key columns */
  current_fungible_asset_balances_by_pk?: Maybe<CurrentFungibleAssetBalances>;
  /** fetch data from the table: "current_fungible_asset_balances" */
  current_fungible_asset_balances_new: Array<CurrentFungibleAssetBalancesNew>;
  /** fetch aggregated fields from the table: "current_fungible_asset_balances" */
  current_fungible_asset_balances_new_aggregate: CurrentFungibleAssetBalancesNewAggregate;
  /** fetch data from the table: "current_fungible_asset_balances" using primary key columns */
  current_fungible_asset_balances_new_by_pk?: Maybe<CurrentFungibleAssetBalancesNew>;
  /** fetch data from the table: "current_objects" */
  current_objects: Array<CurrentObjects>;
  /** fetch aggregated fields from the table: "current_objects" */
  current_objects_aggregate: CurrentObjectsAggregate;
  /** fetch data from the table: "current_objects" using primary key columns */
  current_objects_by_pk?: Maybe<CurrentObjects>;
  /** fetch data from the table: "current_staking_pool_voter" */
  current_staking_pool_voter: Array<CurrentStakingPoolVoter>;
  /** fetch aggregated fields from the table: "current_staking_pool_voter" */
  current_staking_pool_voter_aggregate: CurrentStakingPoolVoterAggregate;
  /** fetch data from the table: "current_staking_pool_voter" using primary key columns */
  current_staking_pool_voter_by_pk?: Maybe<CurrentStakingPoolVoter>;
  /** fetch data from the table: "current_table_items" */
  current_table_items: Array<CurrentTableItems>;
  /** fetch aggregated fields from the table: "current_table_items" */
  current_table_items_aggregate: CurrentTableItemsAggregate;
  /** fetch data from the table: "current_table_items" using primary key columns */
  current_table_items_by_pk?: Maybe<CurrentTableItems>;
  /** fetch data from the table: "current_table_items_view" */
  current_table_items_view: Array<CurrentTableItemsView>;
  /** fetch aggregated fields from the table: "current_table_items_view" */
  current_table_items_view_aggregate: CurrentTableItemsViewAggregate;
  /** fetch data from the table: "current_token_datas" */
  current_token_datas: Array<CurrentTokenDatas>;
  /** fetch aggregated fields from the table: "current_token_datas" */
  current_token_datas_aggregate: CurrentTokenDatasAggregate;
  /** fetch data from the table: "current_token_datas" using primary key columns */
  current_token_datas_by_pk?: Maybe<CurrentTokenDatas>;
  /** fetch data from the table: "current_token_datas_v2" */
  current_token_datas_v2: Array<CurrentTokenDatasV2>;
  /** fetch aggregated fields from the table: "current_token_datas_v2" */
  current_token_datas_v2_aggregate: CurrentTokenDatasV2Aggregate;
  /** fetch data from the table: "current_token_datas_v2" using primary key columns */
  current_token_datas_v2_by_pk?: Maybe<CurrentTokenDatasV2>;
  /** fetch data from the table: "current_token_ownerships" */
  current_token_ownerships: Array<CurrentTokenOwnerships>;
  /** fetch aggregated fields from the table: "current_token_ownerships" */
  current_token_ownerships_aggregate: CurrentTokenOwnershipsAggregate;
  /** fetch data from the table: "current_token_ownerships" using primary key columns */
  current_token_ownerships_by_pk?: Maybe<CurrentTokenOwnerships>;
  /** fetch data from the table: "current_token_ownerships_v2" */
  current_token_ownerships_v2: Array<CurrentTokenOwnershipsV2>;
  /** fetch aggregated fields from the table: "current_token_ownerships_v2" */
  current_token_ownerships_v2_aggregate: CurrentTokenOwnershipsV2Aggregate;
  /** fetch data from the table: "current_token_ownerships_v2" using primary key columns */
  current_token_ownerships_v2_by_pk?: Maybe<CurrentTokenOwnershipsV2>;
  /** fetch data from the table: "current_token_pending_claims" */
  current_token_pending_claims: Array<CurrentTokenPendingClaims>;
  /** fetch aggregated fields from the table: "current_token_pending_claims" */
  current_token_pending_claims_aggregate: CurrentTokenPendingClaimsAggregate;
  /** fetch data from the table: "current_token_pending_claims" using primary key columns */
  current_token_pending_claims_by_pk?: Maybe<CurrentTokenPendingClaims>;
  /** fetch data from the table: "current_token_royalty_v1" */
  current_token_royalty_v1: Array<CurrentTokenRoyaltyV1>;
  /** fetch aggregated fields from the table: "current_token_royalty_v1" */
  current_token_royalty_v1_aggregate: CurrentTokenRoyaltyV1Aggregate;
  /** fetch data from the table: "current_token_royalty_v1" using primary key columns */
  current_token_royalty_v1_by_pk?: Maybe<CurrentTokenRoyaltyV1>;
  /** fetch data from the table: "current_token_v2_metadata" */
  current_token_v2_metadata: Array<CurrentTokenV2Metadata>;
  /** fetch aggregated fields from the table: "current_token_v2_metadata" */
  current_token_v2_metadata_aggregate: CurrentTokenV2MetadataAggregate;
  /** fetch data from the table: "current_token_v2_metadata" using primary key columns */
  current_token_v2_metadata_by_pk?: Maybe<CurrentTokenV2Metadata>;
  /** fetch data from the table: "delegated_staking_activities" */
  delegated_staking_activities: Array<DelegatedStakingActivities>;
  /** fetch aggregated fields from the table: "delegated_staking_activities" */
  delegated_staking_activities_aggregate: DelegatedStakingActivitiesAggregate;
  /** fetch data from the table: "delegated_staking_activities" using primary key columns */
  delegated_staking_activities_by_pk?: Maybe<DelegatedStakingActivities>;
  /** fetch data from the table: "delegated_staking_pool_balances" */
  delegated_staking_pool_balances: Array<DelegatedStakingPoolBalances>;
  /** fetch aggregated fields from the table: "delegated_staking_pool_balances" */
  delegated_staking_pool_balances_aggregate: DelegatedStakingPoolBalancesAggregate;
  /** fetch data from the table: "delegated_staking_pool_balances" using primary key columns */
  delegated_staking_pool_balances_by_pk?: Maybe<DelegatedStakingPoolBalances>;
  /** fetch data from the table: "delegated_staking_pools" */
  delegated_staking_pools: Array<DelegatedStakingPools>;
  /** fetch aggregated fields from the table: "delegated_staking_pools" */
  delegated_staking_pools_aggregate: DelegatedStakingPoolsAggregate;
  /** fetch data from the table: "delegated_staking_pools" using primary key columns */
  delegated_staking_pools_by_pk?: Maybe<DelegatedStakingPools>;
  /** fetch data from the table: "delegator_balances" */
  delegator_balances: Array<DelegatorBalances>;
  /** fetch aggregated fields from the table: "delegator_balances" */
  delegator_balances_aggregate: DelegatorBalancesAggregate;
  /** fetch data from the table: "delegator_balances" using primary key columns */
  delegator_balances_by_pk?: Maybe<DelegatorBalances>;
  /** fetch data from the table: "delegator_distinct_pool" */
  delegator_distinct_pool: Array<DelegatorDistinctPool>;
  /** fetch aggregated fields from the table: "delegator_distinct_pool" */
  delegator_distinct_pool_aggregate: DelegatorDistinctPoolAggregate;
  /** fetch data from the table: "event_size_info" */
  event_size_info: Array<EventSizeInfo>;
  /** fetch aggregated fields from the table: "event_size_info" */
  event_size_info_aggregate: EventSizeInfoAggregate;
  /** fetch data from the table: "event_size_info" using primary key columns */
  event_size_info_by_pk?: Maybe<EventSizeInfo>;
  /** fetch data from the table: "events" */
  events: Array<Events>;
  /** fetch aggregated fields from the table: "events" */
  events_aggregate: EventsAggregate;
  /** fetch data from the table: "events" using primary key columns */
  events_by_pk?: Maybe<Events>;
  /** fetch data from the table: "events_view" */
  events_view: Array<EventsView>;
  /** fetch aggregated fields from the table: "events_view" */
  events_view_aggregate: EventsViewAggregate;
  /** fetch data from the table: "fungible_asset_activities" */
  fungible_asset_activities: Array<FungibleAssetActivities>;
  /** fetch aggregated fields from the table: "fungible_asset_activities" */
  fungible_asset_activities_aggregate: FungibleAssetActivitiesAggregate;
  /** fetch data from the table: "fungible_asset_activities" using primary key columns */
  fungible_asset_activities_by_pk?: Maybe<FungibleAssetActivities>;
  /** fetch data from the table: "fungible_asset_balances" */
  fungible_asset_balances: Array<FungibleAssetBalances>;
  /** fetch aggregated fields from the table: "fungible_asset_balances" */
  fungible_asset_balances_aggregate: FungibleAssetBalancesAggregate;
  /** fetch data from the table: "fungible_asset_balances" using primary key columns */
  fungible_asset_balances_by_pk?: Maybe<FungibleAssetBalances>;
  /** fetch data from the table: "fungible_asset_metadata" */
  fungible_asset_metadata: Array<FungibleAssetMetadata>;
  /** fetch aggregated fields from the table: "fungible_asset_metadata" */
  fungible_asset_metadata_aggregate: FungibleAssetMetadataAggregate;
  /** fetch data from the table: "fungible_asset_metadata" using primary key columns */
  fungible_asset_metadata_by_pk?: Maybe<FungibleAssetMetadata>;
  /** fetch data from the table: "fungible_asset_to_coin_mappings" */
  fungible_asset_to_coin_mappings: Array<FungibleAssetToCoinMappings>;
  /** fetch aggregated fields from the table: "fungible_asset_to_coin_mappings" */
  fungible_asset_to_coin_mappings_aggregate: FungibleAssetToCoinMappingsAggregate;
  /** fetch data from the table: "fungible_asset_to_coin_mappings" using primary key columns */
  fungible_asset_to_coin_mappings_by_pk?: Maybe<FungibleAssetToCoinMappings>;
  /** fetch data from the table: "gas_fees" */
  gas_fees: Array<GasFees>;
  /** fetch aggregated fields from the table: "gas_fees" */
  gas_fees_aggregate: GasFeesAggregate;
  /** fetch data from the table: "gas_fees" using primary key columns */
  gas_fees_by_pk?: Maybe<GasFees>;
  /** fetch data from the table: "indexer_status" */
  indexer_status: Array<IndexerStatus>;
  /** fetch aggregated fields from the table: "indexer_status" */
  indexer_status_aggregate: IndexerStatusAggregate;
  /** fetch data from the table: "indexer_status" using primary key columns */
  indexer_status_by_pk?: Maybe<IndexerStatus>;
  /** fetch data from the table: "move_modules" */
  move_modules: Array<MoveModules>;
  /** fetch aggregated fields from the table: "move_modules" */
  move_modules_aggregate: MoveModulesAggregate;
  /** fetch data from the table: "move_modules" using primary key columns */
  move_modules_by_pk?: Maybe<MoveModules>;
  /** fetch data from the table: "move_resources" */
  move_resources: Array<MoveResources>;
  /** fetch aggregated fields from the table: "move_resources" */
  move_resources_aggregate: MoveResourcesAggregate;
  /** fetch data from the table: "move_resources" using primary key columns */
  move_resources_by_pk?: Maybe<MoveResources>;
  /** fetch data from the table: "move_resources_view" */
  move_resources_view: Array<MoveResourcesView>;
  /** fetch aggregated fields from the table: "move_resources_view" */
  move_resources_view_aggregate: MoveResourcesViewAggregate;
  /** fetch data from the table: "nft_metadata_crawler.parsed_asset_uris" */
  nft_metadata_crawler_parsed_asset_uris: Array<NftMetadataCrawlerParsedAssetUris>;
  /** fetch aggregated fields from the table: "nft_metadata_crawler.parsed_asset_uris" */
  nft_metadata_crawler_parsed_asset_uris_aggregate: NftMetadataCrawlerParsedAssetUrisAggregate;
  /** fetch data from the table: "nft_metadata_crawler.parsed_asset_uris" using primary key columns */
  nft_metadata_crawler_parsed_asset_uris_by_pk?: Maybe<NftMetadataCrawlerParsedAssetUris>;
  /** fetch data from the table: "nft_points" */
  nft_points: Array<NftPoints>;
  /** fetch aggregated fields from the table: "nft_points" */
  nft_points_aggregate: NftPointsAggregate;
  /** fetch data from the table: "nft_points" using primary key columns */
  nft_points_by_pk?: Maybe<NftPoints>;
  /** fetch data from the table: "num_active_delegator_per_pool" */
  num_active_delegator_per_pool: Array<NumActiveDelegatorPerPool>;
  /** fetch aggregated fields from the table: "num_active_delegator_per_pool" */
  num_active_delegator_per_pool_aggregate: NumActiveDelegatorPerPoolAggregate;
  /** fetch data from the table: "objects" */
  objects: Array<Objects>;
  /** fetch aggregated fields from the table: "objects" */
  objects_aggregate: ObjectsAggregate;
  /** fetch data from the table: "objects" using primary key columns */
  objects_by_pk?: Maybe<Objects>;
  /** fetch data from the table: "processor_metadata.processor_status" */
  processor_metadata_processor_status: Array<ProcessorMetadataProcessorStatus>;
  /** fetch aggregated fields from the table: "processor_metadata.processor_status" */
  processor_metadata_processor_status_aggregate: ProcessorMetadataProcessorStatusAggregate;
  /** fetch data from the table: "processor_metadata.processor_status" using primary key columns */
  processor_metadata_processor_status_by_pk?: Maybe<ProcessorMetadataProcessorStatus>;
  /** fetch data from the table: "processor_status" */
  processor_status: Array<ProcessorStatus>;
  /** fetch aggregated fields from the table: "processor_status" */
  processor_status_aggregate: ProcessorStatusAggregate;
  /** fetch data from the table: "processor_status" using primary key columns */
  processor_status_by_pk?: Maybe<ProcessorStatus>;
  /** fetch data from the table: "proposal_votes" */
  proposal_votes: Array<ProposalVotes>;
  /** fetch aggregated fields from the table: "proposal_votes" */
  proposal_votes_aggregate: ProposalVotesAggregate;
  /** fetch data from the table: "proposal_votes" using primary key columns */
  proposal_votes_by_pk?: Maybe<ProposalVotes>;
  /** fetch data from the table: "public_key_auth_keys" */
  public_key_auth_keys: Array<PublicKeyAuthKeys>;
  /** fetch aggregated fields from the table: "public_key_auth_keys" */
  public_key_auth_keys_aggregate: PublicKeyAuthKeysAggregate;
  /** fetch data from the table: "public_key_auth_keys" using primary key columns */
  public_key_auth_keys_by_pk?: Maybe<PublicKeyAuthKeys>;
  /** fetch data from the table: "signatures" */
  signatures: Array<Signatures>;
  /** fetch aggregated fields from the table: "signatures" */
  signatures_aggregate: SignaturesAggregate;
  /** fetch data from the table: "signatures" using primary key columns */
  signatures_by_pk?: Maybe<Signatures>;
  /** fetch data from the table: "spam_assets" */
  spam_assets: Array<SpamAssets>;
  /** fetch aggregated fields from the table: "spam_assets" */
  spam_assets_aggregate: SpamAssetsAggregate;
  /** fetch data from the table: "spam_assets" using primary key columns */
  spam_assets_by_pk?: Maybe<SpamAssets>;
  /** fetch data from the table: "table_items" */
  table_items: Array<TableItems>;
  /** fetch aggregated fields from the table: "table_items" */
  table_items_aggregate: TableItemsAggregate;
  /** fetch data from the table: "table_items" using primary key columns */
  table_items_by_pk?: Maybe<TableItems>;
  /** fetch data from the table: "table_items_view" */
  table_items_view: Array<TableItemsView>;
  /** fetch aggregated fields from the table: "table_items_view" */
  table_items_view_aggregate: TableItemsViewAggregate;
  /** fetch data from the table: "table_metadatas" */
  table_metadatas: Array<TableMetadatas>;
  /** fetch aggregated fields from the table: "table_metadatas" */
  table_metadatas_aggregate: TableMetadatasAggregate;
  /** fetch data from the table: "table_metadatas" using primary key columns */
  table_metadatas_by_pk?: Maybe<TableMetadatas>;
  /** fetch data from the table: "token_activities" */
  token_activities: Array<TokenActivities>;
  /** fetch aggregated fields from the table: "token_activities" */
  token_activities_aggregate: TokenActivitiesAggregate;
  /** fetch data from the table: "token_activities" using primary key columns */
  token_activities_by_pk?: Maybe<TokenActivities>;
  /** fetch data from the table: "token_activities_v2" */
  token_activities_v2: Array<TokenActivitiesV2>;
  /** fetch aggregated fields from the table: "token_activities_v2" */
  token_activities_v2_aggregate: TokenActivitiesV2Aggregate;
  /** fetch data from the table: "token_activities_v2" using primary key columns */
  token_activities_v2_by_pk?: Maybe<TokenActivitiesV2>;
  /** fetch data from the table: "token_datas" */
  token_datas: Array<TokenDatas>;
  /** fetch aggregated fields from the table: "token_datas" */
  token_datas_aggregate: TokenDatasAggregate;
  /** fetch data from the table: "token_datas" using primary key columns */
  token_datas_by_pk?: Maybe<TokenDatas>;
  /** fetch data from the table: "token_datas_v2" */
  token_datas_v2: Array<TokenDatasV2>;
  /** fetch aggregated fields from the table: "token_datas_v2" */
  token_datas_v2_aggregate: TokenDatasV2Aggregate;
  /** fetch data from the table: "token_datas_v2" using primary key columns */
  token_datas_v2_by_pk?: Maybe<TokenDatasV2>;
  /** fetch data from the table: "token_ownerships" */
  token_ownerships: Array<TokenOwnerships>;
  /** fetch aggregated fields from the table: "token_ownerships" */
  token_ownerships_aggregate: TokenOwnershipsAggregate;
  /** fetch data from the table: "token_ownerships" using primary key columns */
  token_ownerships_by_pk?: Maybe<TokenOwnerships>;
  /** fetch data from the table: "token_ownerships_v2" */
  token_ownerships_v2: Array<TokenOwnershipsV2>;
  /** fetch aggregated fields from the table: "token_ownerships_v2" */
  token_ownerships_v2_aggregate: TokenOwnershipsV2Aggregate;
  /** fetch data from the table: "token_ownerships_v2" using primary key columns */
  token_ownerships_v2_by_pk?: Maybe<TokenOwnershipsV2>;
  /** fetch data from the table: "tokens" */
  tokens: Array<Tokens>;
  /** fetch aggregated fields from the table: "tokens" */
  tokens_aggregate: TokensAggregate;
  /** fetch data from the table: "tokens" using primary key columns */
  tokens_by_pk?: Maybe<Tokens>;
  /** fetch data from the table: "transaction_size_info" */
  transaction_size_info: Array<TransactionSizeInfo>;
  /** fetch aggregated fields from the table: "transaction_size_info" */
  transaction_size_info_aggregate: TransactionSizeInfoAggregate;
  /** fetch data from the table: "transaction_size_info" using primary key columns */
  transaction_size_info_by_pk?: Maybe<TransactionSizeInfo>;
  /** fetch data from the table: "transactions_view" */
  transactions_view: Array<TransactionsView>;
  /** fetch aggregated fields from the table: "transactions_view" */
  transactions_view_aggregate: TransactionsViewAggregate;
  /** fetch data from the table: "user_transactions" */
  user_transactions: Array<UserTransactions>;
  /** fetch aggregated fields from the table: "user_transactions" */
  user_transactions_aggregate: UserTransactionsAggregate;
  /** fetch data from the table: "user_transactions" using primary key columns */
  user_transactions_by_pk?: Maybe<UserTransactions>;
};

export type QueryRootAccountTransactionsArgs = {
  distinct_on?: InputMaybe<Array<AccountTransactionsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AccountTransactionsOrderBy>>;
  where?: InputMaybe<AccountTransactionsBoolExp>;
};

export type QueryRootAccountTransactionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<AccountTransactionsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AccountTransactionsOrderBy>>;
  where?: InputMaybe<AccountTransactionsBoolExp>;
};

export type QueryRootAccountTransactionsByPkArgs = {
  account_address: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type QueryRootAddressEventsSummaryArgs = {
  distinct_on?: InputMaybe<Array<AddressEventsSummarySelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AddressEventsSummaryOrderBy>>;
  where?: InputMaybe<AddressEventsSummaryBoolExp>;
};

export type QueryRootAddressEventsSummaryAggregateArgs = {
  distinct_on?: InputMaybe<Array<AddressEventsSummarySelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AddressEventsSummaryOrderBy>>;
  where?: InputMaybe<AddressEventsSummaryBoolExp>;
};

export type QueryRootAddressVersionFromEventsArgs = {
  distinct_on?: InputMaybe<Array<AddressVersionFromEventsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AddressVersionFromEventsOrderBy>>;
  where?: InputMaybe<AddressVersionFromEventsBoolExp>;
};

export type QueryRootAddressVersionFromEventsAggregateArgs = {
  distinct_on?: InputMaybe<Array<AddressVersionFromEventsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AddressVersionFromEventsOrderBy>>;
  where?: InputMaybe<AddressVersionFromEventsBoolExp>;
};

export type QueryRootAddressVersionFromMoveResourcesArgs = {
  distinct_on?: InputMaybe<Array<AddressVersionFromMoveResourcesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AddressVersionFromMoveResourcesOrderBy>>;
  where?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;
};

export type QueryRootAddressVersionFromMoveResourcesAggregateArgs = {
  distinct_on?: InputMaybe<Array<AddressVersionFromMoveResourcesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AddressVersionFromMoveResourcesOrderBy>>;
  where?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;
};

export type QueryRootAnsLookupArgs = {
  distinct_on?: InputMaybe<Array<AnsLookupSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AnsLookupOrderBy>>;
  where?: InputMaybe<AnsLookupBoolExp>;
};

export type QueryRootAnsLookupAggregateArgs = {
  distinct_on?: InputMaybe<Array<AnsLookupSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AnsLookupOrderBy>>;
  where?: InputMaybe<AnsLookupBoolExp>;
};

export type QueryRootAnsLookupByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type QueryRootAnsLookupV2Args = {
  distinct_on?: InputMaybe<Array<AnsLookupV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AnsLookupV2OrderBy>>;
  where?: InputMaybe<AnsLookupV2BoolExp>;
};

export type QueryRootAnsLookupV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<AnsLookupV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AnsLookupV2OrderBy>>;
  where?: InputMaybe<AnsLookupV2BoolExp>;
};

export type QueryRootAnsLookupV2ByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type QueryRootAnsPrimaryNameArgs = {
  distinct_on?: InputMaybe<Array<AnsPrimaryNameSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AnsPrimaryNameOrderBy>>;
  where?: InputMaybe<AnsPrimaryNameBoolExp>;
};

export type QueryRootAnsPrimaryNameAggregateArgs = {
  distinct_on?: InputMaybe<Array<AnsPrimaryNameSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AnsPrimaryNameOrderBy>>;
  where?: InputMaybe<AnsPrimaryNameBoolExp>;
};

export type QueryRootAnsPrimaryNameByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type QueryRootAnsPrimaryNameV2Args = {
  distinct_on?: InputMaybe<Array<AnsPrimaryNameV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AnsPrimaryNameV2OrderBy>>;
  where?: InputMaybe<AnsPrimaryNameV2BoolExp>;
};

export type QueryRootAnsPrimaryNameV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<AnsPrimaryNameV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AnsPrimaryNameV2OrderBy>>;
  where?: InputMaybe<AnsPrimaryNameV2BoolExp>;
};

export type QueryRootAnsPrimaryNameV2ByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type QueryRootAuthKeyAccountAddressesArgs = {
  distinct_on?: InputMaybe<Array<AuthKeyAccountAddressesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AuthKeyAccountAddressesOrderBy>>;
  where?: InputMaybe<AuthKeyAccountAddressesBoolExp>;
};

export type QueryRootAuthKeyAccountAddressesAggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthKeyAccountAddressesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AuthKeyAccountAddressesOrderBy>>;
  where?: InputMaybe<AuthKeyAccountAddressesBoolExp>;
};

export type QueryRootAuthKeyAccountAddressesByPkArgs = {
  account_address: Scalars["String"]["input"];
};

export type QueryRootBlockMetadataTransactionsArgs = {
  distinct_on?: InputMaybe<Array<BlockMetadataTransactionsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<BlockMetadataTransactionsOrderBy>>;
  where?: InputMaybe<BlockMetadataTransactionsBoolExp>;
};

export type QueryRootBlockMetadataTransactionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<BlockMetadataTransactionsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<BlockMetadataTransactionsOrderBy>>;
  where?: InputMaybe<BlockMetadataTransactionsBoolExp>;
};

export type QueryRootBlockMetadataTransactionsByPkArgs = {
  version: Scalars["bigint"]["input"];
};

export type QueryRootCoinActivitiesArgs = {
  distinct_on?: InputMaybe<Array<CoinActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CoinActivitiesOrderBy>>;
  where?: InputMaybe<CoinActivitiesBoolExp>;
};

export type QueryRootCoinActivitiesAggregateArgs = {
  distinct_on?: InputMaybe<Array<CoinActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CoinActivitiesOrderBy>>;
  where?: InputMaybe<CoinActivitiesBoolExp>;
};

export type QueryRootCoinActivitiesByPkArgs = {
  event_account_address: Scalars["String"]["input"];
  event_creation_number: Scalars["bigint"]["input"];
  event_sequence_number: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type QueryRootCoinBalancesArgs = {
  distinct_on?: InputMaybe<Array<CoinBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CoinBalancesOrderBy>>;
  where?: InputMaybe<CoinBalancesBoolExp>;
};

export type QueryRootCoinBalancesAggregateArgs = {
  distinct_on?: InputMaybe<Array<CoinBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CoinBalancesOrderBy>>;
  where?: InputMaybe<CoinBalancesBoolExp>;
};

export type QueryRootCoinBalancesByPkArgs = {
  coin_type_hash: Scalars["String"]["input"];
  owner_address: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type QueryRootCoinInfosArgs = {
  distinct_on?: InputMaybe<Array<CoinInfosSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CoinInfosOrderBy>>;
  where?: InputMaybe<CoinInfosBoolExp>;
};

export type QueryRootCoinInfosAggregateArgs = {
  distinct_on?: InputMaybe<Array<CoinInfosSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CoinInfosOrderBy>>;
  where?: InputMaybe<CoinInfosBoolExp>;
};

export type QueryRootCoinInfosByPkArgs = {
  coin_type_hash: Scalars["String"]["input"];
};

export type QueryRootCoinSupplyArgs = {
  distinct_on?: InputMaybe<Array<CoinSupplySelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CoinSupplyOrderBy>>;
  where?: InputMaybe<CoinSupplyBoolExp>;
};

export type QueryRootCoinSupplyAggregateArgs = {
  distinct_on?: InputMaybe<Array<CoinSupplySelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CoinSupplyOrderBy>>;
  where?: InputMaybe<CoinSupplyBoolExp>;
};

export type QueryRootCoinSupplyByPkArgs = {
  coin_type_hash: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type QueryRootCollectionDatasArgs = {
  distinct_on?: InputMaybe<Array<CollectionDatasSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CollectionDatasOrderBy>>;
  where?: InputMaybe<CollectionDatasBoolExp>;
};

export type QueryRootCollectionDatasAggregateArgs = {
  distinct_on?: InputMaybe<Array<CollectionDatasSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CollectionDatasOrderBy>>;
  where?: InputMaybe<CollectionDatasBoolExp>;
};

export type QueryRootCollectionDatasByPkArgs = {
  collection_data_id_hash: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type QueryRootCollectionsV2Args = {
  distinct_on?: InputMaybe<Array<CollectionsV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CollectionsV2OrderBy>>;
  where?: InputMaybe<CollectionsV2BoolExp>;
};

export type QueryRootCollectionsV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<CollectionsV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CollectionsV2OrderBy>>;
  where?: InputMaybe<CollectionsV2BoolExp>;
};

export type QueryRootCollectionsV2ByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type QueryRootCurrentAnsLookupArgs = {
  distinct_on?: InputMaybe<Array<CurrentAnsLookupSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentAnsLookupOrderBy>>;
  where?: InputMaybe<CurrentAnsLookupBoolExp>;
};

export type QueryRootCurrentAnsLookupAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentAnsLookupSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentAnsLookupOrderBy>>;
  where?: InputMaybe<CurrentAnsLookupBoolExp>;
};

export type QueryRootCurrentAnsLookupByPkArgs = {
  domain: Scalars["String"]["input"];
  subdomain: Scalars["String"]["input"];
};

export type QueryRootCurrentAnsLookupV2Args = {
  distinct_on?: InputMaybe<Array<CurrentAnsLookupV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentAnsLookupV2OrderBy>>;
  where?: InputMaybe<CurrentAnsLookupV2BoolExp>;
};

export type QueryRootCurrentAnsLookupV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentAnsLookupV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentAnsLookupV2OrderBy>>;
  where?: InputMaybe<CurrentAnsLookupV2BoolExp>;
};

export type QueryRootCurrentAnsLookupV2ByPkArgs = {
  domain: Scalars["String"]["input"];
  subdomain: Scalars["String"]["input"];
  token_standard: Scalars["String"]["input"];
};

export type QueryRootCurrentAnsPrimaryNameArgs = {
  distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentAnsPrimaryNameOrderBy>>;
  where?: InputMaybe<CurrentAnsPrimaryNameBoolExp>;
};

export type QueryRootCurrentAnsPrimaryNameAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentAnsPrimaryNameOrderBy>>;
  where?: InputMaybe<CurrentAnsPrimaryNameBoolExp>;
};

export type QueryRootCurrentAnsPrimaryNameByPkArgs = {
  registered_address: Scalars["String"]["input"];
};

export type QueryRootCurrentAnsPrimaryNameV2Args = {
  distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentAnsPrimaryNameV2OrderBy>>;
  where?: InputMaybe<CurrentAnsPrimaryNameV2BoolExp>;
};

export type QueryRootCurrentAnsPrimaryNameV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentAnsPrimaryNameV2OrderBy>>;
  where?: InputMaybe<CurrentAnsPrimaryNameV2BoolExp>;
};

export type QueryRootCurrentAnsPrimaryNameV2ByPkArgs = {
  registered_address: Scalars["String"]["input"];
  token_standard: Scalars["String"]["input"];
};

export type QueryRootCurrentCedraNamesArgs = {
  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
  where?: InputMaybe<CurrentCedraNamesBoolExp>;
};

export type QueryRootCurrentCedraNamesAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
  where?: InputMaybe<CurrentCedraNamesBoolExp>;
};

export type QueryRootCurrentCoinBalancesArgs = {
  distinct_on?: InputMaybe<Array<CurrentCoinBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCoinBalancesOrderBy>>;
  where?: InputMaybe<CurrentCoinBalancesBoolExp>;
};

export type QueryRootCurrentCoinBalancesAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentCoinBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCoinBalancesOrderBy>>;
  where?: InputMaybe<CurrentCoinBalancesBoolExp>;
};

export type QueryRootCurrentCoinBalancesByPkArgs = {
  coin_type_hash: Scalars["String"]["input"];
  owner_address: Scalars["String"]["input"];
};

export type QueryRootCurrentCollectionDatasArgs = {
  distinct_on?: InputMaybe<Array<CurrentCollectionDatasSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCollectionDatasOrderBy>>;
  where?: InputMaybe<CurrentCollectionDatasBoolExp>;
};

export type QueryRootCurrentCollectionDatasAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentCollectionDatasSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCollectionDatasOrderBy>>;
  where?: InputMaybe<CurrentCollectionDatasBoolExp>;
};

export type QueryRootCurrentCollectionDatasByPkArgs = {
  collection_data_id_hash: Scalars["String"]["input"];
};

export type QueryRootCurrentCollectionOwnershipV2ViewArgs = {
  distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewOrderBy>>;
  where?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;
};

export type QueryRootCurrentCollectionOwnershipV2ViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewOrderBy>>;
  where?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;
};

export type QueryRootCurrentCollectionOwnershipViewArgs = {
  distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCollectionOwnershipViewOrderBy>>;
  where?: InputMaybe<CurrentCollectionOwnershipViewBoolExp>;
};

export type QueryRootCurrentCollectionOwnershipViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCollectionOwnershipViewOrderBy>>;
  where?: InputMaybe<CurrentCollectionOwnershipViewBoolExp>;
};

export type QueryRootCurrentCollectionsV2Args = {
  distinct_on?: InputMaybe<Array<CurrentCollectionsV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCollectionsV2OrderBy>>;
  where?: InputMaybe<CurrentCollectionsV2BoolExp>;
};

export type QueryRootCurrentCollectionsV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentCollectionsV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCollectionsV2OrderBy>>;
  where?: InputMaybe<CurrentCollectionsV2BoolExp>;
};

export type QueryRootCurrentCollectionsV2ByPkArgs = {
  collection_id: Scalars["String"]["input"];
};

export type QueryRootCurrentDelegatedStakingPoolBalancesArgs = {
  distinct_on?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesOrderBy>>;
  where?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;
};

export type QueryRootCurrentDelegatedStakingPoolBalancesAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesOrderBy>>;
  where?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;
};

export type QueryRootCurrentDelegatedStakingPoolBalancesByPkArgs = {
  staking_pool_address: Scalars["String"]["input"];
};

export type QueryRootCurrentDelegatedVoterArgs = {
  distinct_on?: InputMaybe<Array<CurrentDelegatedVoterSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentDelegatedVoterOrderBy>>;
  where?: InputMaybe<CurrentDelegatedVoterBoolExp>;
};

export type QueryRootCurrentDelegatedVoterAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentDelegatedVoterSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentDelegatedVoterOrderBy>>;
  where?: InputMaybe<CurrentDelegatedVoterBoolExp>;
};

export type QueryRootCurrentDelegatedVoterByPkArgs = {
  delegation_pool_address: Scalars["String"]["input"];
  delegator_address: Scalars["String"]["input"];
};

export type QueryRootCurrentDelegatorBalancesArgs = {
  distinct_on?: InputMaybe<Array<CurrentDelegatorBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentDelegatorBalancesOrderBy>>;
  where?: InputMaybe<CurrentDelegatorBalancesBoolExp>;
};

export type QueryRootCurrentDelegatorBalancesAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentDelegatorBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentDelegatorBalancesOrderBy>>;
  where?: InputMaybe<CurrentDelegatorBalancesBoolExp>;
};

export type QueryRootCurrentDelegatorBalancesByPkArgs = {
  delegator_address: Scalars["String"]["input"];
  pool_address: Scalars["String"]["input"];
  pool_type: Scalars["String"]["input"];
  table_handle: Scalars["String"]["input"];
};

export type QueryRootCurrentFungibleAssetBalancesArgs = {
  distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesOrderBy>>;
  where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;
};

export type QueryRootCurrentFungibleAssetBalancesAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesOrderBy>>;
  where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;
};

export type QueryRootCurrentFungibleAssetBalancesByPkArgs = {
  storage_id: Scalars["String"]["input"];
};

export type QueryRootCurrentFungibleAssetBalancesNewArgs = {
  distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesNewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesNewOrderBy>>;
  where?: InputMaybe<CurrentFungibleAssetBalancesNewBoolExp>;
};

export type QueryRootCurrentFungibleAssetBalancesNewAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesNewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesNewOrderBy>>;
  where?: InputMaybe<CurrentFungibleAssetBalancesNewBoolExp>;
};

export type QueryRootCurrentFungibleAssetBalancesNewByPkArgs = {
  storage_id: Scalars["String"]["input"];
};

export type QueryRootCurrentObjectsArgs = {
  distinct_on?: InputMaybe<Array<CurrentObjectsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentObjectsOrderBy>>;
  where?: InputMaybe<CurrentObjectsBoolExp>;
};

export type QueryRootCurrentObjectsAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentObjectsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentObjectsOrderBy>>;
  where?: InputMaybe<CurrentObjectsBoolExp>;
};

export type QueryRootCurrentObjectsByPkArgs = {
  object_address: Scalars["String"]["input"];
};

export type QueryRootCurrentStakingPoolVoterArgs = {
  distinct_on?: InputMaybe<Array<CurrentStakingPoolVoterSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentStakingPoolVoterOrderBy>>;
  where?: InputMaybe<CurrentStakingPoolVoterBoolExp>;
};

export type QueryRootCurrentStakingPoolVoterAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentStakingPoolVoterSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentStakingPoolVoterOrderBy>>;
  where?: InputMaybe<CurrentStakingPoolVoterBoolExp>;
};

export type QueryRootCurrentStakingPoolVoterByPkArgs = {
  staking_pool_address: Scalars["String"]["input"];
};

export type QueryRootCurrentTableItemsArgs = {
  distinct_on?: InputMaybe<Array<CurrentTableItemsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTableItemsOrderBy>>;
  where?: InputMaybe<CurrentTableItemsBoolExp>;
};

export type QueryRootCurrentTableItemsAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentTableItemsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTableItemsOrderBy>>;
  where?: InputMaybe<CurrentTableItemsBoolExp>;
};

export type QueryRootCurrentTableItemsByPkArgs = {
  key_hash: Scalars["String"]["input"];
  table_handle: Scalars["String"]["input"];
};

export type QueryRootCurrentTableItemsViewArgs = {
  distinct_on?: InputMaybe<Array<CurrentTableItemsViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTableItemsViewOrderBy>>;
  where?: InputMaybe<CurrentTableItemsViewBoolExp>;
};

export type QueryRootCurrentTableItemsViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentTableItemsViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTableItemsViewOrderBy>>;
  where?: InputMaybe<CurrentTableItemsViewBoolExp>;
};

export type QueryRootCurrentTokenDatasArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenDatasSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenDatasOrderBy>>;
  where?: InputMaybe<CurrentTokenDatasBoolExp>;
};

export type QueryRootCurrentTokenDatasAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenDatasSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenDatasOrderBy>>;
  where?: InputMaybe<CurrentTokenDatasBoolExp>;
};

export type QueryRootCurrentTokenDatasByPkArgs = {
  token_data_id_hash: Scalars["String"]["input"];
};

export type QueryRootCurrentTokenDatasV2Args = {
  distinct_on?: InputMaybe<Array<CurrentTokenDatasV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenDatasV2OrderBy>>;
  where?: InputMaybe<CurrentTokenDatasV2BoolExp>;
};

export type QueryRootCurrentTokenDatasV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenDatasV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenDatasV2OrderBy>>;
  where?: InputMaybe<CurrentTokenDatasV2BoolExp>;
};

export type QueryRootCurrentTokenDatasV2ByPkArgs = {
  token_data_id: Scalars["String"]["input"];
};

export type QueryRootCurrentTokenOwnershipsArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenOwnershipsOrderBy>>;
  where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;
};

export type QueryRootCurrentTokenOwnershipsAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenOwnershipsOrderBy>>;
  where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;
};

export type QueryRootCurrentTokenOwnershipsByPkArgs = {
  owner_address: Scalars["String"]["input"];
  property_version: Scalars["numeric"]["input"];
  token_data_id_hash: Scalars["String"]["input"];
};

export type QueryRootCurrentTokenOwnershipsV2Args = {
  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;
  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
};

export type QueryRootCurrentTokenOwnershipsV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;
  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
};

export type QueryRootCurrentTokenOwnershipsV2ByPkArgs = {
  owner_address: Scalars["String"]["input"];
  property_version_v1: Scalars["numeric"]["input"];
  storage_id: Scalars["String"]["input"];
  token_data_id: Scalars["String"]["input"];
};

export type QueryRootCurrentTokenPendingClaimsArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenPendingClaimsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenPendingClaimsOrderBy>>;
  where?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;
};

export type QueryRootCurrentTokenPendingClaimsAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenPendingClaimsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenPendingClaimsOrderBy>>;
  where?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;
};

export type QueryRootCurrentTokenPendingClaimsByPkArgs = {
  from_address: Scalars["String"]["input"];
  property_version: Scalars["numeric"]["input"];
  to_address: Scalars["String"]["input"];
  token_data_id_hash: Scalars["String"]["input"];
};

export type QueryRootCurrentTokenRoyaltyV1Args = {
  distinct_on?: InputMaybe<Array<CurrentTokenRoyaltyV1SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenRoyaltyV1OrderBy>>;
  where?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;
};

export type QueryRootCurrentTokenRoyaltyV1AggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenRoyaltyV1SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenRoyaltyV1OrderBy>>;
  where?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;
};

export type QueryRootCurrentTokenRoyaltyV1ByPkArgs = {
  token_data_id: Scalars["String"]["input"];
};

export type QueryRootCurrentTokenV2MetadataArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenV2MetadataSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenV2MetadataOrderBy>>;
  where?: InputMaybe<CurrentTokenV2MetadataBoolExp>;
};

export type QueryRootCurrentTokenV2MetadataAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenV2MetadataSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenV2MetadataOrderBy>>;
  where?: InputMaybe<CurrentTokenV2MetadataBoolExp>;
};

export type QueryRootCurrentTokenV2MetadataByPkArgs = {
  object_address: Scalars["String"]["input"];
  resource_type: Scalars["String"]["input"];
};

export type QueryRootDelegatedStakingActivitiesArgs = {
  distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;
  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
};

export type QueryRootDelegatedStakingActivitiesAggregateArgs = {
  distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;
  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
};

export type QueryRootDelegatedStakingActivitiesByPkArgs = {
  event_index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type QueryRootDelegatedStakingPoolBalancesArgs = {
  distinct_on?: InputMaybe<Array<DelegatedStakingPoolBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatedStakingPoolBalancesOrderBy>>;
  where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;
};

export type QueryRootDelegatedStakingPoolBalancesAggregateArgs = {
  distinct_on?: InputMaybe<Array<DelegatedStakingPoolBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatedStakingPoolBalancesOrderBy>>;
  where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;
};

export type QueryRootDelegatedStakingPoolBalancesByPkArgs = {
  staking_pool_address: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type QueryRootDelegatedStakingPoolsArgs = {
  distinct_on?: InputMaybe<Array<DelegatedStakingPoolsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatedStakingPoolsOrderBy>>;
  where?: InputMaybe<DelegatedStakingPoolsBoolExp>;
};

export type QueryRootDelegatedStakingPoolsAggregateArgs = {
  distinct_on?: InputMaybe<Array<DelegatedStakingPoolsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatedStakingPoolsOrderBy>>;
  where?: InputMaybe<DelegatedStakingPoolsBoolExp>;
};

export type QueryRootDelegatedStakingPoolsByPkArgs = {
  staking_pool_address: Scalars["String"]["input"];
};

export type QueryRootDelegatorBalancesArgs = {
  distinct_on?: InputMaybe<Array<DelegatorBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatorBalancesOrderBy>>;
  where?: InputMaybe<DelegatorBalancesBoolExp>;
};

export type QueryRootDelegatorBalancesAggregateArgs = {
  distinct_on?: InputMaybe<Array<DelegatorBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatorBalancesOrderBy>>;
  where?: InputMaybe<DelegatorBalancesBoolExp>;
};

export type QueryRootDelegatorBalancesByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type QueryRootDelegatorDistinctPoolArgs = {
  distinct_on?: InputMaybe<Array<DelegatorDistinctPoolSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatorDistinctPoolOrderBy>>;
  where?: InputMaybe<DelegatorDistinctPoolBoolExp>;
};

export type QueryRootDelegatorDistinctPoolAggregateArgs = {
  distinct_on?: InputMaybe<Array<DelegatorDistinctPoolSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatorDistinctPoolOrderBy>>;
  where?: InputMaybe<DelegatorDistinctPoolBoolExp>;
};

export type QueryRootEventSizeInfoArgs = {
  distinct_on?: InputMaybe<Array<EventSizeInfoSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<EventSizeInfoOrderBy>>;
  where?: InputMaybe<EventSizeInfoBoolExp>;
};

export type QueryRootEventSizeInfoAggregateArgs = {
  distinct_on?: InputMaybe<Array<EventSizeInfoSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<EventSizeInfoOrderBy>>;
  where?: InputMaybe<EventSizeInfoBoolExp>;
};

export type QueryRootEventSizeInfoByPkArgs = {
  index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type QueryRootEventsArgs = {
  distinct_on?: InputMaybe<Array<EventsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<EventsOrderBy>>;
  where?: InputMaybe<EventsBoolExp>;
};

export type QueryRootEventsAggregateArgs = {
  distinct_on?: InputMaybe<Array<EventsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<EventsOrderBy>>;
  where?: InputMaybe<EventsBoolExp>;
};

export type QueryRootEventsByPkArgs = {
  event_index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type QueryRootEventsViewArgs = {
  distinct_on?: InputMaybe<Array<EventsViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<EventsViewOrderBy>>;
  where?: InputMaybe<EventsViewBoolExp>;
};

export type QueryRootEventsViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<EventsViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<EventsViewOrderBy>>;
  where?: InputMaybe<EventsViewBoolExp>;
};

export type QueryRootFungibleAssetActivitiesArgs = {
  distinct_on?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<FungibleAssetActivitiesOrderBy>>;
  where?: InputMaybe<FungibleAssetActivitiesBoolExp>;
};

export type QueryRootFungibleAssetActivitiesAggregateArgs = {
  distinct_on?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<FungibleAssetActivitiesOrderBy>>;
  where?: InputMaybe<FungibleAssetActivitiesBoolExp>;
};

export type QueryRootFungibleAssetActivitiesByPkArgs = {
  event_index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type QueryRootFungibleAssetBalancesArgs = {
  distinct_on?: InputMaybe<Array<FungibleAssetBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<FungibleAssetBalancesOrderBy>>;
  where?: InputMaybe<FungibleAssetBalancesBoolExp>;
};

export type QueryRootFungibleAssetBalancesAggregateArgs = {
  distinct_on?: InputMaybe<Array<FungibleAssetBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<FungibleAssetBalancesOrderBy>>;
  where?: InputMaybe<FungibleAssetBalancesBoolExp>;
};

export type QueryRootFungibleAssetBalancesByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type QueryRootFungibleAssetMetadataArgs = {
  distinct_on?: InputMaybe<Array<FungibleAssetMetadataSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<FungibleAssetMetadataOrderBy>>;
  where?: InputMaybe<FungibleAssetMetadataBoolExp>;
};

export type QueryRootFungibleAssetMetadataAggregateArgs = {
  distinct_on?: InputMaybe<Array<FungibleAssetMetadataSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<FungibleAssetMetadataOrderBy>>;
  where?: InputMaybe<FungibleAssetMetadataBoolExp>;
};

export type QueryRootFungibleAssetMetadataByPkArgs = {
  asset_type: Scalars["String"]["input"];
};

export type QueryRootFungibleAssetToCoinMappingsArgs = {
  distinct_on?: InputMaybe<Array<FungibleAssetToCoinMappingsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<FungibleAssetToCoinMappingsOrderBy>>;
  where?: InputMaybe<FungibleAssetToCoinMappingsBoolExp>;
};

export type QueryRootFungibleAssetToCoinMappingsAggregateArgs = {
  distinct_on?: InputMaybe<Array<FungibleAssetToCoinMappingsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<FungibleAssetToCoinMappingsOrderBy>>;
  where?: InputMaybe<FungibleAssetToCoinMappingsBoolExp>;
};

export type QueryRootFungibleAssetToCoinMappingsByPkArgs = {
  fungible_asset_metadata_address: Scalars["String"]["input"];
};

export type QueryRootGasFeesArgs = {
  distinct_on?: InputMaybe<Array<GasFeesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<GasFeesOrderBy>>;
  where?: InputMaybe<GasFeesBoolExp>;
};

export type QueryRootGasFeesAggregateArgs = {
  distinct_on?: InputMaybe<Array<GasFeesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<GasFeesOrderBy>>;
  where?: InputMaybe<GasFeesBoolExp>;
};

export type QueryRootGasFeesByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
};

export type QueryRootIndexerStatusArgs = {
  distinct_on?: InputMaybe<Array<IndexerStatusSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<IndexerStatusOrderBy>>;
  where?: InputMaybe<IndexerStatusBoolExp>;
};

export type QueryRootIndexerStatusAggregateArgs = {
  distinct_on?: InputMaybe<Array<IndexerStatusSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<IndexerStatusOrderBy>>;
  where?: InputMaybe<IndexerStatusBoolExp>;
};

export type QueryRootIndexerStatusByPkArgs = {
  db: Scalars["String"]["input"];
};

export type QueryRootMoveModulesArgs = {
  distinct_on?: InputMaybe<Array<MoveModulesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<MoveModulesOrderBy>>;
  where?: InputMaybe<MoveModulesBoolExp>;
};

export type QueryRootMoveModulesAggregateArgs = {
  distinct_on?: InputMaybe<Array<MoveModulesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<MoveModulesOrderBy>>;
  where?: InputMaybe<MoveModulesBoolExp>;
};

export type QueryRootMoveModulesByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type QueryRootMoveResourcesArgs = {
  distinct_on?: InputMaybe<Array<MoveResourcesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<MoveResourcesOrderBy>>;
  where?: InputMaybe<MoveResourcesBoolExp>;
};

export type QueryRootMoveResourcesAggregateArgs = {
  distinct_on?: InputMaybe<Array<MoveResourcesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<MoveResourcesOrderBy>>;
  where?: InputMaybe<MoveResourcesBoolExp>;
};

export type QueryRootMoveResourcesByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type QueryRootMoveResourcesViewArgs = {
  distinct_on?: InputMaybe<Array<MoveResourcesViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<MoveResourcesViewOrderBy>>;
  where?: InputMaybe<MoveResourcesViewBoolExp>;
};

export type QueryRootMoveResourcesViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<MoveResourcesViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<MoveResourcesViewOrderBy>>;
  where?: InputMaybe<MoveResourcesViewBoolExp>;
};

export type QueryRootNftMetadataCrawlerParsedAssetUrisArgs = {
  distinct_on?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisOrderBy>>;
  where?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;
};

export type QueryRootNftMetadataCrawlerParsedAssetUrisAggregateArgs = {
  distinct_on?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisOrderBy>>;
  where?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;
};

export type QueryRootNftMetadataCrawlerParsedAssetUrisByPkArgs = {
  asset_uri: Scalars["String"]["input"];
};

export type QueryRootNftPointsArgs = {
  distinct_on?: InputMaybe<Array<NftPointsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<NftPointsOrderBy>>;
  where?: InputMaybe<NftPointsBoolExp>;
};

export type QueryRootNftPointsAggregateArgs = {
  distinct_on?: InputMaybe<Array<NftPointsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<NftPointsOrderBy>>;
  where?: InputMaybe<NftPointsBoolExp>;
};

export type QueryRootNftPointsByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
};

export type QueryRootNumActiveDelegatorPerPoolArgs = {
  distinct_on?: InputMaybe<Array<NumActiveDelegatorPerPoolSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<NumActiveDelegatorPerPoolOrderBy>>;
  where?: InputMaybe<NumActiveDelegatorPerPoolBoolExp>;
};

export type QueryRootNumActiveDelegatorPerPoolAggregateArgs = {
  distinct_on?: InputMaybe<Array<NumActiveDelegatorPerPoolSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<NumActiveDelegatorPerPoolOrderBy>>;
  where?: InputMaybe<NumActiveDelegatorPerPoolBoolExp>;
};

export type QueryRootObjectsArgs = {
  distinct_on?: InputMaybe<Array<ObjectsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<ObjectsOrderBy>>;
  where?: InputMaybe<ObjectsBoolExp>;
};

export type QueryRootObjectsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ObjectsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<ObjectsOrderBy>>;
  where?: InputMaybe<ObjectsBoolExp>;
};

export type QueryRootObjectsByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type QueryRootProcessorMetadataProcessorStatusArgs = {
  distinct_on?: InputMaybe<Array<ProcessorMetadataProcessorStatusSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<ProcessorMetadataProcessorStatusOrderBy>>;
  where?: InputMaybe<ProcessorMetadataProcessorStatusBoolExp>;
};

export type QueryRootProcessorMetadataProcessorStatusAggregateArgs = {
  distinct_on?: InputMaybe<Array<ProcessorMetadataProcessorStatusSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<ProcessorMetadataProcessorStatusOrderBy>>;
  where?: InputMaybe<ProcessorMetadataProcessorStatusBoolExp>;
};

export type QueryRootProcessorMetadataProcessorStatusByPkArgs = {
  processor: Scalars["String"]["input"];
};

export type QueryRootProcessorStatusArgs = {
  distinct_on?: InputMaybe<Array<ProcessorStatusSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<ProcessorStatusOrderBy>>;
  where?: InputMaybe<ProcessorStatusBoolExp>;
};

export type QueryRootProcessorStatusAggregateArgs = {
  distinct_on?: InputMaybe<Array<ProcessorStatusSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<ProcessorStatusOrderBy>>;
  where?: InputMaybe<ProcessorStatusBoolExp>;
};

export type QueryRootProcessorStatusByPkArgs = {
  processor: Scalars["String"]["input"];
};

export type QueryRootProposalVotesArgs = {
  distinct_on?: InputMaybe<Array<ProposalVotesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<ProposalVotesOrderBy>>;
  where?: InputMaybe<ProposalVotesBoolExp>;
};

export type QueryRootProposalVotesAggregateArgs = {
  distinct_on?: InputMaybe<Array<ProposalVotesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<ProposalVotesOrderBy>>;
  where?: InputMaybe<ProposalVotesBoolExp>;
};

export type QueryRootProposalVotesByPkArgs = {
  proposal_id: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
  voter_address: Scalars["String"]["input"];
};

export type QueryRootPublicKeyAuthKeysArgs = {
  distinct_on?: InputMaybe<Array<PublicKeyAuthKeysSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<PublicKeyAuthKeysOrderBy>>;
  where?: InputMaybe<PublicKeyAuthKeysBoolExp>;
};

export type QueryRootPublicKeyAuthKeysAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicKeyAuthKeysSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<PublicKeyAuthKeysOrderBy>>;
  where?: InputMaybe<PublicKeyAuthKeysBoolExp>;
};

export type QueryRootPublicKeyAuthKeysByPkArgs = {
  auth_key: Scalars["String"]["input"];
  public_key: Scalars["String"]["input"];
  public_key_type: Scalars["String"]["input"];
};

export type QueryRootSignaturesArgs = {
  distinct_on?: InputMaybe<Array<SignaturesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<SignaturesOrderBy>>;
  where?: InputMaybe<SignaturesBoolExp>;
};

export type QueryRootSignaturesAggregateArgs = {
  distinct_on?: InputMaybe<Array<SignaturesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<SignaturesOrderBy>>;
  where?: InputMaybe<SignaturesBoolExp>;
};

export type QueryRootSignaturesByPkArgs = {
  is_sender_primary: Scalars["Boolean"]["input"];
  multi_agent_index: Scalars["bigint"]["input"];
  multi_sig_index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type QueryRootSpamAssetsArgs = {
  distinct_on?: InputMaybe<Array<SpamAssetsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<SpamAssetsOrderBy>>;
  where?: InputMaybe<SpamAssetsBoolExp>;
};

export type QueryRootSpamAssetsAggregateArgs = {
  distinct_on?: InputMaybe<Array<SpamAssetsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<SpamAssetsOrderBy>>;
  where?: InputMaybe<SpamAssetsBoolExp>;
};

export type QueryRootSpamAssetsByPkArgs = {
  asset: Scalars["String"]["input"];
};

export type QueryRootTableItemsArgs = {
  distinct_on?: InputMaybe<Array<TableItemsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TableItemsOrderBy>>;
  where?: InputMaybe<TableItemsBoolExp>;
};

export type QueryRootTableItemsAggregateArgs = {
  distinct_on?: InputMaybe<Array<TableItemsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TableItemsOrderBy>>;
  where?: InputMaybe<TableItemsBoolExp>;
};

export type QueryRootTableItemsByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type QueryRootTableItemsViewArgs = {
  distinct_on?: InputMaybe<Array<TableItemsViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TableItemsViewOrderBy>>;
  where?: InputMaybe<TableItemsViewBoolExp>;
};

export type QueryRootTableItemsViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<TableItemsViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TableItemsViewOrderBy>>;
  where?: InputMaybe<TableItemsViewBoolExp>;
};

export type QueryRootTableMetadatasArgs = {
  distinct_on?: InputMaybe<Array<TableMetadatasSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TableMetadatasOrderBy>>;
  where?: InputMaybe<TableMetadatasBoolExp>;
};

export type QueryRootTableMetadatasAggregateArgs = {
  distinct_on?: InputMaybe<Array<TableMetadatasSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TableMetadatasOrderBy>>;
  where?: InputMaybe<TableMetadatasBoolExp>;
};

export type QueryRootTableMetadatasByPkArgs = {
  handle: Scalars["String"]["input"];
};

export type QueryRootTokenActivitiesArgs = {
  distinct_on?: InputMaybe<Array<TokenActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenActivitiesOrderBy>>;
  where?: InputMaybe<TokenActivitiesBoolExp>;
};

export type QueryRootTokenActivitiesAggregateArgs = {
  distinct_on?: InputMaybe<Array<TokenActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenActivitiesOrderBy>>;
  where?: InputMaybe<TokenActivitiesBoolExp>;
};

export type QueryRootTokenActivitiesByPkArgs = {
  event_account_address: Scalars["String"]["input"];
  event_creation_number: Scalars["bigint"]["input"];
  event_sequence_number: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type QueryRootTokenActivitiesV2Args = {
  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;
  where?: InputMaybe<TokenActivitiesV2BoolExp>;
};

export type QueryRootTokenActivitiesV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;
  where?: InputMaybe<TokenActivitiesV2BoolExp>;
};

export type QueryRootTokenActivitiesV2ByPkArgs = {
  event_index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type QueryRootTokenDatasArgs = {
  distinct_on?: InputMaybe<Array<TokenDatasSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenDatasOrderBy>>;
  where?: InputMaybe<TokenDatasBoolExp>;
};

export type QueryRootTokenDatasAggregateArgs = {
  distinct_on?: InputMaybe<Array<TokenDatasSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenDatasOrderBy>>;
  where?: InputMaybe<TokenDatasBoolExp>;
};

export type QueryRootTokenDatasByPkArgs = {
  token_data_id_hash: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type QueryRootTokenDatasV2Args = {
  distinct_on?: InputMaybe<Array<TokenDatasV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenDatasV2OrderBy>>;
  where?: InputMaybe<TokenDatasV2BoolExp>;
};

export type QueryRootTokenDatasV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<TokenDatasV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenDatasV2OrderBy>>;
  where?: InputMaybe<TokenDatasV2BoolExp>;
};

export type QueryRootTokenDatasV2ByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type QueryRootTokenOwnershipsArgs = {
  distinct_on?: InputMaybe<Array<TokenOwnershipsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenOwnershipsOrderBy>>;
  where?: InputMaybe<TokenOwnershipsBoolExp>;
};

export type QueryRootTokenOwnershipsAggregateArgs = {
  distinct_on?: InputMaybe<Array<TokenOwnershipsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenOwnershipsOrderBy>>;
  where?: InputMaybe<TokenOwnershipsBoolExp>;
};

export type QueryRootTokenOwnershipsByPkArgs = {
  property_version: Scalars["numeric"]["input"];
  table_handle: Scalars["String"]["input"];
  token_data_id_hash: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type QueryRootTokenOwnershipsV2Args = {
  distinct_on?: InputMaybe<Array<TokenOwnershipsV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenOwnershipsV2OrderBy>>;
  where?: InputMaybe<TokenOwnershipsV2BoolExp>;
};

export type QueryRootTokenOwnershipsV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<TokenOwnershipsV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenOwnershipsV2OrderBy>>;
  where?: InputMaybe<TokenOwnershipsV2BoolExp>;
};

export type QueryRootTokenOwnershipsV2ByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type QueryRootTokensArgs = {
  distinct_on?: InputMaybe<Array<TokensSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokensOrderBy>>;
  where?: InputMaybe<TokensBoolExp>;
};

export type QueryRootTokensAggregateArgs = {
  distinct_on?: InputMaybe<Array<TokensSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokensOrderBy>>;
  where?: InputMaybe<TokensBoolExp>;
};

export type QueryRootTokensByPkArgs = {
  property_version: Scalars["numeric"]["input"];
  token_data_id_hash: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type QueryRootTransactionSizeInfoArgs = {
  distinct_on?: InputMaybe<Array<TransactionSizeInfoSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TransactionSizeInfoOrderBy>>;
  where?: InputMaybe<TransactionSizeInfoBoolExp>;
};

export type QueryRootTransactionSizeInfoAggregateArgs = {
  distinct_on?: InputMaybe<Array<TransactionSizeInfoSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TransactionSizeInfoOrderBy>>;
  where?: InputMaybe<TransactionSizeInfoBoolExp>;
};

export type QueryRootTransactionSizeInfoByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
};

export type QueryRootTransactionsViewArgs = {
  distinct_on?: InputMaybe<Array<TransactionsViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TransactionsViewOrderBy>>;
  where?: InputMaybe<TransactionsViewBoolExp>;
};

export type QueryRootTransactionsViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<TransactionsViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TransactionsViewOrderBy>>;
  where?: InputMaybe<TransactionsViewBoolExp>;
};

export type QueryRootUserTransactionsArgs = {
  distinct_on?: InputMaybe<Array<UserTransactionsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<UserTransactionsOrderBy>>;
  where?: InputMaybe<UserTransactionsBoolExp>;
};

export type QueryRootUserTransactionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<UserTransactionsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<UserTransactionsOrderBy>>;
  where?: InputMaybe<UserTransactionsBoolExp>;
};

export type QueryRootUserTransactionsByPkArgs = {
  version: Scalars["bigint"]["input"];
};

/** columns and relationships of "signatures" */
export type Signatures = {
  any_signature_type?: Maybe<Scalars["String"]["output"]>;
  inserted_at: Scalars["timestamp"]["output"];
  is_sender_primary: Scalars["Boolean"]["output"];
  multi_agent_index: Scalars["bigint"]["output"];
  multi_sig_index: Scalars["bigint"]["output"];
  public_key: Scalars["String"]["output"];
  public_key_indices: Scalars["jsonb"]["output"];
  public_key_type?: Maybe<Scalars["String"]["output"]>;
  signature: Scalars["String"]["output"];
  signer: Scalars["String"]["output"];
  threshold: Scalars["bigint"]["output"];
  transaction_block_height: Scalars["bigint"]["output"];
  transaction_version: Scalars["bigint"]["output"];
  type: Scalars["String"]["output"];
};

/** columns and relationships of "signatures" */
export type SignaturesPublicKeyIndicesArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregated selection of "signatures" */
export type SignaturesAggregate = {
  aggregate?: Maybe<SignaturesAggregateFields>;
  nodes: Array<Signatures>;
};

/** aggregate fields of "signatures" */
export type SignaturesAggregateFields = {
  avg?: Maybe<SignaturesAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<SignaturesMaxFields>;
  min?: Maybe<SignaturesMinFields>;
  stddev?: Maybe<SignaturesStddevFields>;
  stddev_pop?: Maybe<SignaturesStddevPopFields>;
  stddev_samp?: Maybe<SignaturesStddevSampFields>;
  sum?: Maybe<SignaturesSumFields>;
  var_pop?: Maybe<SignaturesVarPopFields>;
  var_samp?: Maybe<SignaturesVarSampFields>;
  variance?: Maybe<SignaturesVarianceFields>;
};

/** aggregate fields of "signatures" */
export type SignaturesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<SignaturesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type SignaturesAppendInput = {
  public_key_indices?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** aggregate avg on columns */
export type SignaturesAvgFields = {
  multi_agent_index?: Maybe<Scalars["Float"]["output"]>;
  multi_sig_index?: Maybe<Scalars["Float"]["output"]>;
  threshold?: Maybe<Scalars["Float"]["output"]>;
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "signatures". All fields are combined with a logical 'AND'. */
export type SignaturesBoolExp = {
  _and?: InputMaybe<Array<SignaturesBoolExp>>;
  _not?: InputMaybe<SignaturesBoolExp>;
  _or?: InputMaybe<Array<SignaturesBoolExp>>;
  any_signature_type?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_sender_primary?: InputMaybe<BooleanComparisonExp>;
  multi_agent_index?: InputMaybe<BigintComparisonExp>;
  multi_sig_index?: InputMaybe<BigintComparisonExp>;
  public_key?: InputMaybe<StringComparisonExp>;
  public_key_indices?: InputMaybe<JsonbComparisonExp>;
  public_key_type?: InputMaybe<StringComparisonExp>;
  signature?: InputMaybe<StringComparisonExp>;
  signer?: InputMaybe<StringComparisonExp>;
  threshold?: InputMaybe<BigintComparisonExp>;
  transaction_block_height?: InputMaybe<BigintComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  type?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "signatures" */
export enum SignaturesConstraint {
  /** unique or primary key constraint on columns "multi_agent_index", "is_sender_primary", "transaction_version", "multi_sig_index" */
  SignaturesPkey = "signatures_pkey",
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type SignaturesDeleteAtPathInput = {
  public_key_indices?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type SignaturesDeleteElemInput = {
  public_key_indices?: InputMaybe<Scalars["Int"]["input"]>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type SignaturesDeleteKeyInput = {
  public_key_indices?: InputMaybe<Scalars["String"]["input"]>;
};

/** input type for incrementing numeric columns in table "signatures" */
export type SignaturesIncInput = {
  multi_agent_index?: InputMaybe<Scalars["bigint"]["input"]>;
  multi_sig_index?: InputMaybe<Scalars["bigint"]["input"]>;
  threshold?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "signatures" */
export type SignaturesInsertInput = {
  any_signature_type?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_sender_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
  multi_agent_index?: InputMaybe<Scalars["bigint"]["input"]>;
  multi_sig_index?: InputMaybe<Scalars["bigint"]["input"]>;
  public_key?: InputMaybe<Scalars["String"]["input"]>;
  public_key_indices?: InputMaybe<Scalars["jsonb"]["input"]>;
  public_key_type?: InputMaybe<Scalars["String"]["input"]>;
  signature?: InputMaybe<Scalars["String"]["input"]>;
  signer?: InputMaybe<Scalars["String"]["input"]>;
  threshold?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type SignaturesMaxFields = {
  any_signature_type?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  multi_agent_index?: Maybe<Scalars["bigint"]["output"]>;
  multi_sig_index?: Maybe<Scalars["bigint"]["output"]>;
  public_key?: Maybe<Scalars["String"]["output"]>;
  public_key_type?: Maybe<Scalars["String"]["output"]>;
  signature?: Maybe<Scalars["String"]["output"]>;
  signer?: Maybe<Scalars["String"]["output"]>;
  threshold?: Maybe<Scalars["bigint"]["output"]>;
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  type?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type SignaturesMinFields = {
  any_signature_type?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  multi_agent_index?: Maybe<Scalars["bigint"]["output"]>;
  multi_sig_index?: Maybe<Scalars["bigint"]["output"]>;
  public_key?: Maybe<Scalars["String"]["output"]>;
  public_key_type?: Maybe<Scalars["String"]["output"]>;
  signature?: Maybe<Scalars["String"]["output"]>;
  signer?: Maybe<Scalars["String"]["output"]>;
  threshold?: Maybe<Scalars["bigint"]["output"]>;
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  type?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "signatures" */
export type SignaturesMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<Signatures>;
};

/** on_conflict condition type for table "signatures" */
export type SignaturesOnConflict = {
  constraint: SignaturesConstraint;
  update_columns?: Array<SignaturesUpdateColumn>;
  where?: InputMaybe<SignaturesBoolExp>;
};

/** Ordering options when selecting data from "signatures". */
export type SignaturesOrderBy = {
  any_signature_type?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_sender_primary?: InputMaybe<OrderBy>;
  multi_agent_index?: InputMaybe<OrderBy>;
  multi_sig_index?: InputMaybe<OrderBy>;
  public_key?: InputMaybe<OrderBy>;
  public_key_indices?: InputMaybe<OrderBy>;
  public_key_type?: InputMaybe<OrderBy>;
  signature?: InputMaybe<OrderBy>;
  signer?: InputMaybe<OrderBy>;
  threshold?: InputMaybe<OrderBy>;
  transaction_block_height?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: signatures */
export type SignaturesPkColumnsInput = {
  is_sender_primary: Scalars["Boolean"]["input"];
  multi_agent_index: Scalars["bigint"]["input"];
  multi_sig_index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type SignaturesPrependInput = {
  public_key_indices?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** select columns of table "signatures" */
export enum SignaturesSelectColumn {
  /** column name */
  AnySignatureType = "any_signature_type",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsSenderPrimary = "is_sender_primary",
  /** column name */
  MultiAgentIndex = "multi_agent_index",
  /** column name */
  MultiSigIndex = "multi_sig_index",
  /** column name */
  PublicKey = "public_key",
  /** column name */
  PublicKeyIndices = "public_key_indices",
  /** column name */
  PublicKeyType = "public_key_type",
  /** column name */
  Signature = "signature",
  /** column name */
  Signer = "signer",
  /** column name */
  Threshold = "threshold",
  /** column name */
  TransactionBlockHeight = "transaction_block_height",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  Type = "type",
}

/** input type for updating data in table "signatures" */
export type SignaturesSetInput = {
  any_signature_type?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_sender_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
  multi_agent_index?: InputMaybe<Scalars["bigint"]["input"]>;
  multi_sig_index?: InputMaybe<Scalars["bigint"]["input"]>;
  public_key?: InputMaybe<Scalars["String"]["input"]>;
  public_key_indices?: InputMaybe<Scalars["jsonb"]["input"]>;
  public_key_type?: InputMaybe<Scalars["String"]["input"]>;
  signature?: InputMaybe<Scalars["String"]["input"]>;
  signer?: InputMaybe<Scalars["String"]["input"]>;
  threshold?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type SignaturesStddevFields = {
  multi_agent_index?: Maybe<Scalars["Float"]["output"]>;
  multi_sig_index?: Maybe<Scalars["Float"]["output"]>;
  threshold?: Maybe<Scalars["Float"]["output"]>;
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type SignaturesStddevPopFields = {
  multi_agent_index?: Maybe<Scalars["Float"]["output"]>;
  multi_sig_index?: Maybe<Scalars["Float"]["output"]>;
  threshold?: Maybe<Scalars["Float"]["output"]>;
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type SignaturesStddevSampFields = {
  multi_agent_index?: Maybe<Scalars["Float"]["output"]>;
  multi_sig_index?: Maybe<Scalars["Float"]["output"]>;
  threshold?: Maybe<Scalars["Float"]["output"]>;
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "signatures" */
export type SignaturesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: SignaturesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SignaturesStreamCursorValueInput = {
  any_signature_type?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_sender_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
  multi_agent_index?: InputMaybe<Scalars["bigint"]["input"]>;
  multi_sig_index?: InputMaybe<Scalars["bigint"]["input"]>;
  public_key?: InputMaybe<Scalars["String"]["input"]>;
  public_key_indices?: InputMaybe<Scalars["jsonb"]["input"]>;
  public_key_type?: InputMaybe<Scalars["String"]["input"]>;
  signature?: InputMaybe<Scalars["String"]["input"]>;
  signer?: InputMaybe<Scalars["String"]["input"]>;
  threshold?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type SignaturesSumFields = {
  multi_agent_index?: Maybe<Scalars["bigint"]["output"]>;
  multi_sig_index?: Maybe<Scalars["bigint"]["output"]>;
  threshold?: Maybe<Scalars["bigint"]["output"]>;
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "signatures" */
export enum SignaturesUpdateColumn {
  /** column name */
  AnySignatureType = "any_signature_type",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsSenderPrimary = "is_sender_primary",
  /** column name */
  MultiAgentIndex = "multi_agent_index",
  /** column name */
  MultiSigIndex = "multi_sig_index",
  /** column name */
  PublicKey = "public_key",
  /** column name */
  PublicKeyIndices = "public_key_indices",
  /** column name */
  PublicKeyType = "public_key_type",
  /** column name */
  Signature = "signature",
  /** column name */
  Signer = "signer",
  /** column name */
  Threshold = "threshold",
  /** column name */
  TransactionBlockHeight = "transaction_block_height",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  Type = "type",
}

export type SignaturesUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<SignaturesAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<SignaturesDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<SignaturesDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<SignaturesDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<SignaturesIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<SignaturesPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SignaturesSetInput>;
  /** filter the rows which have to be updated */
  where: SignaturesBoolExp;
};

/** aggregate var_pop on columns */
export type SignaturesVarPopFields = {
  multi_agent_index?: Maybe<Scalars["Float"]["output"]>;
  multi_sig_index?: Maybe<Scalars["Float"]["output"]>;
  threshold?: Maybe<Scalars["Float"]["output"]>;
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type SignaturesVarSampFields = {
  multi_agent_index?: Maybe<Scalars["Float"]["output"]>;
  multi_sig_index?: Maybe<Scalars["Float"]["output"]>;
  threshold?: Maybe<Scalars["Float"]["output"]>;
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type SignaturesVarianceFields = {
  multi_agent_index?: Maybe<Scalars["Float"]["output"]>;
  multi_sig_index?: Maybe<Scalars["Float"]["output"]>;
  threshold?: Maybe<Scalars["Float"]["output"]>;
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "spam_assets" */
export type SpamAssets = {
  asset: Scalars["String"]["output"];
  is_spam: Scalars["Boolean"]["output"];
  last_updated: Scalars["timestamp"]["output"];
};

/** aggregated selection of "spam_assets" */
export type SpamAssetsAggregate = {
  aggregate?: Maybe<SpamAssetsAggregateFields>;
  nodes: Array<SpamAssets>;
};

/** aggregate fields of "spam_assets" */
export type SpamAssetsAggregateFields = {
  count: Scalars["Int"]["output"];
  max?: Maybe<SpamAssetsMaxFields>;
  min?: Maybe<SpamAssetsMinFields>;
};

/** aggregate fields of "spam_assets" */
export type SpamAssetsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<SpamAssetsSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** Boolean expression to filter rows from the table "spam_assets". All fields are combined with a logical 'AND'. */
export type SpamAssetsBoolExp = {
  _and?: InputMaybe<Array<SpamAssetsBoolExp>>;
  _not?: InputMaybe<SpamAssetsBoolExp>;
  _or?: InputMaybe<Array<SpamAssetsBoolExp>>;
  asset?: InputMaybe<StringComparisonExp>;
  is_spam?: InputMaybe<BooleanComparisonExp>;
  last_updated?: InputMaybe<TimestampComparisonExp>;
};

/** unique or primary key constraints on table "spam_assets" */
export enum SpamAssetsConstraint {
  /** unique or primary key constraint on columns "asset" */
  SpamAssetsPkey = "spam_assets_pkey",
}

/** input type for inserting data into table "spam_assets" */
export type SpamAssetsInsertInput = {
  asset?: InputMaybe<Scalars["String"]["input"]>;
  is_spam?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_updated?: InputMaybe<Scalars["timestamp"]["input"]>;
};

/** aggregate max on columns */
export type SpamAssetsMaxFields = {
  asset?: Maybe<Scalars["String"]["output"]>;
  last_updated?: Maybe<Scalars["timestamp"]["output"]>;
};

/** aggregate min on columns */
export type SpamAssetsMinFields = {
  asset?: Maybe<Scalars["String"]["output"]>;
  last_updated?: Maybe<Scalars["timestamp"]["output"]>;
};

/** response of any mutation on the table "spam_assets" */
export type SpamAssetsMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<SpamAssets>;
};

/** on_conflict condition type for table "spam_assets" */
export type SpamAssetsOnConflict = {
  constraint: SpamAssetsConstraint;
  update_columns?: Array<SpamAssetsUpdateColumn>;
  where?: InputMaybe<SpamAssetsBoolExp>;
};

/** Ordering options when selecting data from "spam_assets". */
export type SpamAssetsOrderBy = {
  asset?: InputMaybe<OrderBy>;
  is_spam?: InputMaybe<OrderBy>;
  last_updated?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: spam_assets */
export type SpamAssetsPkColumnsInput = {
  asset: Scalars["String"]["input"];
};

/** select columns of table "spam_assets" */
export enum SpamAssetsSelectColumn {
  /** column name */
  Asset = "asset",
  /** column name */
  IsSpam = "is_spam",
  /** column name */
  LastUpdated = "last_updated",
}

/** input type for updating data in table "spam_assets" */
export type SpamAssetsSetInput = {
  asset?: InputMaybe<Scalars["String"]["input"]>;
  is_spam?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_updated?: InputMaybe<Scalars["timestamp"]["input"]>;
};

/** Streaming cursor of the table "spam_assets" */
export type SpamAssetsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: SpamAssetsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SpamAssetsStreamCursorValueInput = {
  asset?: InputMaybe<Scalars["String"]["input"]>;
  is_spam?: InputMaybe<Scalars["Boolean"]["input"]>;
  last_updated?: InputMaybe<Scalars["timestamp"]["input"]>;
};

/** update columns of table "spam_assets" */
export enum SpamAssetsUpdateColumn {
  /** column name */
  Asset = "asset",
  /** column name */
  IsSpam = "is_spam",
  /** column name */
  LastUpdated = "last_updated",
}

export type SpamAssetsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SpamAssetsSetInput>;
  /** filter the rows which have to be updated */
  where: SpamAssetsBoolExp;
};

export type SubscriptionRoot = {
  /** fetch data from the table: "account_transactions" */
  account_transactions: Array<AccountTransactions>;
  /** fetch aggregated fields from the table: "account_transactions" */
  account_transactions_aggregate: AccountTransactionsAggregate;
  /** fetch data from the table: "account_transactions" using primary key columns */
  account_transactions_by_pk?: Maybe<AccountTransactions>;
  /** fetch data from the table in a streaming manner: "account_transactions" */
  account_transactions_stream: Array<AccountTransactions>;
  /** fetch data from the table: "address_events_summary" */
  address_events_summary: Array<AddressEventsSummary>;
  /** fetch aggregated fields from the table: "address_events_summary" */
  address_events_summary_aggregate: AddressEventsSummaryAggregate;
  /** fetch data from the table in a streaming manner: "address_events_summary" */
  address_events_summary_stream: Array<AddressEventsSummary>;
  /** fetch data from the table: "address_version_from_events" */
  address_version_from_events: Array<AddressVersionFromEvents>;
  /** fetch aggregated fields from the table: "address_version_from_events" */
  address_version_from_events_aggregate: AddressVersionFromEventsAggregate;
  /** fetch data from the table in a streaming manner: "address_version_from_events" */
  address_version_from_events_stream: Array<AddressVersionFromEvents>;
  /** fetch data from the table: "address_version_from_move_resources" */
  address_version_from_move_resources: Array<AddressVersionFromMoveResources>;
  /** fetch aggregated fields from the table: "address_version_from_move_resources" */
  address_version_from_move_resources_aggregate: AddressVersionFromMoveResourcesAggregate;
  /** fetch data from the table in a streaming manner: "address_version_from_move_resources" */
  address_version_from_move_resources_stream: Array<AddressVersionFromMoveResources>;
  /** fetch data from the table: "ans_lookup" */
  ans_lookup: Array<AnsLookup>;
  /** fetch aggregated fields from the table: "ans_lookup" */
  ans_lookup_aggregate: AnsLookupAggregate;
  /** fetch data from the table: "ans_lookup" using primary key columns */
  ans_lookup_by_pk?: Maybe<AnsLookup>;
  /** fetch data from the table in a streaming manner: "ans_lookup" */
  ans_lookup_stream: Array<AnsLookup>;
  /** fetch data from the table: "ans_lookup_v2" */
  ans_lookup_v2: Array<AnsLookupV2>;
  /** fetch aggregated fields from the table: "ans_lookup_v2" */
  ans_lookup_v2_aggregate: AnsLookupV2Aggregate;
  /** fetch data from the table: "ans_lookup_v2" using primary key columns */
  ans_lookup_v2_by_pk?: Maybe<AnsLookupV2>;
  /** fetch data from the table in a streaming manner: "ans_lookup_v2" */
  ans_lookup_v2_stream: Array<AnsLookupV2>;
  /** fetch data from the table: "ans_primary_name" */
  ans_primary_name: Array<AnsPrimaryName>;
  /** fetch aggregated fields from the table: "ans_primary_name" */
  ans_primary_name_aggregate: AnsPrimaryNameAggregate;
  /** fetch data from the table: "ans_primary_name" using primary key columns */
  ans_primary_name_by_pk?: Maybe<AnsPrimaryName>;
  /** fetch data from the table in a streaming manner: "ans_primary_name" */
  ans_primary_name_stream: Array<AnsPrimaryName>;
  /** fetch data from the table: "ans_primary_name_v2" */
  ans_primary_name_v2: Array<AnsPrimaryNameV2>;
  /** fetch aggregated fields from the table: "ans_primary_name_v2" */
  ans_primary_name_v2_aggregate: AnsPrimaryNameV2Aggregate;
  /** fetch data from the table: "ans_primary_name_v2" using primary key columns */
  ans_primary_name_v2_by_pk?: Maybe<AnsPrimaryNameV2>;
  /** fetch data from the table in a streaming manner: "ans_primary_name_v2" */
  ans_primary_name_v2_stream: Array<AnsPrimaryNameV2>;
  /** fetch data from the table: "auth_key_account_addresses" */
  auth_key_account_addresses: Array<AuthKeyAccountAddresses>;
  /** fetch aggregated fields from the table: "auth_key_account_addresses" */
  auth_key_account_addresses_aggregate: AuthKeyAccountAddressesAggregate;
  /** fetch data from the table: "auth_key_account_addresses" using primary key columns */
  auth_key_account_addresses_by_pk?: Maybe<AuthKeyAccountAddresses>;
  /** fetch data from the table in a streaming manner: "auth_key_account_addresses" */
  auth_key_account_addresses_stream: Array<AuthKeyAccountAddresses>;
  /** fetch data from the table: "block_metadata_transactions" */
  block_metadata_transactions: Array<BlockMetadataTransactions>;
  /** fetch aggregated fields from the table: "block_metadata_transactions" */
  block_metadata_transactions_aggregate: BlockMetadataTransactionsAggregate;
  /** fetch data from the table: "block_metadata_transactions" using primary key columns */
  block_metadata_transactions_by_pk?: Maybe<BlockMetadataTransactions>;
  /** fetch data from the table in a streaming manner: "block_metadata_transactions" */
  block_metadata_transactions_stream: Array<BlockMetadataTransactions>;
  /** fetch data from the table: "coin_activities" */
  coin_activities: Array<CoinActivities>;
  /** fetch aggregated fields from the table: "coin_activities" */
  coin_activities_aggregate: CoinActivitiesAggregate;
  /** fetch data from the table: "coin_activities" using primary key columns */
  coin_activities_by_pk?: Maybe<CoinActivities>;
  /** fetch data from the table in a streaming manner: "coin_activities" */
  coin_activities_stream: Array<CoinActivities>;
  /** fetch data from the table: "coin_balances" */
  coin_balances: Array<CoinBalances>;
  /** fetch aggregated fields from the table: "coin_balances" */
  coin_balances_aggregate: CoinBalancesAggregate;
  /** fetch data from the table: "coin_balances" using primary key columns */
  coin_balances_by_pk?: Maybe<CoinBalances>;
  /** fetch data from the table in a streaming manner: "coin_balances" */
  coin_balances_stream: Array<CoinBalances>;
  /** fetch data from the table: "coin_infos" */
  coin_infos: Array<CoinInfos>;
  /** fetch aggregated fields from the table: "coin_infos" */
  coin_infos_aggregate: CoinInfosAggregate;
  /** fetch data from the table: "coin_infos" using primary key columns */
  coin_infos_by_pk?: Maybe<CoinInfos>;
  /** fetch data from the table in a streaming manner: "coin_infos" */
  coin_infos_stream: Array<CoinInfos>;
  /** fetch data from the table: "coin_supply" */
  coin_supply: Array<CoinSupply>;
  /** fetch aggregated fields from the table: "coin_supply" */
  coin_supply_aggregate: CoinSupplyAggregate;
  /** fetch data from the table: "coin_supply" using primary key columns */
  coin_supply_by_pk?: Maybe<CoinSupply>;
  /** fetch data from the table in a streaming manner: "coin_supply" */
  coin_supply_stream: Array<CoinSupply>;
  /** fetch data from the table: "collection_datas" */
  collection_datas: Array<CollectionDatas>;
  /** fetch aggregated fields from the table: "collection_datas" */
  collection_datas_aggregate: CollectionDatasAggregate;
  /** fetch data from the table: "collection_datas" using primary key columns */
  collection_datas_by_pk?: Maybe<CollectionDatas>;
  /** fetch data from the table in a streaming manner: "collection_datas" */
  collection_datas_stream: Array<CollectionDatas>;
  /** fetch data from the table: "collections_v2" */
  collections_v2: Array<CollectionsV2>;
  /** fetch aggregated fields from the table: "collections_v2" */
  collections_v2_aggregate: CollectionsV2Aggregate;
  /** fetch data from the table: "collections_v2" using primary key columns */
  collections_v2_by_pk?: Maybe<CollectionsV2>;
  /** fetch data from the table in a streaming manner: "collections_v2" */
  collections_v2_stream: Array<CollectionsV2>;
  /** fetch data from the table: "current_ans_lookup" */
  current_ans_lookup: Array<CurrentAnsLookup>;
  /** fetch aggregated fields from the table: "current_ans_lookup" */
  current_ans_lookup_aggregate: CurrentAnsLookupAggregate;
  /** fetch data from the table: "current_ans_lookup" using primary key columns */
  current_ans_lookup_by_pk?: Maybe<CurrentAnsLookup>;
  /** fetch data from the table in a streaming manner: "current_ans_lookup" */
  current_ans_lookup_stream: Array<CurrentAnsLookup>;
  /** fetch data from the table: "current_ans_lookup_v2" */
  current_ans_lookup_v2: Array<CurrentAnsLookupV2>;
  /** fetch aggregated fields from the table: "current_ans_lookup_v2" */
  current_ans_lookup_v2_aggregate: CurrentAnsLookupV2Aggregate;
  /** fetch data from the table: "current_ans_lookup_v2" using primary key columns */
  current_ans_lookup_v2_by_pk?: Maybe<CurrentAnsLookupV2>;
  /** fetch data from the table in a streaming manner: "current_ans_lookup_v2" */
  current_ans_lookup_v2_stream: Array<CurrentAnsLookupV2>;
  /** fetch data from the table: "current_ans_primary_name" */
  current_ans_primary_name: Array<CurrentAnsPrimaryName>;
  /** fetch aggregated fields from the table: "current_ans_primary_name" */
  current_ans_primary_name_aggregate: CurrentAnsPrimaryNameAggregate;
  /** fetch data from the table: "current_ans_primary_name" using primary key columns */
  current_ans_primary_name_by_pk?: Maybe<CurrentAnsPrimaryName>;
  /** fetch data from the table in a streaming manner: "current_ans_primary_name" */
  current_ans_primary_name_stream: Array<CurrentAnsPrimaryName>;
  /** fetch data from the table: "current_ans_primary_name_v2" */
  current_ans_primary_name_v2: Array<CurrentAnsPrimaryNameV2>;
  /** fetch aggregated fields from the table: "current_ans_primary_name_v2" */
  current_ans_primary_name_v2_aggregate: CurrentAnsPrimaryNameV2Aggregate;
  /** fetch data from the table: "current_ans_primary_name_v2" using primary key columns */
  current_ans_primary_name_v2_by_pk?: Maybe<CurrentAnsPrimaryNameV2>;
  /** fetch data from the table in a streaming manner: "current_ans_primary_name_v2" */
  current_ans_primary_name_v2_stream: Array<CurrentAnsPrimaryNameV2>;
  /** fetch data from the table: "current_cedra_names" */
  current_cedra_names: Array<CurrentCedraNames>;
  /** fetch aggregated fields from the table: "current_cedra_names" */
  current_cedra_names_aggregate: CurrentCedraNamesAggregate;
  /** fetch data from the table in a streaming manner: "current_cedra_names" */
  current_cedra_names_stream: Array<CurrentCedraNames>;
  /** fetch data from the table: "current_coin_balances" */
  current_coin_balances: Array<CurrentCoinBalances>;
  /** fetch aggregated fields from the table: "current_coin_balances" */
  current_coin_balances_aggregate: CurrentCoinBalancesAggregate;
  /** fetch data from the table: "current_coin_balances" using primary key columns */
  current_coin_balances_by_pk?: Maybe<CurrentCoinBalances>;
  /** fetch data from the table in a streaming manner: "current_coin_balances" */
  current_coin_balances_stream: Array<CurrentCoinBalances>;
  /** fetch data from the table: "current_collection_datas" */
  current_collection_datas: Array<CurrentCollectionDatas>;
  /** fetch aggregated fields from the table: "current_collection_datas" */
  current_collection_datas_aggregate: CurrentCollectionDatasAggregate;
  /** fetch data from the table: "current_collection_datas" using primary key columns */
  current_collection_datas_by_pk?: Maybe<CurrentCollectionDatas>;
  /** fetch data from the table in a streaming manner: "current_collection_datas" */
  current_collection_datas_stream: Array<CurrentCollectionDatas>;
  /** fetch data from the table: "current_collection_ownership_v2_view" */
  current_collection_ownership_v2_view: Array<CurrentCollectionOwnershipV2View>;
  /** fetch aggregated fields from the table: "current_collection_ownership_v2_view" */
  current_collection_ownership_v2_view_aggregate: CurrentCollectionOwnershipV2ViewAggregate;
  /** fetch data from the table in a streaming manner: "current_collection_ownership_v2_view" */
  current_collection_ownership_v2_view_stream: Array<CurrentCollectionOwnershipV2View>;
  /** fetch data from the table: "current_collection_ownership_view" */
  current_collection_ownership_view: Array<CurrentCollectionOwnershipView>;
  /** fetch aggregated fields from the table: "current_collection_ownership_view" */
  current_collection_ownership_view_aggregate: CurrentCollectionOwnershipViewAggregate;
  /** fetch data from the table in a streaming manner: "current_collection_ownership_view" */
  current_collection_ownership_view_stream: Array<CurrentCollectionOwnershipView>;
  /** fetch data from the table: "current_collections_v2" */
  current_collections_v2: Array<CurrentCollectionsV2>;
  /** fetch aggregated fields from the table: "current_collections_v2" */
  current_collections_v2_aggregate: CurrentCollectionsV2Aggregate;
  /** fetch data from the table: "current_collections_v2" using primary key columns */
  current_collections_v2_by_pk?: Maybe<CurrentCollectionsV2>;
  /** fetch data from the table in a streaming manner: "current_collections_v2" */
  current_collections_v2_stream: Array<CurrentCollectionsV2>;
  /** fetch data from the table: "current_delegated_staking_pool_balances" */
  current_delegated_staking_pool_balances: Array<CurrentDelegatedStakingPoolBalances>;
  /** fetch aggregated fields from the table: "current_delegated_staking_pool_balances" */
  current_delegated_staking_pool_balances_aggregate: CurrentDelegatedStakingPoolBalancesAggregate;
  /** fetch data from the table: "current_delegated_staking_pool_balances" using primary key columns */
  current_delegated_staking_pool_balances_by_pk?: Maybe<CurrentDelegatedStakingPoolBalances>;
  /** fetch data from the table in a streaming manner: "current_delegated_staking_pool_balances" */
  current_delegated_staking_pool_balances_stream: Array<CurrentDelegatedStakingPoolBalances>;
  /** fetch data from the table: "current_delegated_voter" */
  current_delegated_voter: Array<CurrentDelegatedVoter>;
  /** fetch aggregated fields from the table: "current_delegated_voter" */
  current_delegated_voter_aggregate: CurrentDelegatedVoterAggregate;
  /** fetch data from the table: "current_delegated_voter" using primary key columns */
  current_delegated_voter_by_pk?: Maybe<CurrentDelegatedVoter>;
  /** fetch data from the table in a streaming manner: "current_delegated_voter" */
  current_delegated_voter_stream: Array<CurrentDelegatedVoter>;
  /** fetch data from the table: "current_delegator_balances" */
  current_delegator_balances: Array<CurrentDelegatorBalances>;
  /** fetch aggregated fields from the table: "current_delegator_balances" */
  current_delegator_balances_aggregate: CurrentDelegatorBalancesAggregate;
  /** fetch data from the table: "current_delegator_balances" using primary key columns */
  current_delegator_balances_by_pk?: Maybe<CurrentDelegatorBalances>;
  /** fetch data from the table in a streaming manner: "current_delegator_balances" */
  current_delegator_balances_stream: Array<CurrentDelegatorBalances>;
  /** fetch data from the table: "current_fungible_asset_balances_legacy" */
  current_fungible_asset_balances: Array<CurrentFungibleAssetBalances>;
  /** fetch aggregated fields from the table: "current_fungible_asset_balances_legacy" */
  current_fungible_asset_balances_aggregate: CurrentFungibleAssetBalancesAggregate;
  /** fetch data from the table: "current_fungible_asset_balances_legacy" using primary key columns */
  current_fungible_asset_balances_by_pk?: Maybe<CurrentFungibleAssetBalances>;
  /** fetch data from the table: "current_fungible_asset_balances" */
  current_fungible_asset_balances_new: Array<CurrentFungibleAssetBalancesNew>;
  /** fetch aggregated fields from the table: "current_fungible_asset_balances" */
  current_fungible_asset_balances_new_aggregate: CurrentFungibleAssetBalancesNewAggregate;
  /** fetch data from the table: "current_fungible_asset_balances" using primary key columns */
  current_fungible_asset_balances_new_by_pk?: Maybe<CurrentFungibleAssetBalancesNew>;
  /** fetch data from the table in a streaming manner: "current_fungible_asset_balances" */
  current_fungible_asset_balances_new_stream: Array<CurrentFungibleAssetBalancesNew>;
  /** fetch data from the table in a streaming manner: "current_fungible_asset_balances_legacy" */
  current_fungible_asset_balances_stream: Array<CurrentFungibleAssetBalances>;
  /** fetch data from the table: "current_objects" */
  current_objects: Array<CurrentObjects>;
  /** fetch aggregated fields from the table: "current_objects" */
  current_objects_aggregate: CurrentObjectsAggregate;
  /** fetch data from the table: "current_objects" using primary key columns */
  current_objects_by_pk?: Maybe<CurrentObjects>;
  /** fetch data from the table in a streaming manner: "current_objects" */
  current_objects_stream: Array<CurrentObjects>;
  /** fetch data from the table: "current_staking_pool_voter" */
  current_staking_pool_voter: Array<CurrentStakingPoolVoter>;
  /** fetch aggregated fields from the table: "current_staking_pool_voter" */
  current_staking_pool_voter_aggregate: CurrentStakingPoolVoterAggregate;
  /** fetch data from the table: "current_staking_pool_voter" using primary key columns */
  current_staking_pool_voter_by_pk?: Maybe<CurrentStakingPoolVoter>;
  /** fetch data from the table in a streaming manner: "current_staking_pool_voter" */
  current_staking_pool_voter_stream: Array<CurrentStakingPoolVoter>;
  /** fetch data from the table: "current_table_items" */
  current_table_items: Array<CurrentTableItems>;
  /** fetch aggregated fields from the table: "current_table_items" */
  current_table_items_aggregate: CurrentTableItemsAggregate;
  /** fetch data from the table: "current_table_items" using primary key columns */
  current_table_items_by_pk?: Maybe<CurrentTableItems>;
  /** fetch data from the table in a streaming manner: "current_table_items" */
  current_table_items_stream: Array<CurrentTableItems>;
  /** fetch data from the table: "current_table_items_view" */
  current_table_items_view: Array<CurrentTableItemsView>;
  /** fetch aggregated fields from the table: "current_table_items_view" */
  current_table_items_view_aggregate: CurrentTableItemsViewAggregate;
  /** fetch data from the table in a streaming manner: "current_table_items_view" */
  current_table_items_view_stream: Array<CurrentTableItemsView>;
  /** fetch data from the table: "current_token_datas" */
  current_token_datas: Array<CurrentTokenDatas>;
  /** fetch aggregated fields from the table: "current_token_datas" */
  current_token_datas_aggregate: CurrentTokenDatasAggregate;
  /** fetch data from the table: "current_token_datas" using primary key columns */
  current_token_datas_by_pk?: Maybe<CurrentTokenDatas>;
  /** fetch data from the table in a streaming manner: "current_token_datas" */
  current_token_datas_stream: Array<CurrentTokenDatas>;
  /** fetch data from the table: "current_token_datas_v2" */
  current_token_datas_v2: Array<CurrentTokenDatasV2>;
  /** fetch aggregated fields from the table: "current_token_datas_v2" */
  current_token_datas_v2_aggregate: CurrentTokenDatasV2Aggregate;
  /** fetch data from the table: "current_token_datas_v2" using primary key columns */
  current_token_datas_v2_by_pk?: Maybe<CurrentTokenDatasV2>;
  /** fetch data from the table in a streaming manner: "current_token_datas_v2" */
  current_token_datas_v2_stream: Array<CurrentTokenDatasV2>;
  /** fetch data from the table: "current_token_ownerships" */
  current_token_ownerships: Array<CurrentTokenOwnerships>;
  /** fetch aggregated fields from the table: "current_token_ownerships" */
  current_token_ownerships_aggregate: CurrentTokenOwnershipsAggregate;
  /** fetch data from the table: "current_token_ownerships" using primary key columns */
  current_token_ownerships_by_pk?: Maybe<CurrentTokenOwnerships>;
  /** fetch data from the table in a streaming manner: "current_token_ownerships" */
  current_token_ownerships_stream: Array<CurrentTokenOwnerships>;
  /** fetch data from the table: "current_token_ownerships_v2" */
  current_token_ownerships_v2: Array<CurrentTokenOwnershipsV2>;
  /** fetch aggregated fields from the table: "current_token_ownerships_v2" */
  current_token_ownerships_v2_aggregate: CurrentTokenOwnershipsV2Aggregate;
  /** fetch data from the table: "current_token_ownerships_v2" using primary key columns */
  current_token_ownerships_v2_by_pk?: Maybe<CurrentTokenOwnershipsV2>;
  /** fetch data from the table in a streaming manner: "current_token_ownerships_v2" */
  current_token_ownerships_v2_stream: Array<CurrentTokenOwnershipsV2>;
  /** fetch data from the table: "current_token_pending_claims" */
  current_token_pending_claims: Array<CurrentTokenPendingClaims>;
  /** fetch aggregated fields from the table: "current_token_pending_claims" */
  current_token_pending_claims_aggregate: CurrentTokenPendingClaimsAggregate;
  /** fetch data from the table: "current_token_pending_claims" using primary key columns */
  current_token_pending_claims_by_pk?: Maybe<CurrentTokenPendingClaims>;
  /** fetch data from the table in a streaming manner: "current_token_pending_claims" */
  current_token_pending_claims_stream: Array<CurrentTokenPendingClaims>;
  /** fetch data from the table: "current_token_royalty_v1" */
  current_token_royalty_v1: Array<CurrentTokenRoyaltyV1>;
  /** fetch aggregated fields from the table: "current_token_royalty_v1" */
  current_token_royalty_v1_aggregate: CurrentTokenRoyaltyV1Aggregate;
  /** fetch data from the table: "current_token_royalty_v1" using primary key columns */
  current_token_royalty_v1_by_pk?: Maybe<CurrentTokenRoyaltyV1>;
  /** fetch data from the table in a streaming manner: "current_token_royalty_v1" */
  current_token_royalty_v1_stream: Array<CurrentTokenRoyaltyV1>;
  /** fetch data from the table: "current_token_v2_metadata" */
  current_token_v2_metadata: Array<CurrentTokenV2Metadata>;
  /** fetch aggregated fields from the table: "current_token_v2_metadata" */
  current_token_v2_metadata_aggregate: CurrentTokenV2MetadataAggregate;
  /** fetch data from the table: "current_token_v2_metadata" using primary key columns */
  current_token_v2_metadata_by_pk?: Maybe<CurrentTokenV2Metadata>;
  /** fetch data from the table in a streaming manner: "current_token_v2_metadata" */
  current_token_v2_metadata_stream: Array<CurrentTokenV2Metadata>;
  /** fetch data from the table: "delegated_staking_activities" */
  delegated_staking_activities: Array<DelegatedStakingActivities>;
  /** fetch aggregated fields from the table: "delegated_staking_activities" */
  delegated_staking_activities_aggregate: DelegatedStakingActivitiesAggregate;
  /** fetch data from the table: "delegated_staking_activities" using primary key columns */
  delegated_staking_activities_by_pk?: Maybe<DelegatedStakingActivities>;
  /** fetch data from the table in a streaming manner: "delegated_staking_activities" */
  delegated_staking_activities_stream: Array<DelegatedStakingActivities>;
  /** fetch data from the table: "delegated_staking_pool_balances" */
  delegated_staking_pool_balances: Array<DelegatedStakingPoolBalances>;
  /** fetch aggregated fields from the table: "delegated_staking_pool_balances" */
  delegated_staking_pool_balances_aggregate: DelegatedStakingPoolBalancesAggregate;
  /** fetch data from the table: "delegated_staking_pool_balances" using primary key columns */
  delegated_staking_pool_balances_by_pk?: Maybe<DelegatedStakingPoolBalances>;
  /** fetch data from the table in a streaming manner: "delegated_staking_pool_balances" */
  delegated_staking_pool_balances_stream: Array<DelegatedStakingPoolBalances>;
  /** fetch data from the table: "delegated_staking_pools" */
  delegated_staking_pools: Array<DelegatedStakingPools>;
  /** fetch aggregated fields from the table: "delegated_staking_pools" */
  delegated_staking_pools_aggregate: DelegatedStakingPoolsAggregate;
  /** fetch data from the table: "delegated_staking_pools" using primary key columns */
  delegated_staking_pools_by_pk?: Maybe<DelegatedStakingPools>;
  /** fetch data from the table in a streaming manner: "delegated_staking_pools" */
  delegated_staking_pools_stream: Array<DelegatedStakingPools>;
  /** fetch data from the table: "delegator_balances" */
  delegator_balances: Array<DelegatorBalances>;
  /** fetch aggregated fields from the table: "delegator_balances" */
  delegator_balances_aggregate: DelegatorBalancesAggregate;
  /** fetch data from the table: "delegator_balances" using primary key columns */
  delegator_balances_by_pk?: Maybe<DelegatorBalances>;
  /** fetch data from the table in a streaming manner: "delegator_balances" */
  delegator_balances_stream: Array<DelegatorBalances>;
  /** fetch data from the table: "delegator_distinct_pool" */
  delegator_distinct_pool: Array<DelegatorDistinctPool>;
  /** fetch aggregated fields from the table: "delegator_distinct_pool" */
  delegator_distinct_pool_aggregate: DelegatorDistinctPoolAggregate;
  /** fetch data from the table in a streaming manner: "delegator_distinct_pool" */
  delegator_distinct_pool_stream: Array<DelegatorDistinctPool>;
  /** fetch data from the table: "event_size_info" */
  event_size_info: Array<EventSizeInfo>;
  /** fetch aggregated fields from the table: "event_size_info" */
  event_size_info_aggregate: EventSizeInfoAggregate;
  /** fetch data from the table: "event_size_info" using primary key columns */
  event_size_info_by_pk?: Maybe<EventSizeInfo>;
  /** fetch data from the table in a streaming manner: "event_size_info" */
  event_size_info_stream: Array<EventSizeInfo>;
  /** fetch data from the table: "events" */
  events: Array<Events>;
  /** fetch aggregated fields from the table: "events" */
  events_aggregate: EventsAggregate;
  /** fetch data from the table: "events" using primary key columns */
  events_by_pk?: Maybe<Events>;
  /** fetch data from the table in a streaming manner: "events" */
  events_stream: Array<Events>;
  /** fetch data from the table: "events_view" */
  events_view: Array<EventsView>;
  /** fetch aggregated fields from the table: "events_view" */
  events_view_aggregate: EventsViewAggregate;
  /** fetch data from the table in a streaming manner: "events_view" */
  events_view_stream: Array<EventsView>;
  /** fetch data from the table: "fungible_asset_activities" */
  fungible_asset_activities: Array<FungibleAssetActivities>;
  /** fetch aggregated fields from the table: "fungible_asset_activities" */
  fungible_asset_activities_aggregate: FungibleAssetActivitiesAggregate;
  /** fetch data from the table: "fungible_asset_activities" using primary key columns */
  fungible_asset_activities_by_pk?: Maybe<FungibleAssetActivities>;
  /** fetch data from the table in a streaming manner: "fungible_asset_activities" */
  fungible_asset_activities_stream: Array<FungibleAssetActivities>;
  /** fetch data from the table: "fungible_asset_balances" */
  fungible_asset_balances: Array<FungibleAssetBalances>;
  /** fetch aggregated fields from the table: "fungible_asset_balances" */
  fungible_asset_balances_aggregate: FungibleAssetBalancesAggregate;
  /** fetch data from the table: "fungible_asset_balances" using primary key columns */
  fungible_asset_balances_by_pk?: Maybe<FungibleAssetBalances>;
  /** fetch data from the table in a streaming manner: "fungible_asset_balances" */
  fungible_asset_balances_stream: Array<FungibleAssetBalances>;
  /** fetch data from the table: "fungible_asset_metadata" */
  fungible_asset_metadata: Array<FungibleAssetMetadata>;
  /** fetch aggregated fields from the table: "fungible_asset_metadata" */
  fungible_asset_metadata_aggregate: FungibleAssetMetadataAggregate;
  /** fetch data from the table: "fungible_asset_metadata" using primary key columns */
  fungible_asset_metadata_by_pk?: Maybe<FungibleAssetMetadata>;
  /** fetch data from the table in a streaming manner: "fungible_asset_metadata" */
  fungible_asset_metadata_stream: Array<FungibleAssetMetadata>;
  /** fetch data from the table: "fungible_asset_to_coin_mappings" */
  fungible_asset_to_coin_mappings: Array<FungibleAssetToCoinMappings>;
  /** fetch aggregated fields from the table: "fungible_asset_to_coin_mappings" */
  fungible_asset_to_coin_mappings_aggregate: FungibleAssetToCoinMappingsAggregate;
  /** fetch data from the table: "fungible_asset_to_coin_mappings" using primary key columns */
  fungible_asset_to_coin_mappings_by_pk?: Maybe<FungibleAssetToCoinMappings>;
  /** fetch data from the table in a streaming manner: "fungible_asset_to_coin_mappings" */
  fungible_asset_to_coin_mappings_stream: Array<FungibleAssetToCoinMappings>;
  /** fetch data from the table: "gas_fees" */
  gas_fees: Array<GasFees>;
  /** fetch aggregated fields from the table: "gas_fees" */
  gas_fees_aggregate: GasFeesAggregate;
  /** fetch data from the table: "gas_fees" using primary key columns */
  gas_fees_by_pk?: Maybe<GasFees>;
  /** fetch data from the table in a streaming manner: "gas_fees" */
  gas_fees_stream: Array<GasFees>;
  /** fetch data from the table: "indexer_status" */
  indexer_status: Array<IndexerStatus>;
  /** fetch aggregated fields from the table: "indexer_status" */
  indexer_status_aggregate: IndexerStatusAggregate;
  /** fetch data from the table: "indexer_status" using primary key columns */
  indexer_status_by_pk?: Maybe<IndexerStatus>;
  /** fetch data from the table in a streaming manner: "indexer_status" */
  indexer_status_stream: Array<IndexerStatus>;
  /** fetch data from the table: "move_modules" */
  move_modules: Array<MoveModules>;
  /** fetch aggregated fields from the table: "move_modules" */
  move_modules_aggregate: MoveModulesAggregate;
  /** fetch data from the table: "move_modules" using primary key columns */
  move_modules_by_pk?: Maybe<MoveModules>;
  /** fetch data from the table in a streaming manner: "move_modules" */
  move_modules_stream: Array<MoveModules>;
  /** fetch data from the table: "move_resources" */
  move_resources: Array<MoveResources>;
  /** fetch aggregated fields from the table: "move_resources" */
  move_resources_aggregate: MoveResourcesAggregate;
  /** fetch data from the table: "move_resources" using primary key columns */
  move_resources_by_pk?: Maybe<MoveResources>;
  /** fetch data from the table in a streaming manner: "move_resources" */
  move_resources_stream: Array<MoveResources>;
  /** fetch data from the table: "move_resources_view" */
  move_resources_view: Array<MoveResourcesView>;
  /** fetch aggregated fields from the table: "move_resources_view" */
  move_resources_view_aggregate: MoveResourcesViewAggregate;
  /** fetch data from the table in a streaming manner: "move_resources_view" */
  move_resources_view_stream: Array<MoveResourcesView>;
  /** fetch data from the table: "nft_metadata_crawler.parsed_asset_uris" */
  nft_metadata_crawler_parsed_asset_uris: Array<NftMetadataCrawlerParsedAssetUris>;
  /** fetch aggregated fields from the table: "nft_metadata_crawler.parsed_asset_uris" */
  nft_metadata_crawler_parsed_asset_uris_aggregate: NftMetadataCrawlerParsedAssetUrisAggregate;
  /** fetch data from the table: "nft_metadata_crawler.parsed_asset_uris" using primary key columns */
  nft_metadata_crawler_parsed_asset_uris_by_pk?: Maybe<NftMetadataCrawlerParsedAssetUris>;
  /** fetch data from the table in a streaming manner: "nft_metadata_crawler.parsed_asset_uris" */
  nft_metadata_crawler_parsed_asset_uris_stream: Array<NftMetadataCrawlerParsedAssetUris>;
  /** fetch data from the table: "nft_points" */
  nft_points: Array<NftPoints>;
  /** fetch aggregated fields from the table: "nft_points" */
  nft_points_aggregate: NftPointsAggregate;
  /** fetch data from the table: "nft_points" using primary key columns */
  nft_points_by_pk?: Maybe<NftPoints>;
  /** fetch data from the table in a streaming manner: "nft_points" */
  nft_points_stream: Array<NftPoints>;
  /** fetch data from the table: "num_active_delegator_per_pool" */
  num_active_delegator_per_pool: Array<NumActiveDelegatorPerPool>;
  /** fetch aggregated fields from the table: "num_active_delegator_per_pool" */
  num_active_delegator_per_pool_aggregate: NumActiveDelegatorPerPoolAggregate;
  /** fetch data from the table in a streaming manner: "num_active_delegator_per_pool" */
  num_active_delegator_per_pool_stream: Array<NumActiveDelegatorPerPool>;
  /** fetch data from the table: "objects" */
  objects: Array<Objects>;
  /** fetch aggregated fields from the table: "objects" */
  objects_aggregate: ObjectsAggregate;
  /** fetch data from the table: "objects" using primary key columns */
  objects_by_pk?: Maybe<Objects>;
  /** fetch data from the table in a streaming manner: "objects" */
  objects_stream: Array<Objects>;
  /** fetch data from the table: "processor_metadata.processor_status" */
  processor_metadata_processor_status: Array<ProcessorMetadataProcessorStatus>;
  /** fetch aggregated fields from the table: "processor_metadata.processor_status" */
  processor_metadata_processor_status_aggregate: ProcessorMetadataProcessorStatusAggregate;
  /** fetch data from the table: "processor_metadata.processor_status" using primary key columns */
  processor_metadata_processor_status_by_pk?: Maybe<ProcessorMetadataProcessorStatus>;
  /** fetch data from the table in a streaming manner: "processor_metadata.processor_status" */
  processor_metadata_processor_status_stream: Array<ProcessorMetadataProcessorStatus>;
  /** fetch data from the table: "processor_status" */
  processor_status: Array<ProcessorStatus>;
  /** fetch aggregated fields from the table: "processor_status" */
  processor_status_aggregate: ProcessorStatusAggregate;
  /** fetch data from the table: "processor_status" using primary key columns */
  processor_status_by_pk?: Maybe<ProcessorStatus>;
  /** fetch data from the table in a streaming manner: "processor_status" */
  processor_status_stream: Array<ProcessorStatus>;
  /** fetch data from the table: "proposal_votes" */
  proposal_votes: Array<ProposalVotes>;
  /** fetch aggregated fields from the table: "proposal_votes" */
  proposal_votes_aggregate: ProposalVotesAggregate;
  /** fetch data from the table: "proposal_votes" using primary key columns */
  proposal_votes_by_pk?: Maybe<ProposalVotes>;
  /** fetch data from the table in a streaming manner: "proposal_votes" */
  proposal_votes_stream: Array<ProposalVotes>;
  /** fetch data from the table: "public_key_auth_keys" */
  public_key_auth_keys: Array<PublicKeyAuthKeys>;
  /** fetch aggregated fields from the table: "public_key_auth_keys" */
  public_key_auth_keys_aggregate: PublicKeyAuthKeysAggregate;
  /** fetch data from the table: "public_key_auth_keys" using primary key columns */
  public_key_auth_keys_by_pk?: Maybe<PublicKeyAuthKeys>;
  /** fetch data from the table in a streaming manner: "public_key_auth_keys" */
  public_key_auth_keys_stream: Array<PublicKeyAuthKeys>;
  /** fetch data from the table: "signatures" */
  signatures: Array<Signatures>;
  /** fetch aggregated fields from the table: "signatures" */
  signatures_aggregate: SignaturesAggregate;
  /** fetch data from the table: "signatures" using primary key columns */
  signatures_by_pk?: Maybe<Signatures>;
  /** fetch data from the table in a streaming manner: "signatures" */
  signatures_stream: Array<Signatures>;
  /** fetch data from the table: "spam_assets" */
  spam_assets: Array<SpamAssets>;
  /** fetch aggregated fields from the table: "spam_assets" */
  spam_assets_aggregate: SpamAssetsAggregate;
  /** fetch data from the table: "spam_assets" using primary key columns */
  spam_assets_by_pk?: Maybe<SpamAssets>;
  /** fetch data from the table in a streaming manner: "spam_assets" */
  spam_assets_stream: Array<SpamAssets>;
  /** fetch data from the table: "table_items" */
  table_items: Array<TableItems>;
  /** fetch aggregated fields from the table: "table_items" */
  table_items_aggregate: TableItemsAggregate;
  /** fetch data from the table: "table_items" using primary key columns */
  table_items_by_pk?: Maybe<TableItems>;
  /** fetch data from the table in a streaming manner: "table_items" */
  table_items_stream: Array<TableItems>;
  /** fetch data from the table: "table_items_view" */
  table_items_view: Array<TableItemsView>;
  /** fetch aggregated fields from the table: "table_items_view" */
  table_items_view_aggregate: TableItemsViewAggregate;
  /** fetch data from the table in a streaming manner: "table_items_view" */
  table_items_view_stream: Array<TableItemsView>;
  /** fetch data from the table: "table_metadatas" */
  table_metadatas: Array<TableMetadatas>;
  /** fetch aggregated fields from the table: "table_metadatas" */
  table_metadatas_aggregate: TableMetadatasAggregate;
  /** fetch data from the table: "table_metadatas" using primary key columns */
  table_metadatas_by_pk?: Maybe<TableMetadatas>;
  /** fetch data from the table in a streaming manner: "table_metadatas" */
  table_metadatas_stream: Array<TableMetadatas>;
  /** fetch data from the table: "token_activities" */
  token_activities: Array<TokenActivities>;
  /** fetch aggregated fields from the table: "token_activities" */
  token_activities_aggregate: TokenActivitiesAggregate;
  /** fetch data from the table: "token_activities" using primary key columns */
  token_activities_by_pk?: Maybe<TokenActivities>;
  /** fetch data from the table in a streaming manner: "token_activities" */
  token_activities_stream: Array<TokenActivities>;
  /** fetch data from the table: "token_activities_v2" */
  token_activities_v2: Array<TokenActivitiesV2>;
  /** fetch aggregated fields from the table: "token_activities_v2" */
  token_activities_v2_aggregate: TokenActivitiesV2Aggregate;
  /** fetch data from the table: "token_activities_v2" using primary key columns */
  token_activities_v2_by_pk?: Maybe<TokenActivitiesV2>;
  /** fetch data from the table in a streaming manner: "token_activities_v2" */
  token_activities_v2_stream: Array<TokenActivitiesV2>;
  /** fetch data from the table: "token_datas" */
  token_datas: Array<TokenDatas>;
  /** fetch aggregated fields from the table: "token_datas" */
  token_datas_aggregate: TokenDatasAggregate;
  /** fetch data from the table: "token_datas" using primary key columns */
  token_datas_by_pk?: Maybe<TokenDatas>;
  /** fetch data from the table in a streaming manner: "token_datas" */
  token_datas_stream: Array<TokenDatas>;
  /** fetch data from the table: "token_datas_v2" */
  token_datas_v2: Array<TokenDatasV2>;
  /** fetch aggregated fields from the table: "token_datas_v2" */
  token_datas_v2_aggregate: TokenDatasV2Aggregate;
  /** fetch data from the table: "token_datas_v2" using primary key columns */
  token_datas_v2_by_pk?: Maybe<TokenDatasV2>;
  /** fetch data from the table in a streaming manner: "token_datas_v2" */
  token_datas_v2_stream: Array<TokenDatasV2>;
  /** fetch data from the table: "token_ownerships" */
  token_ownerships: Array<TokenOwnerships>;
  /** fetch aggregated fields from the table: "token_ownerships" */
  token_ownerships_aggregate: TokenOwnershipsAggregate;
  /** fetch data from the table: "token_ownerships" using primary key columns */
  token_ownerships_by_pk?: Maybe<TokenOwnerships>;
  /** fetch data from the table in a streaming manner: "token_ownerships" */
  token_ownerships_stream: Array<TokenOwnerships>;
  /** fetch data from the table: "token_ownerships_v2" */
  token_ownerships_v2: Array<TokenOwnershipsV2>;
  /** fetch aggregated fields from the table: "token_ownerships_v2" */
  token_ownerships_v2_aggregate: TokenOwnershipsV2Aggregate;
  /** fetch data from the table: "token_ownerships_v2" using primary key columns */
  token_ownerships_v2_by_pk?: Maybe<TokenOwnershipsV2>;
  /** fetch data from the table in a streaming manner: "token_ownerships_v2" */
  token_ownerships_v2_stream: Array<TokenOwnershipsV2>;
  /** fetch data from the table: "tokens" */
  tokens: Array<Tokens>;
  /** fetch aggregated fields from the table: "tokens" */
  tokens_aggregate: TokensAggregate;
  /** fetch data from the table: "tokens" using primary key columns */
  tokens_by_pk?: Maybe<Tokens>;
  /** fetch data from the table in a streaming manner: "tokens" */
  tokens_stream: Array<Tokens>;
  /** fetch data from the table: "transaction_size_info" */
  transaction_size_info: Array<TransactionSizeInfo>;
  /** fetch aggregated fields from the table: "transaction_size_info" */
  transaction_size_info_aggregate: TransactionSizeInfoAggregate;
  /** fetch data from the table: "transaction_size_info" using primary key columns */
  transaction_size_info_by_pk?: Maybe<TransactionSizeInfo>;
  /** fetch data from the table in a streaming manner: "transaction_size_info" */
  transaction_size_info_stream: Array<TransactionSizeInfo>;
  /** fetch data from the table: "transactions_view" */
  transactions_view: Array<TransactionsView>;
  /** fetch aggregated fields from the table: "transactions_view" */
  transactions_view_aggregate: TransactionsViewAggregate;
  /** fetch data from the table in a streaming manner: "transactions_view" */
  transactions_view_stream: Array<TransactionsView>;
  /** fetch data from the table: "user_transactions" */
  user_transactions: Array<UserTransactions>;
  /** fetch aggregated fields from the table: "user_transactions" */
  user_transactions_aggregate: UserTransactionsAggregate;
  /** fetch data from the table: "user_transactions" using primary key columns */
  user_transactions_by_pk?: Maybe<UserTransactions>;
  /** fetch data from the table in a streaming manner: "user_transactions" */
  user_transactions_stream: Array<UserTransactions>;
};

export type SubscriptionRootAccountTransactionsArgs = {
  distinct_on?: InputMaybe<Array<AccountTransactionsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AccountTransactionsOrderBy>>;
  where?: InputMaybe<AccountTransactionsBoolExp>;
};

export type SubscriptionRootAccountTransactionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<AccountTransactionsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AccountTransactionsOrderBy>>;
  where?: InputMaybe<AccountTransactionsBoolExp>;
};

export type SubscriptionRootAccountTransactionsByPkArgs = {
  account_address: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type SubscriptionRootAccountTransactionsStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<AccountTransactionsStreamCursorInput>>;
  where?: InputMaybe<AccountTransactionsBoolExp>;
};

export type SubscriptionRootAddressEventsSummaryArgs = {
  distinct_on?: InputMaybe<Array<AddressEventsSummarySelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AddressEventsSummaryOrderBy>>;
  where?: InputMaybe<AddressEventsSummaryBoolExp>;
};

export type SubscriptionRootAddressEventsSummaryAggregateArgs = {
  distinct_on?: InputMaybe<Array<AddressEventsSummarySelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AddressEventsSummaryOrderBy>>;
  where?: InputMaybe<AddressEventsSummaryBoolExp>;
};

export type SubscriptionRootAddressEventsSummaryStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<AddressEventsSummaryStreamCursorInput>>;
  where?: InputMaybe<AddressEventsSummaryBoolExp>;
};

export type SubscriptionRootAddressVersionFromEventsArgs = {
  distinct_on?: InputMaybe<Array<AddressVersionFromEventsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AddressVersionFromEventsOrderBy>>;
  where?: InputMaybe<AddressVersionFromEventsBoolExp>;
};

export type SubscriptionRootAddressVersionFromEventsAggregateArgs = {
  distinct_on?: InputMaybe<Array<AddressVersionFromEventsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AddressVersionFromEventsOrderBy>>;
  where?: InputMaybe<AddressVersionFromEventsBoolExp>;
};

export type SubscriptionRootAddressVersionFromEventsStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<AddressVersionFromEventsStreamCursorInput>>;
  where?: InputMaybe<AddressVersionFromEventsBoolExp>;
};

export type SubscriptionRootAddressVersionFromMoveResourcesArgs = {
  distinct_on?: InputMaybe<Array<AddressVersionFromMoveResourcesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AddressVersionFromMoveResourcesOrderBy>>;
  where?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;
};

export type SubscriptionRootAddressVersionFromMoveResourcesAggregateArgs = {
  distinct_on?: InputMaybe<Array<AddressVersionFromMoveResourcesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AddressVersionFromMoveResourcesOrderBy>>;
  where?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;
};

export type SubscriptionRootAddressVersionFromMoveResourcesStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<AddressVersionFromMoveResourcesStreamCursorInput>>;
  where?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;
};

export type SubscriptionRootAnsLookupArgs = {
  distinct_on?: InputMaybe<Array<AnsLookupSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AnsLookupOrderBy>>;
  where?: InputMaybe<AnsLookupBoolExp>;
};

export type SubscriptionRootAnsLookupAggregateArgs = {
  distinct_on?: InputMaybe<Array<AnsLookupSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AnsLookupOrderBy>>;
  where?: InputMaybe<AnsLookupBoolExp>;
};

export type SubscriptionRootAnsLookupByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type SubscriptionRootAnsLookupStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<AnsLookupStreamCursorInput>>;
  where?: InputMaybe<AnsLookupBoolExp>;
};

export type SubscriptionRootAnsLookupV2Args = {
  distinct_on?: InputMaybe<Array<AnsLookupV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AnsLookupV2OrderBy>>;
  where?: InputMaybe<AnsLookupV2BoolExp>;
};

export type SubscriptionRootAnsLookupV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<AnsLookupV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AnsLookupV2OrderBy>>;
  where?: InputMaybe<AnsLookupV2BoolExp>;
};

export type SubscriptionRootAnsLookupV2ByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type SubscriptionRootAnsLookupV2StreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<AnsLookupV2StreamCursorInput>>;
  where?: InputMaybe<AnsLookupV2BoolExp>;
};

export type SubscriptionRootAnsPrimaryNameArgs = {
  distinct_on?: InputMaybe<Array<AnsPrimaryNameSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AnsPrimaryNameOrderBy>>;
  where?: InputMaybe<AnsPrimaryNameBoolExp>;
};

export type SubscriptionRootAnsPrimaryNameAggregateArgs = {
  distinct_on?: InputMaybe<Array<AnsPrimaryNameSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AnsPrimaryNameOrderBy>>;
  where?: InputMaybe<AnsPrimaryNameBoolExp>;
};

export type SubscriptionRootAnsPrimaryNameByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type SubscriptionRootAnsPrimaryNameStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<AnsPrimaryNameStreamCursorInput>>;
  where?: InputMaybe<AnsPrimaryNameBoolExp>;
};

export type SubscriptionRootAnsPrimaryNameV2Args = {
  distinct_on?: InputMaybe<Array<AnsPrimaryNameV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AnsPrimaryNameV2OrderBy>>;
  where?: InputMaybe<AnsPrimaryNameV2BoolExp>;
};

export type SubscriptionRootAnsPrimaryNameV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<AnsPrimaryNameV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AnsPrimaryNameV2OrderBy>>;
  where?: InputMaybe<AnsPrimaryNameV2BoolExp>;
};

export type SubscriptionRootAnsPrimaryNameV2ByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type SubscriptionRootAnsPrimaryNameV2StreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<AnsPrimaryNameV2StreamCursorInput>>;
  where?: InputMaybe<AnsPrimaryNameV2BoolExp>;
};

export type SubscriptionRootAuthKeyAccountAddressesArgs = {
  distinct_on?: InputMaybe<Array<AuthKeyAccountAddressesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AuthKeyAccountAddressesOrderBy>>;
  where?: InputMaybe<AuthKeyAccountAddressesBoolExp>;
};

export type SubscriptionRootAuthKeyAccountAddressesAggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthKeyAccountAddressesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<AuthKeyAccountAddressesOrderBy>>;
  where?: InputMaybe<AuthKeyAccountAddressesBoolExp>;
};

export type SubscriptionRootAuthKeyAccountAddressesByPkArgs = {
  account_address: Scalars["String"]["input"];
};

export type SubscriptionRootAuthKeyAccountAddressesStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<AuthKeyAccountAddressesStreamCursorInput>>;
  where?: InputMaybe<AuthKeyAccountAddressesBoolExp>;
};

export type SubscriptionRootBlockMetadataTransactionsArgs = {
  distinct_on?: InputMaybe<Array<BlockMetadataTransactionsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<BlockMetadataTransactionsOrderBy>>;
  where?: InputMaybe<BlockMetadataTransactionsBoolExp>;
};

export type SubscriptionRootBlockMetadataTransactionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<BlockMetadataTransactionsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<BlockMetadataTransactionsOrderBy>>;
  where?: InputMaybe<BlockMetadataTransactionsBoolExp>;
};

export type SubscriptionRootBlockMetadataTransactionsByPkArgs = {
  version: Scalars["bigint"]["input"];
};

export type SubscriptionRootBlockMetadataTransactionsStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<BlockMetadataTransactionsStreamCursorInput>>;
  where?: InputMaybe<BlockMetadataTransactionsBoolExp>;
};

export type SubscriptionRootCoinActivitiesArgs = {
  distinct_on?: InputMaybe<Array<CoinActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CoinActivitiesOrderBy>>;
  where?: InputMaybe<CoinActivitiesBoolExp>;
};

export type SubscriptionRootCoinActivitiesAggregateArgs = {
  distinct_on?: InputMaybe<Array<CoinActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CoinActivitiesOrderBy>>;
  where?: InputMaybe<CoinActivitiesBoolExp>;
};

export type SubscriptionRootCoinActivitiesByPkArgs = {
  event_account_address: Scalars["String"]["input"];
  event_creation_number: Scalars["bigint"]["input"];
  event_sequence_number: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type SubscriptionRootCoinActivitiesStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CoinActivitiesStreamCursorInput>>;
  where?: InputMaybe<CoinActivitiesBoolExp>;
};

export type SubscriptionRootCoinBalancesArgs = {
  distinct_on?: InputMaybe<Array<CoinBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CoinBalancesOrderBy>>;
  where?: InputMaybe<CoinBalancesBoolExp>;
};

export type SubscriptionRootCoinBalancesAggregateArgs = {
  distinct_on?: InputMaybe<Array<CoinBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CoinBalancesOrderBy>>;
  where?: InputMaybe<CoinBalancesBoolExp>;
};

export type SubscriptionRootCoinBalancesByPkArgs = {
  coin_type_hash: Scalars["String"]["input"];
  owner_address: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type SubscriptionRootCoinBalancesStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CoinBalancesStreamCursorInput>>;
  where?: InputMaybe<CoinBalancesBoolExp>;
};

export type SubscriptionRootCoinInfosArgs = {
  distinct_on?: InputMaybe<Array<CoinInfosSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CoinInfosOrderBy>>;
  where?: InputMaybe<CoinInfosBoolExp>;
};

export type SubscriptionRootCoinInfosAggregateArgs = {
  distinct_on?: InputMaybe<Array<CoinInfosSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CoinInfosOrderBy>>;
  where?: InputMaybe<CoinInfosBoolExp>;
};

export type SubscriptionRootCoinInfosByPkArgs = {
  coin_type_hash: Scalars["String"]["input"];
};

export type SubscriptionRootCoinInfosStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CoinInfosStreamCursorInput>>;
  where?: InputMaybe<CoinInfosBoolExp>;
};

export type SubscriptionRootCoinSupplyArgs = {
  distinct_on?: InputMaybe<Array<CoinSupplySelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CoinSupplyOrderBy>>;
  where?: InputMaybe<CoinSupplyBoolExp>;
};

export type SubscriptionRootCoinSupplyAggregateArgs = {
  distinct_on?: InputMaybe<Array<CoinSupplySelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CoinSupplyOrderBy>>;
  where?: InputMaybe<CoinSupplyBoolExp>;
};

export type SubscriptionRootCoinSupplyByPkArgs = {
  coin_type_hash: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type SubscriptionRootCoinSupplyStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CoinSupplyStreamCursorInput>>;
  where?: InputMaybe<CoinSupplyBoolExp>;
};

export type SubscriptionRootCollectionDatasArgs = {
  distinct_on?: InputMaybe<Array<CollectionDatasSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CollectionDatasOrderBy>>;
  where?: InputMaybe<CollectionDatasBoolExp>;
};

export type SubscriptionRootCollectionDatasAggregateArgs = {
  distinct_on?: InputMaybe<Array<CollectionDatasSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CollectionDatasOrderBy>>;
  where?: InputMaybe<CollectionDatasBoolExp>;
};

export type SubscriptionRootCollectionDatasByPkArgs = {
  collection_data_id_hash: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type SubscriptionRootCollectionDatasStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CollectionDatasStreamCursorInput>>;
  where?: InputMaybe<CollectionDatasBoolExp>;
};

export type SubscriptionRootCollectionsV2Args = {
  distinct_on?: InputMaybe<Array<CollectionsV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CollectionsV2OrderBy>>;
  where?: InputMaybe<CollectionsV2BoolExp>;
};

export type SubscriptionRootCollectionsV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<CollectionsV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CollectionsV2OrderBy>>;
  where?: InputMaybe<CollectionsV2BoolExp>;
};

export type SubscriptionRootCollectionsV2ByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type SubscriptionRootCollectionsV2StreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CollectionsV2StreamCursorInput>>;
  where?: InputMaybe<CollectionsV2BoolExp>;
};

export type SubscriptionRootCurrentAnsLookupArgs = {
  distinct_on?: InputMaybe<Array<CurrentAnsLookupSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentAnsLookupOrderBy>>;
  where?: InputMaybe<CurrentAnsLookupBoolExp>;
};

export type SubscriptionRootCurrentAnsLookupAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentAnsLookupSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentAnsLookupOrderBy>>;
  where?: InputMaybe<CurrentAnsLookupBoolExp>;
};

export type SubscriptionRootCurrentAnsLookupByPkArgs = {
  domain: Scalars["String"]["input"];
  subdomain: Scalars["String"]["input"];
};

export type SubscriptionRootCurrentAnsLookupStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentAnsLookupStreamCursorInput>>;
  where?: InputMaybe<CurrentAnsLookupBoolExp>;
};

export type SubscriptionRootCurrentAnsLookupV2Args = {
  distinct_on?: InputMaybe<Array<CurrentAnsLookupV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentAnsLookupV2OrderBy>>;
  where?: InputMaybe<CurrentAnsLookupV2BoolExp>;
};

export type SubscriptionRootCurrentAnsLookupV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentAnsLookupV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentAnsLookupV2OrderBy>>;
  where?: InputMaybe<CurrentAnsLookupV2BoolExp>;
};

export type SubscriptionRootCurrentAnsLookupV2ByPkArgs = {
  domain: Scalars["String"]["input"];
  subdomain: Scalars["String"]["input"];
  token_standard: Scalars["String"]["input"];
};

export type SubscriptionRootCurrentAnsLookupV2StreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentAnsLookupV2StreamCursorInput>>;
  where?: InputMaybe<CurrentAnsLookupV2BoolExp>;
};

export type SubscriptionRootCurrentAnsPrimaryNameArgs = {
  distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentAnsPrimaryNameOrderBy>>;
  where?: InputMaybe<CurrentAnsPrimaryNameBoolExp>;
};

export type SubscriptionRootCurrentAnsPrimaryNameAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentAnsPrimaryNameOrderBy>>;
  where?: InputMaybe<CurrentAnsPrimaryNameBoolExp>;
};

export type SubscriptionRootCurrentAnsPrimaryNameByPkArgs = {
  registered_address: Scalars["String"]["input"];
};

export type SubscriptionRootCurrentAnsPrimaryNameStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentAnsPrimaryNameStreamCursorInput>>;
  where?: InputMaybe<CurrentAnsPrimaryNameBoolExp>;
};

export type SubscriptionRootCurrentAnsPrimaryNameV2Args = {
  distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentAnsPrimaryNameV2OrderBy>>;
  where?: InputMaybe<CurrentAnsPrimaryNameV2BoolExp>;
};

export type SubscriptionRootCurrentAnsPrimaryNameV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentAnsPrimaryNameV2OrderBy>>;
  where?: InputMaybe<CurrentAnsPrimaryNameV2BoolExp>;
};

export type SubscriptionRootCurrentAnsPrimaryNameV2ByPkArgs = {
  registered_address: Scalars["String"]["input"];
  token_standard: Scalars["String"]["input"];
};

export type SubscriptionRootCurrentAnsPrimaryNameV2StreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentAnsPrimaryNameV2StreamCursorInput>>;
  where?: InputMaybe<CurrentAnsPrimaryNameV2BoolExp>;
};

export type SubscriptionRootCurrentCedraNamesArgs = {
  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
  where?: InputMaybe<CurrentCedraNamesBoolExp>;
};

export type SubscriptionRootCurrentCedraNamesAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
  where?: InputMaybe<CurrentCedraNamesBoolExp>;
};

export type SubscriptionRootCurrentCedraNamesStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentCedraNamesStreamCursorInput>>;
  where?: InputMaybe<CurrentCedraNamesBoolExp>;
};

export type SubscriptionRootCurrentCoinBalancesArgs = {
  distinct_on?: InputMaybe<Array<CurrentCoinBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCoinBalancesOrderBy>>;
  where?: InputMaybe<CurrentCoinBalancesBoolExp>;
};

export type SubscriptionRootCurrentCoinBalancesAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentCoinBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCoinBalancesOrderBy>>;
  where?: InputMaybe<CurrentCoinBalancesBoolExp>;
};

export type SubscriptionRootCurrentCoinBalancesByPkArgs = {
  coin_type_hash: Scalars["String"]["input"];
  owner_address: Scalars["String"]["input"];
};

export type SubscriptionRootCurrentCoinBalancesStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentCoinBalancesStreamCursorInput>>;
  where?: InputMaybe<CurrentCoinBalancesBoolExp>;
};

export type SubscriptionRootCurrentCollectionDatasArgs = {
  distinct_on?: InputMaybe<Array<CurrentCollectionDatasSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCollectionDatasOrderBy>>;
  where?: InputMaybe<CurrentCollectionDatasBoolExp>;
};

export type SubscriptionRootCurrentCollectionDatasAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentCollectionDatasSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCollectionDatasOrderBy>>;
  where?: InputMaybe<CurrentCollectionDatasBoolExp>;
};

export type SubscriptionRootCurrentCollectionDatasByPkArgs = {
  collection_data_id_hash: Scalars["String"]["input"];
};

export type SubscriptionRootCurrentCollectionDatasStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentCollectionDatasStreamCursorInput>>;
  where?: InputMaybe<CurrentCollectionDatasBoolExp>;
};

export type SubscriptionRootCurrentCollectionOwnershipV2ViewArgs = {
  distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewOrderBy>>;
  where?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;
};

export type SubscriptionRootCurrentCollectionOwnershipV2ViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewOrderBy>>;
  where?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;
};

export type SubscriptionRootCurrentCollectionOwnershipV2ViewStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentCollectionOwnershipV2ViewStreamCursorInput>>;
  where?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;
};

export type SubscriptionRootCurrentCollectionOwnershipViewArgs = {
  distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCollectionOwnershipViewOrderBy>>;
  where?: InputMaybe<CurrentCollectionOwnershipViewBoolExp>;
};

export type SubscriptionRootCurrentCollectionOwnershipViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCollectionOwnershipViewOrderBy>>;
  where?: InputMaybe<CurrentCollectionOwnershipViewBoolExp>;
};

export type SubscriptionRootCurrentCollectionOwnershipViewStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentCollectionOwnershipViewStreamCursorInput>>;
  where?: InputMaybe<CurrentCollectionOwnershipViewBoolExp>;
};

export type SubscriptionRootCurrentCollectionsV2Args = {
  distinct_on?: InputMaybe<Array<CurrentCollectionsV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCollectionsV2OrderBy>>;
  where?: InputMaybe<CurrentCollectionsV2BoolExp>;
};

export type SubscriptionRootCurrentCollectionsV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentCollectionsV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCollectionsV2OrderBy>>;
  where?: InputMaybe<CurrentCollectionsV2BoolExp>;
};

export type SubscriptionRootCurrentCollectionsV2ByPkArgs = {
  collection_id: Scalars["String"]["input"];
};

export type SubscriptionRootCurrentCollectionsV2StreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentCollectionsV2StreamCursorInput>>;
  where?: InputMaybe<CurrentCollectionsV2BoolExp>;
};

export type SubscriptionRootCurrentDelegatedStakingPoolBalancesArgs = {
  distinct_on?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesOrderBy>>;
  where?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;
};

export type SubscriptionRootCurrentDelegatedStakingPoolBalancesAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesOrderBy>>;
  where?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;
};

export type SubscriptionRootCurrentDelegatedStakingPoolBalancesByPkArgs = {
  staking_pool_address: Scalars["String"]["input"];
};

export type SubscriptionRootCurrentDelegatedStakingPoolBalancesStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentDelegatedStakingPoolBalancesStreamCursorInput>>;
  where?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;
};

export type SubscriptionRootCurrentDelegatedVoterArgs = {
  distinct_on?: InputMaybe<Array<CurrentDelegatedVoterSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentDelegatedVoterOrderBy>>;
  where?: InputMaybe<CurrentDelegatedVoterBoolExp>;
};

export type SubscriptionRootCurrentDelegatedVoterAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentDelegatedVoterSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentDelegatedVoterOrderBy>>;
  where?: InputMaybe<CurrentDelegatedVoterBoolExp>;
};

export type SubscriptionRootCurrentDelegatedVoterByPkArgs = {
  delegation_pool_address: Scalars["String"]["input"];
  delegator_address: Scalars["String"]["input"];
};

export type SubscriptionRootCurrentDelegatedVoterStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentDelegatedVoterStreamCursorInput>>;
  where?: InputMaybe<CurrentDelegatedVoterBoolExp>;
};

export type SubscriptionRootCurrentDelegatorBalancesArgs = {
  distinct_on?: InputMaybe<Array<CurrentDelegatorBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentDelegatorBalancesOrderBy>>;
  where?: InputMaybe<CurrentDelegatorBalancesBoolExp>;
};

export type SubscriptionRootCurrentDelegatorBalancesAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentDelegatorBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentDelegatorBalancesOrderBy>>;
  where?: InputMaybe<CurrentDelegatorBalancesBoolExp>;
};

export type SubscriptionRootCurrentDelegatorBalancesByPkArgs = {
  delegator_address: Scalars["String"]["input"];
  pool_address: Scalars["String"]["input"];
  pool_type: Scalars["String"]["input"];
  table_handle: Scalars["String"]["input"];
};

export type SubscriptionRootCurrentDelegatorBalancesStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentDelegatorBalancesStreamCursorInput>>;
  where?: InputMaybe<CurrentDelegatorBalancesBoolExp>;
};

export type SubscriptionRootCurrentFungibleAssetBalancesArgs = {
  distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesOrderBy>>;
  where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;
};

export type SubscriptionRootCurrentFungibleAssetBalancesAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesOrderBy>>;
  where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;
};

export type SubscriptionRootCurrentFungibleAssetBalancesByPkArgs = {
  storage_id: Scalars["String"]["input"];
};

export type SubscriptionRootCurrentFungibleAssetBalancesNewArgs = {
  distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesNewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesNewOrderBy>>;
  where?: InputMaybe<CurrentFungibleAssetBalancesNewBoolExp>;
};

export type SubscriptionRootCurrentFungibleAssetBalancesNewAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesNewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesNewOrderBy>>;
  where?: InputMaybe<CurrentFungibleAssetBalancesNewBoolExp>;
};

export type SubscriptionRootCurrentFungibleAssetBalancesNewByPkArgs = {
  storage_id: Scalars["String"]["input"];
};

export type SubscriptionRootCurrentFungibleAssetBalancesNewStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentFungibleAssetBalancesNewStreamCursorInput>>;
  where?: InputMaybe<CurrentFungibleAssetBalancesNewBoolExp>;
};

export type SubscriptionRootCurrentFungibleAssetBalancesStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentFungibleAssetBalancesStreamCursorInput>>;
  where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;
};

export type SubscriptionRootCurrentObjectsArgs = {
  distinct_on?: InputMaybe<Array<CurrentObjectsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentObjectsOrderBy>>;
  where?: InputMaybe<CurrentObjectsBoolExp>;
};

export type SubscriptionRootCurrentObjectsAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentObjectsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentObjectsOrderBy>>;
  where?: InputMaybe<CurrentObjectsBoolExp>;
};

export type SubscriptionRootCurrentObjectsByPkArgs = {
  object_address: Scalars["String"]["input"];
};

export type SubscriptionRootCurrentObjectsStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentObjectsStreamCursorInput>>;
  where?: InputMaybe<CurrentObjectsBoolExp>;
};

export type SubscriptionRootCurrentStakingPoolVoterArgs = {
  distinct_on?: InputMaybe<Array<CurrentStakingPoolVoterSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentStakingPoolVoterOrderBy>>;
  where?: InputMaybe<CurrentStakingPoolVoterBoolExp>;
};

export type SubscriptionRootCurrentStakingPoolVoterAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentStakingPoolVoterSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentStakingPoolVoterOrderBy>>;
  where?: InputMaybe<CurrentStakingPoolVoterBoolExp>;
};

export type SubscriptionRootCurrentStakingPoolVoterByPkArgs = {
  staking_pool_address: Scalars["String"]["input"];
};

export type SubscriptionRootCurrentStakingPoolVoterStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentStakingPoolVoterStreamCursorInput>>;
  where?: InputMaybe<CurrentStakingPoolVoterBoolExp>;
};

export type SubscriptionRootCurrentTableItemsArgs = {
  distinct_on?: InputMaybe<Array<CurrentTableItemsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTableItemsOrderBy>>;
  where?: InputMaybe<CurrentTableItemsBoolExp>;
};

export type SubscriptionRootCurrentTableItemsAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentTableItemsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTableItemsOrderBy>>;
  where?: InputMaybe<CurrentTableItemsBoolExp>;
};

export type SubscriptionRootCurrentTableItemsByPkArgs = {
  key_hash: Scalars["String"]["input"];
  table_handle: Scalars["String"]["input"];
};

export type SubscriptionRootCurrentTableItemsStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentTableItemsStreamCursorInput>>;
  where?: InputMaybe<CurrentTableItemsBoolExp>;
};

export type SubscriptionRootCurrentTableItemsViewArgs = {
  distinct_on?: InputMaybe<Array<CurrentTableItemsViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTableItemsViewOrderBy>>;
  where?: InputMaybe<CurrentTableItemsViewBoolExp>;
};

export type SubscriptionRootCurrentTableItemsViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentTableItemsViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTableItemsViewOrderBy>>;
  where?: InputMaybe<CurrentTableItemsViewBoolExp>;
};

export type SubscriptionRootCurrentTableItemsViewStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentTableItemsViewStreamCursorInput>>;
  where?: InputMaybe<CurrentTableItemsViewBoolExp>;
};

export type SubscriptionRootCurrentTokenDatasArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenDatasSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenDatasOrderBy>>;
  where?: InputMaybe<CurrentTokenDatasBoolExp>;
};

export type SubscriptionRootCurrentTokenDatasAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenDatasSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenDatasOrderBy>>;
  where?: InputMaybe<CurrentTokenDatasBoolExp>;
};

export type SubscriptionRootCurrentTokenDatasByPkArgs = {
  token_data_id_hash: Scalars["String"]["input"];
};

export type SubscriptionRootCurrentTokenDatasStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentTokenDatasStreamCursorInput>>;
  where?: InputMaybe<CurrentTokenDatasBoolExp>;
};

export type SubscriptionRootCurrentTokenDatasV2Args = {
  distinct_on?: InputMaybe<Array<CurrentTokenDatasV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenDatasV2OrderBy>>;
  where?: InputMaybe<CurrentTokenDatasV2BoolExp>;
};

export type SubscriptionRootCurrentTokenDatasV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenDatasV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenDatasV2OrderBy>>;
  where?: InputMaybe<CurrentTokenDatasV2BoolExp>;
};

export type SubscriptionRootCurrentTokenDatasV2ByPkArgs = {
  token_data_id: Scalars["String"]["input"];
};

export type SubscriptionRootCurrentTokenDatasV2StreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentTokenDatasV2StreamCursorInput>>;
  where?: InputMaybe<CurrentTokenDatasV2BoolExp>;
};

export type SubscriptionRootCurrentTokenOwnershipsArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenOwnershipsOrderBy>>;
  where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;
};

export type SubscriptionRootCurrentTokenOwnershipsAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenOwnershipsOrderBy>>;
  where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;
};

export type SubscriptionRootCurrentTokenOwnershipsByPkArgs = {
  owner_address: Scalars["String"]["input"];
  property_version: Scalars["numeric"]["input"];
  token_data_id_hash: Scalars["String"]["input"];
};

export type SubscriptionRootCurrentTokenOwnershipsStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentTokenOwnershipsStreamCursorInput>>;
  where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;
};

export type SubscriptionRootCurrentTokenOwnershipsV2Args = {
  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;
  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
};

export type SubscriptionRootCurrentTokenOwnershipsV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;
  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
};

export type SubscriptionRootCurrentTokenOwnershipsV2ByPkArgs = {
  owner_address: Scalars["String"]["input"];
  property_version_v1: Scalars["numeric"]["input"];
  storage_id: Scalars["String"]["input"];
  token_data_id: Scalars["String"]["input"];
};

export type SubscriptionRootCurrentTokenOwnershipsV2StreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentTokenOwnershipsV2StreamCursorInput>>;
  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
};

export type SubscriptionRootCurrentTokenPendingClaimsArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenPendingClaimsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenPendingClaimsOrderBy>>;
  where?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;
};

export type SubscriptionRootCurrentTokenPendingClaimsAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenPendingClaimsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenPendingClaimsOrderBy>>;
  where?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;
};

export type SubscriptionRootCurrentTokenPendingClaimsByPkArgs = {
  from_address: Scalars["String"]["input"];
  property_version: Scalars["numeric"]["input"];
  to_address: Scalars["String"]["input"];
  token_data_id_hash: Scalars["String"]["input"];
};

export type SubscriptionRootCurrentTokenPendingClaimsStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentTokenPendingClaimsStreamCursorInput>>;
  where?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;
};

export type SubscriptionRootCurrentTokenRoyaltyV1Args = {
  distinct_on?: InputMaybe<Array<CurrentTokenRoyaltyV1SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenRoyaltyV1OrderBy>>;
  where?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;
};

export type SubscriptionRootCurrentTokenRoyaltyV1AggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenRoyaltyV1SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenRoyaltyV1OrderBy>>;
  where?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;
};

export type SubscriptionRootCurrentTokenRoyaltyV1ByPkArgs = {
  token_data_id: Scalars["String"]["input"];
};

export type SubscriptionRootCurrentTokenRoyaltyV1StreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentTokenRoyaltyV1StreamCursorInput>>;
  where?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;
};

export type SubscriptionRootCurrentTokenV2MetadataArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenV2MetadataSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenV2MetadataOrderBy>>;
  where?: InputMaybe<CurrentTokenV2MetadataBoolExp>;
};

export type SubscriptionRootCurrentTokenV2MetadataAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentTokenV2MetadataSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentTokenV2MetadataOrderBy>>;
  where?: InputMaybe<CurrentTokenV2MetadataBoolExp>;
};

export type SubscriptionRootCurrentTokenV2MetadataByPkArgs = {
  object_address: Scalars["String"]["input"];
  resource_type: Scalars["String"]["input"];
};

export type SubscriptionRootCurrentTokenV2MetadataStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<CurrentTokenV2MetadataStreamCursorInput>>;
  where?: InputMaybe<CurrentTokenV2MetadataBoolExp>;
};

export type SubscriptionRootDelegatedStakingActivitiesArgs = {
  distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;
  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
};

export type SubscriptionRootDelegatedStakingActivitiesAggregateArgs = {
  distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;
  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
};

export type SubscriptionRootDelegatedStakingActivitiesByPkArgs = {
  event_index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type SubscriptionRootDelegatedStakingActivitiesStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<DelegatedStakingActivitiesStreamCursorInput>>;
  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
};

export type SubscriptionRootDelegatedStakingPoolBalancesArgs = {
  distinct_on?: InputMaybe<Array<DelegatedStakingPoolBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatedStakingPoolBalancesOrderBy>>;
  where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;
};

export type SubscriptionRootDelegatedStakingPoolBalancesAggregateArgs = {
  distinct_on?: InputMaybe<Array<DelegatedStakingPoolBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatedStakingPoolBalancesOrderBy>>;
  where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;
};

export type SubscriptionRootDelegatedStakingPoolBalancesByPkArgs = {
  staking_pool_address: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type SubscriptionRootDelegatedStakingPoolBalancesStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<DelegatedStakingPoolBalancesStreamCursorInput>>;
  where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;
};

export type SubscriptionRootDelegatedStakingPoolsArgs = {
  distinct_on?: InputMaybe<Array<DelegatedStakingPoolsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatedStakingPoolsOrderBy>>;
  where?: InputMaybe<DelegatedStakingPoolsBoolExp>;
};

export type SubscriptionRootDelegatedStakingPoolsAggregateArgs = {
  distinct_on?: InputMaybe<Array<DelegatedStakingPoolsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatedStakingPoolsOrderBy>>;
  where?: InputMaybe<DelegatedStakingPoolsBoolExp>;
};

export type SubscriptionRootDelegatedStakingPoolsByPkArgs = {
  staking_pool_address: Scalars["String"]["input"];
};

export type SubscriptionRootDelegatedStakingPoolsStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<DelegatedStakingPoolsStreamCursorInput>>;
  where?: InputMaybe<DelegatedStakingPoolsBoolExp>;
};

export type SubscriptionRootDelegatorBalancesArgs = {
  distinct_on?: InputMaybe<Array<DelegatorBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatorBalancesOrderBy>>;
  where?: InputMaybe<DelegatorBalancesBoolExp>;
};

export type SubscriptionRootDelegatorBalancesAggregateArgs = {
  distinct_on?: InputMaybe<Array<DelegatorBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatorBalancesOrderBy>>;
  where?: InputMaybe<DelegatorBalancesBoolExp>;
};

export type SubscriptionRootDelegatorBalancesByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type SubscriptionRootDelegatorBalancesStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<DelegatorBalancesStreamCursorInput>>;
  where?: InputMaybe<DelegatorBalancesBoolExp>;
};

export type SubscriptionRootDelegatorDistinctPoolArgs = {
  distinct_on?: InputMaybe<Array<DelegatorDistinctPoolSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatorDistinctPoolOrderBy>>;
  where?: InputMaybe<DelegatorDistinctPoolBoolExp>;
};

export type SubscriptionRootDelegatorDistinctPoolAggregateArgs = {
  distinct_on?: InputMaybe<Array<DelegatorDistinctPoolSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<DelegatorDistinctPoolOrderBy>>;
  where?: InputMaybe<DelegatorDistinctPoolBoolExp>;
};

export type SubscriptionRootDelegatorDistinctPoolStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<DelegatorDistinctPoolStreamCursorInput>>;
  where?: InputMaybe<DelegatorDistinctPoolBoolExp>;
};

export type SubscriptionRootEventSizeInfoArgs = {
  distinct_on?: InputMaybe<Array<EventSizeInfoSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<EventSizeInfoOrderBy>>;
  where?: InputMaybe<EventSizeInfoBoolExp>;
};

export type SubscriptionRootEventSizeInfoAggregateArgs = {
  distinct_on?: InputMaybe<Array<EventSizeInfoSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<EventSizeInfoOrderBy>>;
  where?: InputMaybe<EventSizeInfoBoolExp>;
};

export type SubscriptionRootEventSizeInfoByPkArgs = {
  index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type SubscriptionRootEventSizeInfoStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<EventSizeInfoStreamCursorInput>>;
  where?: InputMaybe<EventSizeInfoBoolExp>;
};

export type SubscriptionRootEventsArgs = {
  distinct_on?: InputMaybe<Array<EventsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<EventsOrderBy>>;
  where?: InputMaybe<EventsBoolExp>;
};

export type SubscriptionRootEventsAggregateArgs = {
  distinct_on?: InputMaybe<Array<EventsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<EventsOrderBy>>;
  where?: InputMaybe<EventsBoolExp>;
};

export type SubscriptionRootEventsByPkArgs = {
  event_index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type SubscriptionRootEventsStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<EventsStreamCursorInput>>;
  where?: InputMaybe<EventsBoolExp>;
};

export type SubscriptionRootEventsViewArgs = {
  distinct_on?: InputMaybe<Array<EventsViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<EventsViewOrderBy>>;
  where?: InputMaybe<EventsViewBoolExp>;
};

export type SubscriptionRootEventsViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<EventsViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<EventsViewOrderBy>>;
  where?: InputMaybe<EventsViewBoolExp>;
};

export type SubscriptionRootEventsViewStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<EventsViewStreamCursorInput>>;
  where?: InputMaybe<EventsViewBoolExp>;
};

export type SubscriptionRootFungibleAssetActivitiesArgs = {
  distinct_on?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<FungibleAssetActivitiesOrderBy>>;
  where?: InputMaybe<FungibleAssetActivitiesBoolExp>;
};

export type SubscriptionRootFungibleAssetActivitiesAggregateArgs = {
  distinct_on?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<FungibleAssetActivitiesOrderBy>>;
  where?: InputMaybe<FungibleAssetActivitiesBoolExp>;
};

export type SubscriptionRootFungibleAssetActivitiesByPkArgs = {
  event_index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type SubscriptionRootFungibleAssetActivitiesStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<FungibleAssetActivitiesStreamCursorInput>>;
  where?: InputMaybe<FungibleAssetActivitiesBoolExp>;
};

export type SubscriptionRootFungibleAssetBalancesArgs = {
  distinct_on?: InputMaybe<Array<FungibleAssetBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<FungibleAssetBalancesOrderBy>>;
  where?: InputMaybe<FungibleAssetBalancesBoolExp>;
};

export type SubscriptionRootFungibleAssetBalancesAggregateArgs = {
  distinct_on?: InputMaybe<Array<FungibleAssetBalancesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<FungibleAssetBalancesOrderBy>>;
  where?: InputMaybe<FungibleAssetBalancesBoolExp>;
};

export type SubscriptionRootFungibleAssetBalancesByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type SubscriptionRootFungibleAssetBalancesStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<FungibleAssetBalancesStreamCursorInput>>;
  where?: InputMaybe<FungibleAssetBalancesBoolExp>;
};

export type SubscriptionRootFungibleAssetMetadataArgs = {
  distinct_on?: InputMaybe<Array<FungibleAssetMetadataSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<FungibleAssetMetadataOrderBy>>;
  where?: InputMaybe<FungibleAssetMetadataBoolExp>;
};

export type SubscriptionRootFungibleAssetMetadataAggregateArgs = {
  distinct_on?: InputMaybe<Array<FungibleAssetMetadataSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<FungibleAssetMetadataOrderBy>>;
  where?: InputMaybe<FungibleAssetMetadataBoolExp>;
};

export type SubscriptionRootFungibleAssetMetadataByPkArgs = {
  asset_type: Scalars["String"]["input"];
};

export type SubscriptionRootFungibleAssetMetadataStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<FungibleAssetMetadataStreamCursorInput>>;
  where?: InputMaybe<FungibleAssetMetadataBoolExp>;
};

export type SubscriptionRootFungibleAssetToCoinMappingsArgs = {
  distinct_on?: InputMaybe<Array<FungibleAssetToCoinMappingsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<FungibleAssetToCoinMappingsOrderBy>>;
  where?: InputMaybe<FungibleAssetToCoinMappingsBoolExp>;
};

export type SubscriptionRootFungibleAssetToCoinMappingsAggregateArgs = {
  distinct_on?: InputMaybe<Array<FungibleAssetToCoinMappingsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<FungibleAssetToCoinMappingsOrderBy>>;
  where?: InputMaybe<FungibleAssetToCoinMappingsBoolExp>;
};

export type SubscriptionRootFungibleAssetToCoinMappingsByPkArgs = {
  fungible_asset_metadata_address: Scalars["String"]["input"];
};

export type SubscriptionRootFungibleAssetToCoinMappingsStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<FungibleAssetToCoinMappingsStreamCursorInput>>;
  where?: InputMaybe<FungibleAssetToCoinMappingsBoolExp>;
};

export type SubscriptionRootGasFeesArgs = {
  distinct_on?: InputMaybe<Array<GasFeesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<GasFeesOrderBy>>;
  where?: InputMaybe<GasFeesBoolExp>;
};

export type SubscriptionRootGasFeesAggregateArgs = {
  distinct_on?: InputMaybe<Array<GasFeesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<GasFeesOrderBy>>;
  where?: InputMaybe<GasFeesBoolExp>;
};

export type SubscriptionRootGasFeesByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
};

export type SubscriptionRootGasFeesStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<GasFeesStreamCursorInput>>;
  where?: InputMaybe<GasFeesBoolExp>;
};

export type SubscriptionRootIndexerStatusArgs = {
  distinct_on?: InputMaybe<Array<IndexerStatusSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<IndexerStatusOrderBy>>;
  where?: InputMaybe<IndexerStatusBoolExp>;
};

export type SubscriptionRootIndexerStatusAggregateArgs = {
  distinct_on?: InputMaybe<Array<IndexerStatusSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<IndexerStatusOrderBy>>;
  where?: InputMaybe<IndexerStatusBoolExp>;
};

export type SubscriptionRootIndexerStatusByPkArgs = {
  db: Scalars["String"]["input"];
};

export type SubscriptionRootIndexerStatusStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<IndexerStatusStreamCursorInput>>;
  where?: InputMaybe<IndexerStatusBoolExp>;
};

export type SubscriptionRootMoveModulesArgs = {
  distinct_on?: InputMaybe<Array<MoveModulesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<MoveModulesOrderBy>>;
  where?: InputMaybe<MoveModulesBoolExp>;
};

export type SubscriptionRootMoveModulesAggregateArgs = {
  distinct_on?: InputMaybe<Array<MoveModulesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<MoveModulesOrderBy>>;
  where?: InputMaybe<MoveModulesBoolExp>;
};

export type SubscriptionRootMoveModulesByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type SubscriptionRootMoveModulesStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<MoveModulesStreamCursorInput>>;
  where?: InputMaybe<MoveModulesBoolExp>;
};

export type SubscriptionRootMoveResourcesArgs = {
  distinct_on?: InputMaybe<Array<MoveResourcesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<MoveResourcesOrderBy>>;
  where?: InputMaybe<MoveResourcesBoolExp>;
};

export type SubscriptionRootMoveResourcesAggregateArgs = {
  distinct_on?: InputMaybe<Array<MoveResourcesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<MoveResourcesOrderBy>>;
  where?: InputMaybe<MoveResourcesBoolExp>;
};

export type SubscriptionRootMoveResourcesByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type SubscriptionRootMoveResourcesStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<MoveResourcesStreamCursorInput>>;
  where?: InputMaybe<MoveResourcesBoolExp>;
};

export type SubscriptionRootMoveResourcesViewArgs = {
  distinct_on?: InputMaybe<Array<MoveResourcesViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<MoveResourcesViewOrderBy>>;
  where?: InputMaybe<MoveResourcesViewBoolExp>;
};

export type SubscriptionRootMoveResourcesViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<MoveResourcesViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<MoveResourcesViewOrderBy>>;
  where?: InputMaybe<MoveResourcesViewBoolExp>;
};

export type SubscriptionRootMoveResourcesViewStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<MoveResourcesViewStreamCursorInput>>;
  where?: InputMaybe<MoveResourcesViewBoolExp>;
};

export type SubscriptionRootNftMetadataCrawlerParsedAssetUrisArgs = {
  distinct_on?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisOrderBy>>;
  where?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;
};

export type SubscriptionRootNftMetadataCrawlerParsedAssetUrisAggregateArgs = {
  distinct_on?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisOrderBy>>;
  where?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;
};

export type SubscriptionRootNftMetadataCrawlerParsedAssetUrisByPkArgs = {
  asset_uri: Scalars["String"]["input"];
};

export type SubscriptionRootNftMetadataCrawlerParsedAssetUrisStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<NftMetadataCrawlerParsedAssetUrisStreamCursorInput>>;
  where?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;
};

export type SubscriptionRootNftPointsArgs = {
  distinct_on?: InputMaybe<Array<NftPointsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<NftPointsOrderBy>>;
  where?: InputMaybe<NftPointsBoolExp>;
};

export type SubscriptionRootNftPointsAggregateArgs = {
  distinct_on?: InputMaybe<Array<NftPointsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<NftPointsOrderBy>>;
  where?: InputMaybe<NftPointsBoolExp>;
};

export type SubscriptionRootNftPointsByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
};

export type SubscriptionRootNftPointsStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<NftPointsStreamCursorInput>>;
  where?: InputMaybe<NftPointsBoolExp>;
};

export type SubscriptionRootNumActiveDelegatorPerPoolArgs = {
  distinct_on?: InputMaybe<Array<NumActiveDelegatorPerPoolSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<NumActiveDelegatorPerPoolOrderBy>>;
  where?: InputMaybe<NumActiveDelegatorPerPoolBoolExp>;
};

export type SubscriptionRootNumActiveDelegatorPerPoolAggregateArgs = {
  distinct_on?: InputMaybe<Array<NumActiveDelegatorPerPoolSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<NumActiveDelegatorPerPoolOrderBy>>;
  where?: InputMaybe<NumActiveDelegatorPerPoolBoolExp>;
};

export type SubscriptionRootNumActiveDelegatorPerPoolStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<NumActiveDelegatorPerPoolStreamCursorInput>>;
  where?: InputMaybe<NumActiveDelegatorPerPoolBoolExp>;
};

export type SubscriptionRootObjectsArgs = {
  distinct_on?: InputMaybe<Array<ObjectsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<ObjectsOrderBy>>;
  where?: InputMaybe<ObjectsBoolExp>;
};

export type SubscriptionRootObjectsAggregateArgs = {
  distinct_on?: InputMaybe<Array<ObjectsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<ObjectsOrderBy>>;
  where?: InputMaybe<ObjectsBoolExp>;
};

export type SubscriptionRootObjectsByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type SubscriptionRootObjectsStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<ObjectsStreamCursorInput>>;
  where?: InputMaybe<ObjectsBoolExp>;
};

export type SubscriptionRootProcessorMetadataProcessorStatusArgs = {
  distinct_on?: InputMaybe<Array<ProcessorMetadataProcessorStatusSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<ProcessorMetadataProcessorStatusOrderBy>>;
  where?: InputMaybe<ProcessorMetadataProcessorStatusBoolExp>;
};

export type SubscriptionRootProcessorMetadataProcessorStatusAggregateArgs = {
  distinct_on?: InputMaybe<Array<ProcessorMetadataProcessorStatusSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<ProcessorMetadataProcessorStatusOrderBy>>;
  where?: InputMaybe<ProcessorMetadataProcessorStatusBoolExp>;
};

export type SubscriptionRootProcessorMetadataProcessorStatusByPkArgs = {
  processor: Scalars["String"]["input"];
};

export type SubscriptionRootProcessorMetadataProcessorStatusStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<ProcessorMetadataProcessorStatusStreamCursorInput>>;
  where?: InputMaybe<ProcessorMetadataProcessorStatusBoolExp>;
};

export type SubscriptionRootProcessorStatusArgs = {
  distinct_on?: InputMaybe<Array<ProcessorStatusSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<ProcessorStatusOrderBy>>;
  where?: InputMaybe<ProcessorStatusBoolExp>;
};

export type SubscriptionRootProcessorStatusAggregateArgs = {
  distinct_on?: InputMaybe<Array<ProcessorStatusSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<ProcessorStatusOrderBy>>;
  where?: InputMaybe<ProcessorStatusBoolExp>;
};

export type SubscriptionRootProcessorStatusByPkArgs = {
  processor: Scalars["String"]["input"];
};

export type SubscriptionRootProcessorStatusStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<ProcessorStatusStreamCursorInput>>;
  where?: InputMaybe<ProcessorStatusBoolExp>;
};

export type SubscriptionRootProposalVotesArgs = {
  distinct_on?: InputMaybe<Array<ProposalVotesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<ProposalVotesOrderBy>>;
  where?: InputMaybe<ProposalVotesBoolExp>;
};

export type SubscriptionRootProposalVotesAggregateArgs = {
  distinct_on?: InputMaybe<Array<ProposalVotesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<ProposalVotesOrderBy>>;
  where?: InputMaybe<ProposalVotesBoolExp>;
};

export type SubscriptionRootProposalVotesByPkArgs = {
  proposal_id: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
  voter_address: Scalars["String"]["input"];
};

export type SubscriptionRootProposalVotesStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<ProposalVotesStreamCursorInput>>;
  where?: InputMaybe<ProposalVotesBoolExp>;
};

export type SubscriptionRootPublicKeyAuthKeysArgs = {
  distinct_on?: InputMaybe<Array<PublicKeyAuthKeysSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<PublicKeyAuthKeysOrderBy>>;
  where?: InputMaybe<PublicKeyAuthKeysBoolExp>;
};

export type SubscriptionRootPublicKeyAuthKeysAggregateArgs = {
  distinct_on?: InputMaybe<Array<PublicKeyAuthKeysSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<PublicKeyAuthKeysOrderBy>>;
  where?: InputMaybe<PublicKeyAuthKeysBoolExp>;
};

export type SubscriptionRootPublicKeyAuthKeysByPkArgs = {
  auth_key: Scalars["String"]["input"];
  public_key: Scalars["String"]["input"];
  public_key_type: Scalars["String"]["input"];
};

export type SubscriptionRootPublicKeyAuthKeysStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<PublicKeyAuthKeysStreamCursorInput>>;
  where?: InputMaybe<PublicKeyAuthKeysBoolExp>;
};

export type SubscriptionRootSignaturesArgs = {
  distinct_on?: InputMaybe<Array<SignaturesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<SignaturesOrderBy>>;
  where?: InputMaybe<SignaturesBoolExp>;
};

export type SubscriptionRootSignaturesAggregateArgs = {
  distinct_on?: InputMaybe<Array<SignaturesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<SignaturesOrderBy>>;
  where?: InputMaybe<SignaturesBoolExp>;
};

export type SubscriptionRootSignaturesByPkArgs = {
  is_sender_primary: Scalars["Boolean"]["input"];
  multi_agent_index: Scalars["bigint"]["input"];
  multi_sig_index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type SubscriptionRootSignaturesStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<SignaturesStreamCursorInput>>;
  where?: InputMaybe<SignaturesBoolExp>;
};

export type SubscriptionRootSpamAssetsArgs = {
  distinct_on?: InputMaybe<Array<SpamAssetsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<SpamAssetsOrderBy>>;
  where?: InputMaybe<SpamAssetsBoolExp>;
};

export type SubscriptionRootSpamAssetsAggregateArgs = {
  distinct_on?: InputMaybe<Array<SpamAssetsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<SpamAssetsOrderBy>>;
  where?: InputMaybe<SpamAssetsBoolExp>;
};

export type SubscriptionRootSpamAssetsByPkArgs = {
  asset: Scalars["String"]["input"];
};

export type SubscriptionRootSpamAssetsStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<SpamAssetsStreamCursorInput>>;
  where?: InputMaybe<SpamAssetsBoolExp>;
};

export type SubscriptionRootTableItemsArgs = {
  distinct_on?: InputMaybe<Array<TableItemsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TableItemsOrderBy>>;
  where?: InputMaybe<TableItemsBoolExp>;
};

export type SubscriptionRootTableItemsAggregateArgs = {
  distinct_on?: InputMaybe<Array<TableItemsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TableItemsOrderBy>>;
  where?: InputMaybe<TableItemsBoolExp>;
};

export type SubscriptionRootTableItemsByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type SubscriptionRootTableItemsStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<TableItemsStreamCursorInput>>;
  where?: InputMaybe<TableItemsBoolExp>;
};

export type SubscriptionRootTableItemsViewArgs = {
  distinct_on?: InputMaybe<Array<TableItemsViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TableItemsViewOrderBy>>;
  where?: InputMaybe<TableItemsViewBoolExp>;
};

export type SubscriptionRootTableItemsViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<TableItemsViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TableItemsViewOrderBy>>;
  where?: InputMaybe<TableItemsViewBoolExp>;
};

export type SubscriptionRootTableItemsViewStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<TableItemsViewStreamCursorInput>>;
  where?: InputMaybe<TableItemsViewBoolExp>;
};

export type SubscriptionRootTableMetadatasArgs = {
  distinct_on?: InputMaybe<Array<TableMetadatasSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TableMetadatasOrderBy>>;
  where?: InputMaybe<TableMetadatasBoolExp>;
};

export type SubscriptionRootTableMetadatasAggregateArgs = {
  distinct_on?: InputMaybe<Array<TableMetadatasSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TableMetadatasOrderBy>>;
  where?: InputMaybe<TableMetadatasBoolExp>;
};

export type SubscriptionRootTableMetadatasByPkArgs = {
  handle: Scalars["String"]["input"];
};

export type SubscriptionRootTableMetadatasStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<TableMetadatasStreamCursorInput>>;
  where?: InputMaybe<TableMetadatasBoolExp>;
};

export type SubscriptionRootTokenActivitiesArgs = {
  distinct_on?: InputMaybe<Array<TokenActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenActivitiesOrderBy>>;
  where?: InputMaybe<TokenActivitiesBoolExp>;
};

export type SubscriptionRootTokenActivitiesAggregateArgs = {
  distinct_on?: InputMaybe<Array<TokenActivitiesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenActivitiesOrderBy>>;
  where?: InputMaybe<TokenActivitiesBoolExp>;
};

export type SubscriptionRootTokenActivitiesByPkArgs = {
  event_account_address: Scalars["String"]["input"];
  event_creation_number: Scalars["bigint"]["input"];
  event_sequence_number: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type SubscriptionRootTokenActivitiesStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<TokenActivitiesStreamCursorInput>>;
  where?: InputMaybe<TokenActivitiesBoolExp>;
};

export type SubscriptionRootTokenActivitiesV2Args = {
  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;
  where?: InputMaybe<TokenActivitiesV2BoolExp>;
};

export type SubscriptionRootTokenActivitiesV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;
  where?: InputMaybe<TokenActivitiesV2BoolExp>;
};

export type SubscriptionRootTokenActivitiesV2ByPkArgs = {
  event_index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type SubscriptionRootTokenActivitiesV2StreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<TokenActivitiesV2StreamCursorInput>>;
  where?: InputMaybe<TokenActivitiesV2BoolExp>;
};

export type SubscriptionRootTokenDatasArgs = {
  distinct_on?: InputMaybe<Array<TokenDatasSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenDatasOrderBy>>;
  where?: InputMaybe<TokenDatasBoolExp>;
};

export type SubscriptionRootTokenDatasAggregateArgs = {
  distinct_on?: InputMaybe<Array<TokenDatasSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenDatasOrderBy>>;
  where?: InputMaybe<TokenDatasBoolExp>;
};

export type SubscriptionRootTokenDatasByPkArgs = {
  token_data_id_hash: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type SubscriptionRootTokenDatasStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<TokenDatasStreamCursorInput>>;
  where?: InputMaybe<TokenDatasBoolExp>;
};

export type SubscriptionRootTokenDatasV2Args = {
  distinct_on?: InputMaybe<Array<TokenDatasV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenDatasV2OrderBy>>;
  where?: InputMaybe<TokenDatasV2BoolExp>;
};

export type SubscriptionRootTokenDatasV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<TokenDatasV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenDatasV2OrderBy>>;
  where?: InputMaybe<TokenDatasV2BoolExp>;
};

export type SubscriptionRootTokenDatasV2ByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type SubscriptionRootTokenDatasV2StreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<TokenDatasV2StreamCursorInput>>;
  where?: InputMaybe<TokenDatasV2BoolExp>;
};

export type SubscriptionRootTokenOwnershipsArgs = {
  distinct_on?: InputMaybe<Array<TokenOwnershipsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenOwnershipsOrderBy>>;
  where?: InputMaybe<TokenOwnershipsBoolExp>;
};

export type SubscriptionRootTokenOwnershipsAggregateArgs = {
  distinct_on?: InputMaybe<Array<TokenOwnershipsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenOwnershipsOrderBy>>;
  where?: InputMaybe<TokenOwnershipsBoolExp>;
};

export type SubscriptionRootTokenOwnershipsByPkArgs = {
  property_version: Scalars["numeric"]["input"];
  table_handle: Scalars["String"]["input"];
  token_data_id_hash: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type SubscriptionRootTokenOwnershipsStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<TokenOwnershipsStreamCursorInput>>;
  where?: InputMaybe<TokenOwnershipsBoolExp>;
};

export type SubscriptionRootTokenOwnershipsV2Args = {
  distinct_on?: InputMaybe<Array<TokenOwnershipsV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenOwnershipsV2OrderBy>>;
  where?: InputMaybe<TokenOwnershipsV2BoolExp>;
};

export type SubscriptionRootTokenOwnershipsV2AggregateArgs = {
  distinct_on?: InputMaybe<Array<TokenOwnershipsV2SelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokenOwnershipsV2OrderBy>>;
  where?: InputMaybe<TokenOwnershipsV2BoolExp>;
};

export type SubscriptionRootTokenOwnershipsV2ByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

export type SubscriptionRootTokenOwnershipsV2StreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<TokenOwnershipsV2StreamCursorInput>>;
  where?: InputMaybe<TokenOwnershipsV2BoolExp>;
};

export type SubscriptionRootTokensArgs = {
  distinct_on?: InputMaybe<Array<TokensSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokensOrderBy>>;
  where?: InputMaybe<TokensBoolExp>;
};

export type SubscriptionRootTokensAggregateArgs = {
  distinct_on?: InputMaybe<Array<TokensSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TokensOrderBy>>;
  where?: InputMaybe<TokensBoolExp>;
};

export type SubscriptionRootTokensByPkArgs = {
  property_version: Scalars["numeric"]["input"];
  token_data_id_hash: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

export type SubscriptionRootTokensStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<TokensStreamCursorInput>>;
  where?: InputMaybe<TokensBoolExp>;
};

export type SubscriptionRootTransactionSizeInfoArgs = {
  distinct_on?: InputMaybe<Array<TransactionSizeInfoSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TransactionSizeInfoOrderBy>>;
  where?: InputMaybe<TransactionSizeInfoBoolExp>;
};

export type SubscriptionRootTransactionSizeInfoAggregateArgs = {
  distinct_on?: InputMaybe<Array<TransactionSizeInfoSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TransactionSizeInfoOrderBy>>;
  where?: InputMaybe<TransactionSizeInfoBoolExp>;
};

export type SubscriptionRootTransactionSizeInfoByPkArgs = {
  transaction_version: Scalars["bigint"]["input"];
};

export type SubscriptionRootTransactionSizeInfoStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<TransactionSizeInfoStreamCursorInput>>;
  where?: InputMaybe<TransactionSizeInfoBoolExp>;
};

export type SubscriptionRootTransactionsViewArgs = {
  distinct_on?: InputMaybe<Array<TransactionsViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TransactionsViewOrderBy>>;
  where?: InputMaybe<TransactionsViewBoolExp>;
};

export type SubscriptionRootTransactionsViewAggregateArgs = {
  distinct_on?: InputMaybe<Array<TransactionsViewSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<TransactionsViewOrderBy>>;
  where?: InputMaybe<TransactionsViewBoolExp>;
};

export type SubscriptionRootTransactionsViewStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<TransactionsViewStreamCursorInput>>;
  where?: InputMaybe<TransactionsViewBoolExp>;
};

export type SubscriptionRootUserTransactionsArgs = {
  distinct_on?: InputMaybe<Array<UserTransactionsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<UserTransactionsOrderBy>>;
  where?: InputMaybe<UserTransactionsBoolExp>;
};

export type SubscriptionRootUserTransactionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<UserTransactionsSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<UserTransactionsOrderBy>>;
  where?: InputMaybe<UserTransactionsBoolExp>;
};

export type SubscriptionRootUserTransactionsByPkArgs = {
  version: Scalars["bigint"]["input"];
};

export type SubscriptionRootUserTransactionsStreamArgs = {
  batch_size: Scalars["Int"]["input"];
  cursor: Array<InputMaybe<UserTransactionsStreamCursorInput>>;
  where?: InputMaybe<UserTransactionsBoolExp>;
};

/** columns and relationships of "table_items" */
export type TableItems = {
  decoded_key: Scalars["jsonb"]["output"];
  decoded_value?: Maybe<Scalars["jsonb"]["output"]>;
  inserted_at: Scalars["timestamp"]["output"];
  is_deleted: Scalars["Boolean"]["output"];
  key: Scalars["String"]["output"];
  table_handle: Scalars["String"]["output"];
  transaction_block_height: Scalars["bigint"]["output"];
  transaction_version: Scalars["bigint"]["output"];
  write_set_change_index: Scalars["bigint"]["output"];
};

/** columns and relationships of "table_items" */
export type TableItemsDecodedKeyArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** columns and relationships of "table_items" */
export type TableItemsDecodedValueArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregated selection of "table_items" */
export type TableItemsAggregate = {
  aggregate?: Maybe<TableItemsAggregateFields>;
  nodes: Array<TableItems>;
};

/** aggregate fields of "table_items" */
export type TableItemsAggregateFields = {
  avg?: Maybe<TableItemsAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<TableItemsMaxFields>;
  min?: Maybe<TableItemsMinFields>;
  stddev?: Maybe<TableItemsStddevFields>;
  stddev_pop?: Maybe<TableItemsStddevPopFields>;
  stddev_samp?: Maybe<TableItemsStddevSampFields>;
  sum?: Maybe<TableItemsSumFields>;
  var_pop?: Maybe<TableItemsVarPopFields>;
  var_samp?: Maybe<TableItemsVarSampFields>;
  variance?: Maybe<TableItemsVarianceFields>;
};

/** aggregate fields of "table_items" */
export type TableItemsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TableItemsSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type TableItemsAppendInput = {
  decoded_key?: InputMaybe<Scalars["jsonb"]["input"]>;
  decoded_value?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** aggregate avg on columns */
export type TableItemsAvgFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "table_items". All fields are combined with a logical 'AND'. */
export type TableItemsBoolExp = {
  _and?: InputMaybe<Array<TableItemsBoolExp>>;
  _not?: InputMaybe<TableItemsBoolExp>;
  _or?: InputMaybe<Array<TableItemsBoolExp>>;
  decoded_key?: InputMaybe<JsonbComparisonExp>;
  decoded_value?: InputMaybe<JsonbComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_deleted?: InputMaybe<BooleanComparisonExp>;
  key?: InputMaybe<StringComparisonExp>;
  table_handle?: InputMaybe<StringComparisonExp>;
  transaction_block_height?: InputMaybe<BigintComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  write_set_change_index?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "table_items" */
export enum TableItemsConstraint {
  /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
  TableItemsPkey = "table_items_pkey",
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type TableItemsDeleteAtPathInput = {
  decoded_key?: InputMaybe<Array<Scalars["String"]["input"]>>;
  decoded_value?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type TableItemsDeleteElemInput = {
  decoded_key?: InputMaybe<Scalars["Int"]["input"]>;
  decoded_value?: InputMaybe<Scalars["Int"]["input"]>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type TableItemsDeleteKeyInput = {
  decoded_key?: InputMaybe<Scalars["String"]["input"]>;
  decoded_value?: InputMaybe<Scalars["String"]["input"]>;
};

/** input type for incrementing numeric columns in table "table_items" */
export type TableItemsIncInput = {
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "table_items" */
export type TableItemsInsertInput = {
  decoded_key?: InputMaybe<Scalars["jsonb"]["input"]>;
  decoded_value?: InputMaybe<Scalars["jsonb"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  key?: InputMaybe<Scalars["String"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type TableItemsMaxFields = {
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  key?: Maybe<Scalars["String"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type TableItemsMinFields = {
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  key?: Maybe<Scalars["String"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "table_items" */
export type TableItemsMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<TableItems>;
};

/** on_conflict condition type for table "table_items" */
export type TableItemsOnConflict = {
  constraint: TableItemsConstraint;
  update_columns?: Array<TableItemsUpdateColumn>;
  where?: InputMaybe<TableItemsBoolExp>;
};

/** Ordering options when selecting data from "table_items". */
export type TableItemsOrderBy = {
  decoded_key?: InputMaybe<OrderBy>;
  decoded_value?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_deleted?: InputMaybe<OrderBy>;
  key?: InputMaybe<OrderBy>;
  table_handle?: InputMaybe<OrderBy>;
  transaction_block_height?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  write_set_change_index?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: table_items */
export type TableItemsPkColumnsInput = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type TableItemsPrependInput = {
  decoded_key?: InputMaybe<Scalars["jsonb"]["input"]>;
  decoded_value?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** select columns of table "table_items" */
export enum TableItemsSelectColumn {
  /** column name */
  DecodedKey = "decoded_key",
  /** column name */
  DecodedValue = "decoded_value",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  Key = "key",
  /** column name */
  TableHandle = "table_handle",
  /** column name */
  TransactionBlockHeight = "transaction_block_height",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

/** input type for updating data in table "table_items" */
export type TableItemsSetInput = {
  decoded_key?: InputMaybe<Scalars["jsonb"]["input"]>;
  decoded_value?: InputMaybe<Scalars["jsonb"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  key?: InputMaybe<Scalars["String"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type TableItemsStddevFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type TableItemsStddevPopFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type TableItemsStddevSampFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "table_items" */
export type TableItemsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TableItemsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TableItemsStreamCursorValueInput = {
  decoded_key?: InputMaybe<Scalars["jsonb"]["input"]>;
  decoded_value?: InputMaybe<Scalars["jsonb"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  key?: InputMaybe<Scalars["String"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type TableItemsSumFields = {
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "table_items" */
export enum TableItemsUpdateColumn {
  /** column name */
  DecodedKey = "decoded_key",
  /** column name */
  DecodedValue = "decoded_value",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  Key = "key",
  /** column name */
  TableHandle = "table_handle",
  /** column name */
  TransactionBlockHeight = "transaction_block_height",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

export type TableItemsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<TableItemsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<TableItemsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<TableItemsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<TableItemsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TableItemsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<TableItemsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TableItemsSetInput>;
  /** filter the rows which have to be updated */
  where: TableItemsBoolExp;
};

/** aggregate var_pop on columns */
export type TableItemsVarPopFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type TableItemsVarSampFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type TableItemsVarianceFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "table_items_view" */
export type TableItemsView = {
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  is_deleted?: Maybe<Scalars["Boolean"]["output"]>;
  json_decoded_key?: Maybe<Scalars["String"]["output"]>;
  json_decoded_value?: Maybe<Scalars["String"]["output"]>;
  key?: Maybe<Scalars["String"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregated selection of "table_items_view" */
export type TableItemsViewAggregate = {
  aggregate?: Maybe<TableItemsViewAggregateFields>;
  nodes: Array<TableItemsView>;
};

/** aggregate fields of "table_items_view" */
export type TableItemsViewAggregateFields = {
  avg?: Maybe<TableItemsViewAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<TableItemsViewMaxFields>;
  min?: Maybe<TableItemsViewMinFields>;
  stddev?: Maybe<TableItemsViewStddevFields>;
  stddev_pop?: Maybe<TableItemsViewStddevPopFields>;
  stddev_samp?: Maybe<TableItemsViewStddevSampFields>;
  sum?: Maybe<TableItemsViewSumFields>;
  var_pop?: Maybe<TableItemsViewVarPopFields>;
  var_samp?: Maybe<TableItemsViewVarSampFields>;
  variance?: Maybe<TableItemsViewVarianceFields>;
};

/** aggregate fields of "table_items_view" */
export type TableItemsViewAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TableItemsViewSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type TableItemsViewAvgFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "table_items_view". All fields are combined with a logical 'AND'. */
export type TableItemsViewBoolExp = {
  _and?: InputMaybe<Array<TableItemsViewBoolExp>>;
  _not?: InputMaybe<TableItemsViewBoolExp>;
  _or?: InputMaybe<Array<TableItemsViewBoolExp>>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_deleted?: InputMaybe<BooleanComparisonExp>;
  json_decoded_key?: InputMaybe<StringComparisonExp>;
  json_decoded_value?: InputMaybe<StringComparisonExp>;
  key?: InputMaybe<StringComparisonExp>;
  table_handle?: InputMaybe<StringComparisonExp>;
  transaction_block_height?: InputMaybe<BigintComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  write_set_change_index?: InputMaybe<BigintComparisonExp>;
};

/** input type for incrementing numeric columns in table "table_items_view" */
export type TableItemsViewIncInput = {
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "table_items_view" */
export type TableItemsViewInsertInput = {
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  json_decoded_key?: InputMaybe<Scalars["String"]["input"]>;
  json_decoded_value?: InputMaybe<Scalars["String"]["input"]>;
  key?: InputMaybe<Scalars["String"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type TableItemsViewMaxFields = {
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  json_decoded_key?: Maybe<Scalars["String"]["output"]>;
  json_decoded_value?: Maybe<Scalars["String"]["output"]>;
  key?: Maybe<Scalars["String"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type TableItemsViewMinFields = {
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  json_decoded_key?: Maybe<Scalars["String"]["output"]>;
  json_decoded_value?: Maybe<Scalars["String"]["output"]>;
  key?: Maybe<Scalars["String"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "table_items_view" */
export type TableItemsViewMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<TableItemsView>;
};

/** Ordering options when selecting data from "table_items_view". */
export type TableItemsViewOrderBy = {
  inserted_at?: InputMaybe<OrderBy>;
  is_deleted?: InputMaybe<OrderBy>;
  json_decoded_key?: InputMaybe<OrderBy>;
  json_decoded_value?: InputMaybe<OrderBy>;
  key?: InputMaybe<OrderBy>;
  table_handle?: InputMaybe<OrderBy>;
  transaction_block_height?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  write_set_change_index?: InputMaybe<OrderBy>;
};

/** select columns of table "table_items_view" */
export enum TableItemsViewSelectColumn {
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeleted = "is_deleted",
  /** column name */
  JsonDecodedKey = "json_decoded_key",
  /** column name */
  JsonDecodedValue = "json_decoded_value",
  /** column name */
  Key = "key",
  /** column name */
  TableHandle = "table_handle",
  /** column name */
  TransactionBlockHeight = "transaction_block_height",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

/** input type for updating data in table "table_items_view" */
export type TableItemsViewSetInput = {
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  json_decoded_key?: InputMaybe<Scalars["String"]["input"]>;
  json_decoded_value?: InputMaybe<Scalars["String"]["input"]>;
  key?: InputMaybe<Scalars["String"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type TableItemsViewStddevFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type TableItemsViewStddevPopFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type TableItemsViewStddevSampFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "table_items_view" */
export type TableItemsViewStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TableItemsViewStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TableItemsViewStreamCursorValueInput = {
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  json_decoded_key?: InputMaybe<Scalars["String"]["input"]>;
  json_decoded_value?: InputMaybe<Scalars["String"]["input"]>;
  key?: InputMaybe<Scalars["String"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type TableItemsViewSumFields = {
  transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

export type TableItemsViewUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TableItemsViewIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TableItemsViewSetInput>;
  /** filter the rows which have to be updated */
  where: TableItemsViewBoolExp;
};

/** aggregate var_pop on columns */
export type TableItemsViewVarPopFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type TableItemsViewVarSampFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type TableItemsViewVarianceFields = {
  transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "table_metadatas" */
export type TableMetadatas = {
  handle: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  key_type: Scalars["String"]["output"];
  value_type: Scalars["String"]["output"];
};

/** aggregated selection of "table_metadatas" */
export type TableMetadatasAggregate = {
  aggregate?: Maybe<TableMetadatasAggregateFields>;
  nodes: Array<TableMetadatas>;
};

/** aggregate fields of "table_metadatas" */
export type TableMetadatasAggregateFields = {
  count: Scalars["Int"]["output"];
  max?: Maybe<TableMetadatasMaxFields>;
  min?: Maybe<TableMetadatasMinFields>;
};

/** aggregate fields of "table_metadatas" */
export type TableMetadatasAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TableMetadatasSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** Boolean expression to filter rows from the table "table_metadatas". All fields are combined with a logical 'AND'. */
export type TableMetadatasBoolExp = {
  _and?: InputMaybe<Array<TableMetadatasBoolExp>>;
  _not?: InputMaybe<TableMetadatasBoolExp>;
  _or?: InputMaybe<Array<TableMetadatasBoolExp>>;
  handle?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  key_type?: InputMaybe<StringComparisonExp>;
  value_type?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "table_metadatas" */
export enum TableMetadatasConstraint {
  /** unique or primary key constraint on columns "handle" */
  TableMetadatasPkey = "table_metadatas_pkey",
}

/** input type for inserting data into table "table_metadatas" */
export type TableMetadatasInsertInput = {
  handle?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  key_type?: InputMaybe<Scalars["String"]["input"]>;
  value_type?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type TableMetadatasMaxFields = {
  handle?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  key_type?: Maybe<Scalars["String"]["output"]>;
  value_type?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type TableMetadatasMinFields = {
  handle?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  key_type?: Maybe<Scalars["String"]["output"]>;
  value_type?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "table_metadatas" */
export type TableMetadatasMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<TableMetadatas>;
};

/** on_conflict condition type for table "table_metadatas" */
export type TableMetadatasOnConflict = {
  constraint: TableMetadatasConstraint;
  update_columns?: Array<TableMetadatasUpdateColumn>;
  where?: InputMaybe<TableMetadatasBoolExp>;
};

/** Ordering options when selecting data from "table_metadatas". */
export type TableMetadatasOrderBy = {
  handle?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  key_type?: InputMaybe<OrderBy>;
  value_type?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: table_metadatas */
export type TableMetadatasPkColumnsInput = {
  handle: Scalars["String"]["input"];
};

/** select columns of table "table_metadatas" */
export enum TableMetadatasSelectColumn {
  /** column name */
  Handle = "handle",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  KeyType = "key_type",
  /** column name */
  ValueType = "value_type",
}

/** input type for updating data in table "table_metadatas" */
export type TableMetadatasSetInput = {
  handle?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  key_type?: InputMaybe<Scalars["String"]["input"]>;
  value_type?: InputMaybe<Scalars["String"]["input"]>;
};

/** Streaming cursor of the table "table_metadatas" */
export type TableMetadatasStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TableMetadatasStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TableMetadatasStreamCursorValueInput = {
  handle?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  key_type?: InputMaybe<Scalars["String"]["input"]>;
  value_type?: InputMaybe<Scalars["String"]["input"]>;
};

/** update columns of table "table_metadatas" */
export enum TableMetadatasUpdateColumn {
  /** column name */
  Handle = "handle",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  KeyType = "key_type",
  /** column name */
  ValueType = "value_type",
}

export type TableMetadatasUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TableMetadatasSetInput>;
  /** filter the rows which have to be updated */
  where: TableMetadatasBoolExp;
};

/** Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'. */
export type TimestampComparisonExp = {
  _eq?: InputMaybe<Scalars["timestamp"]["input"]>;
  _gt?: InputMaybe<Scalars["timestamp"]["input"]>;
  _gte?: InputMaybe<Scalars["timestamp"]["input"]>;
  _in?: InputMaybe<Array<Scalars["timestamp"]["input"]>>;
  _is_null?: InputMaybe<Scalars["Boolean"]["input"]>;
  _lt?: InputMaybe<Scalars["timestamp"]["input"]>;
  _lte?: InputMaybe<Scalars["timestamp"]["input"]>;
  _neq?: InputMaybe<Scalars["timestamp"]["input"]>;
  _nin?: InputMaybe<Array<Scalars["timestamp"]["input"]>>;
};

/** columns and relationships of "token_activities" */
export type TokenActivities = {
  coin_amount?: Maybe<Scalars["numeric"]["output"]>;
  coin_type?: Maybe<Scalars["String"]["output"]>;
  collection_data_id_hash: Scalars["String"]["output"];
  collection_name: Scalars["String"]["output"];
  creator_address: Scalars["String"]["output"];
  event_account_address: Scalars["String"]["output"];
  event_creation_number: Scalars["bigint"]["output"];
  event_index?: Maybe<Scalars["bigint"]["output"]>;
  event_sequence_number: Scalars["bigint"]["output"];
  from_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at: Scalars["timestamp"]["output"];
  name: Scalars["String"]["output"];
  property_version: Scalars["numeric"]["output"];
  to_address?: Maybe<Scalars["String"]["output"]>;
  token_amount: Scalars["numeric"]["output"];
  token_data_id_hash: Scalars["String"]["output"];
  transaction_timestamp: Scalars["timestamp"]["output"];
  transaction_version: Scalars["bigint"]["output"];
  transfer_type: Scalars["String"]["output"];
};

/** aggregated selection of "token_activities" */
export type TokenActivitiesAggregate = {
  aggregate?: Maybe<TokenActivitiesAggregateFields>;
  nodes: Array<TokenActivities>;
};

/** aggregate fields of "token_activities" */
export type TokenActivitiesAggregateFields = {
  avg?: Maybe<TokenActivitiesAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<TokenActivitiesMaxFields>;
  min?: Maybe<TokenActivitiesMinFields>;
  stddev?: Maybe<TokenActivitiesStddevFields>;
  stddev_pop?: Maybe<TokenActivitiesStddevPopFields>;
  stddev_samp?: Maybe<TokenActivitiesStddevSampFields>;
  sum?: Maybe<TokenActivitiesSumFields>;
  var_pop?: Maybe<TokenActivitiesVarPopFields>;
  var_samp?: Maybe<TokenActivitiesVarSampFields>;
  variance?: Maybe<TokenActivitiesVarianceFields>;
};

/** aggregate fields of "token_activities" */
export type TokenActivitiesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TokenActivitiesSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type TokenActivitiesAvgFields = {
  coin_amount?: Maybe<Scalars["Float"]["output"]>;
  event_creation_number?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
  token_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "token_activities". All fields are combined with a logical 'AND'. */
export type TokenActivitiesBoolExp = {
  _and?: InputMaybe<Array<TokenActivitiesBoolExp>>;
  _not?: InputMaybe<TokenActivitiesBoolExp>;
  _or?: InputMaybe<Array<TokenActivitiesBoolExp>>;
  coin_amount?: InputMaybe<NumericComparisonExp>;
  coin_type?: InputMaybe<StringComparisonExp>;
  collection_data_id_hash?: InputMaybe<StringComparisonExp>;
  collection_name?: InputMaybe<StringComparisonExp>;
  creator_address?: InputMaybe<StringComparisonExp>;
  event_account_address?: InputMaybe<StringComparisonExp>;
  event_creation_number?: InputMaybe<BigintComparisonExp>;
  event_index?: InputMaybe<BigintComparisonExp>;
  event_sequence_number?: InputMaybe<BigintComparisonExp>;
  from_address?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  property_version?: InputMaybe<NumericComparisonExp>;
  to_address?: InputMaybe<StringComparisonExp>;
  token_amount?: InputMaybe<NumericComparisonExp>;
  token_data_id_hash?: InputMaybe<StringComparisonExp>;
  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  transfer_type?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "token_activities" */
export enum TokenActivitiesConstraint {
  /** unique or primary key constraint on columns "event_sequence_number", "event_creation_number", "transaction_version", "event_account_address" */
  TokenActivitiesPkey = "token_activities_pkey",
}

/** input type for incrementing numeric columns in table "token_activities" */
export type TokenActivitiesIncInput = {
  coin_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  event_creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  event_sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
  property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  token_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "token_activities" */
export type TokenActivitiesInsertInput = {
  coin_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  coin_type?: InputMaybe<Scalars["String"]["input"]>;
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  event_account_address?: InputMaybe<Scalars["String"]["input"]>;
  event_creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  event_sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
  from_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  to_address?: InputMaybe<Scalars["String"]["input"]>;
  token_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  transfer_type?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type TokenActivitiesMaxFields = {
  coin_amount?: Maybe<Scalars["numeric"]["output"]>;
  coin_type?: Maybe<Scalars["String"]["output"]>;
  collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  event_account_address?: Maybe<Scalars["String"]["output"]>;
  event_creation_number?: Maybe<Scalars["bigint"]["output"]>;
  event_index?: Maybe<Scalars["bigint"]["output"]>;
  event_sequence_number?: Maybe<Scalars["bigint"]["output"]>;
  from_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  property_version?: Maybe<Scalars["numeric"]["output"]>;
  to_address?: Maybe<Scalars["String"]["output"]>;
  token_amount?: Maybe<Scalars["numeric"]["output"]>;
  token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  transfer_type?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type TokenActivitiesMinFields = {
  coin_amount?: Maybe<Scalars["numeric"]["output"]>;
  coin_type?: Maybe<Scalars["String"]["output"]>;
  collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  event_account_address?: Maybe<Scalars["String"]["output"]>;
  event_creation_number?: Maybe<Scalars["bigint"]["output"]>;
  event_index?: Maybe<Scalars["bigint"]["output"]>;
  event_sequence_number?: Maybe<Scalars["bigint"]["output"]>;
  from_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  property_version?: Maybe<Scalars["numeric"]["output"]>;
  to_address?: Maybe<Scalars["String"]["output"]>;
  token_amount?: Maybe<Scalars["numeric"]["output"]>;
  token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  transfer_type?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "token_activities" */
export type TokenActivitiesMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<TokenActivities>;
};

/** on_conflict condition type for table "token_activities" */
export type TokenActivitiesOnConflict = {
  constraint: TokenActivitiesConstraint;
  update_columns?: Array<TokenActivitiesUpdateColumn>;
  where?: InputMaybe<TokenActivitiesBoolExp>;
};

/** Ordering options when selecting data from "token_activities". */
export type TokenActivitiesOrderBy = {
  coin_amount?: InputMaybe<OrderBy>;
  coin_type?: InputMaybe<OrderBy>;
  collection_data_id_hash?: InputMaybe<OrderBy>;
  collection_name?: InputMaybe<OrderBy>;
  creator_address?: InputMaybe<OrderBy>;
  event_account_address?: InputMaybe<OrderBy>;
  event_creation_number?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  event_sequence_number?: InputMaybe<OrderBy>;
  from_address?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  property_version?: InputMaybe<OrderBy>;
  to_address?: InputMaybe<OrderBy>;
  token_amount?: InputMaybe<OrderBy>;
  token_data_id_hash?: InputMaybe<OrderBy>;
  transaction_timestamp?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  transfer_type?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: token_activities */
export type TokenActivitiesPkColumnsInput = {
  event_account_address: Scalars["String"]["input"];
  event_creation_number: Scalars["bigint"]["input"];
  event_sequence_number: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** select columns of table "token_activities" */
export enum TokenActivitiesSelectColumn {
  /** column name */
  CoinAmount = "coin_amount",
  /** column name */
  CoinType = "coin_type",
  /** column name */
  CollectionDataIdHash = "collection_data_id_hash",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  EventAccountAddress = "event_account_address",
  /** column name */
  EventCreationNumber = "event_creation_number",
  /** column name */
  EventIndex = "event_index",
  /** column name */
  EventSequenceNumber = "event_sequence_number",
  /** column name */
  FromAddress = "from_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  Name = "name",
  /** column name */
  PropertyVersion = "property_version",
  /** column name */
  ToAddress = "to_address",
  /** column name */
  TokenAmount = "token_amount",
  /** column name */
  TokenDataIdHash = "token_data_id_hash",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  TransferType = "transfer_type",
}

/** input type for updating data in table "token_activities" */
export type TokenActivitiesSetInput = {
  coin_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  coin_type?: InputMaybe<Scalars["String"]["input"]>;
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  event_account_address?: InputMaybe<Scalars["String"]["input"]>;
  event_creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  event_sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
  from_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  to_address?: InputMaybe<Scalars["String"]["input"]>;
  token_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  transfer_type?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type TokenActivitiesStddevFields = {
  coin_amount?: Maybe<Scalars["Float"]["output"]>;
  event_creation_number?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
  token_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type TokenActivitiesStddevPopFields = {
  coin_amount?: Maybe<Scalars["Float"]["output"]>;
  event_creation_number?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
  token_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type TokenActivitiesStddevSampFields = {
  coin_amount?: Maybe<Scalars["Float"]["output"]>;
  event_creation_number?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
  token_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "token_activities" */
export type TokenActivitiesStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TokenActivitiesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TokenActivitiesStreamCursorValueInput = {
  coin_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  coin_type?: InputMaybe<Scalars["String"]["input"]>;
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  event_account_address?: InputMaybe<Scalars["String"]["input"]>;
  event_creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  event_sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
  from_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  to_address?: InputMaybe<Scalars["String"]["input"]>;
  token_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  transfer_type?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type TokenActivitiesSumFields = {
  coin_amount?: Maybe<Scalars["numeric"]["output"]>;
  event_creation_number?: Maybe<Scalars["bigint"]["output"]>;
  event_index?: Maybe<Scalars["bigint"]["output"]>;
  event_sequence_number?: Maybe<Scalars["bigint"]["output"]>;
  property_version?: Maybe<Scalars["numeric"]["output"]>;
  token_amount?: Maybe<Scalars["numeric"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "token_activities" */
export enum TokenActivitiesUpdateColumn {
  /** column name */
  CoinAmount = "coin_amount",
  /** column name */
  CoinType = "coin_type",
  /** column name */
  CollectionDataIdHash = "collection_data_id_hash",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  EventAccountAddress = "event_account_address",
  /** column name */
  EventCreationNumber = "event_creation_number",
  /** column name */
  EventIndex = "event_index",
  /** column name */
  EventSequenceNumber = "event_sequence_number",
  /** column name */
  FromAddress = "from_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  Name = "name",
  /** column name */
  PropertyVersion = "property_version",
  /** column name */
  ToAddress = "to_address",
  /** column name */
  TokenAmount = "token_amount",
  /** column name */
  TokenDataIdHash = "token_data_id_hash",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  TransferType = "transfer_type",
}

export type TokenActivitiesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TokenActivitiesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TokenActivitiesSetInput>;
  /** filter the rows which have to be updated */
  where: TokenActivitiesBoolExp;
};

/** columns and relationships of "token_activities_v2" */
export type TokenActivitiesV2 = {
  after_value?: Maybe<Scalars["String"]["output"]>;
  before_value?: Maybe<Scalars["String"]["output"]>;
  /** An array relationship */
  cedra_names_from: Array<CurrentCedraNames>;
  /** An aggregate relationship */
  cedra_names_from_aggregate: CurrentCedraNamesAggregate;
  /** An array relationship */
  cedra_names_to: Array<CurrentCedraNames>;
  /** An aggregate relationship */
  cedra_names_to_aggregate: CurrentCedraNamesAggregate;
  /** An object relationship */
  current_token_data?: Maybe<CurrentTokenDatasV2>;
  entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
  event_account_address: Scalars["String"]["output"];
  event_index: Scalars["bigint"]["output"];
  from_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at: Scalars["timestamp"]["output"];
  is_fungible_v2?: Maybe<Scalars["Boolean"]["output"]>;
  property_version_v1: Scalars["numeric"]["output"];
  to_address?: Maybe<Scalars["String"]["output"]>;
  token_amount: Scalars["numeric"]["output"];
  token_data_id: Scalars["String"]["output"];
  token_standard: Scalars["String"]["output"];
  transaction_timestamp: Scalars["timestamp"]["output"];
  transaction_version: Scalars["bigint"]["output"];
  type: Scalars["String"]["output"];
};

/** columns and relationships of "token_activities_v2" */
export type TokenActivitiesV2CedraNamesFromArgs = {
  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
  where?: InputMaybe<CurrentCedraNamesBoolExp>;
};

/** columns and relationships of "token_activities_v2" */
export type TokenActivitiesV2CedraNamesFromAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
  where?: InputMaybe<CurrentCedraNamesBoolExp>;
};

/** columns and relationships of "token_activities_v2" */
export type TokenActivitiesV2CedraNamesToArgs = {
  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
  where?: InputMaybe<CurrentCedraNamesBoolExp>;
};

/** columns and relationships of "token_activities_v2" */
export type TokenActivitiesV2CedraNamesToAggregateArgs = {
  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  offset?: InputMaybe<Scalars["Int"]["input"]>;
  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
  where?: InputMaybe<CurrentCedraNamesBoolExp>;
};

/** aggregated selection of "token_activities_v2" */
export type TokenActivitiesV2Aggregate = {
  aggregate?: Maybe<TokenActivitiesV2AggregateFields>;
  nodes: Array<TokenActivitiesV2>;
};

export type TokenActivitiesV2AggregateBoolExp = {
  bool_and?: InputMaybe<TokenActivitiesV2AggregateBoolExpBoolAnd>;
  bool_or?: InputMaybe<TokenActivitiesV2AggregateBoolExpBoolOr>;
  count?: InputMaybe<TokenActivitiesV2AggregateBoolExpCount>;
};

export type TokenActivitiesV2AggregateBoolExpBoolAnd = {
  arguments: TokenActivitiesV2SelectColumnTokenActivitiesV2AggregateBoolExpBoolAndArgumentsColumns;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
  filter?: InputMaybe<TokenActivitiesV2BoolExp>;
  predicate: BooleanComparisonExp;
};

export type TokenActivitiesV2AggregateBoolExpBoolOr = {
  arguments: TokenActivitiesV2SelectColumnTokenActivitiesV2AggregateBoolExpBoolOrArgumentsColumns;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
  filter?: InputMaybe<TokenActivitiesV2BoolExp>;
  predicate: BooleanComparisonExp;
};

export type TokenActivitiesV2AggregateBoolExpCount = {
  arguments?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
  filter?: InputMaybe<TokenActivitiesV2BoolExp>;
  predicate: IntComparisonExp;
};

/** aggregate fields of "token_activities_v2" */
export type TokenActivitiesV2AggregateFields = {
  avg?: Maybe<TokenActivitiesV2AvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<TokenActivitiesV2MaxFields>;
  min?: Maybe<TokenActivitiesV2MinFields>;
  stddev?: Maybe<TokenActivitiesV2StddevFields>;
  stddev_pop?: Maybe<TokenActivitiesV2StddevPopFields>;
  stddev_samp?: Maybe<TokenActivitiesV2StddevSampFields>;
  sum?: Maybe<TokenActivitiesV2SumFields>;
  var_pop?: Maybe<TokenActivitiesV2VarPopFields>;
  var_samp?: Maybe<TokenActivitiesV2VarSampFields>;
  variance?: Maybe<TokenActivitiesV2VarianceFields>;
};

/** aggregate fields of "token_activities_v2" */
export type TokenActivitiesV2AggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** order by aggregate values of table "token_activities_v2" */
export type TokenActivitiesV2AggregateOrderBy = {
  avg?: InputMaybe<TokenActivitiesV2AvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<TokenActivitiesV2MaxOrderBy>;
  min?: InputMaybe<TokenActivitiesV2MinOrderBy>;
  stddev?: InputMaybe<TokenActivitiesV2StddevOrderBy>;
  stddev_pop?: InputMaybe<TokenActivitiesV2StddevPopOrderBy>;
  stddev_samp?: InputMaybe<TokenActivitiesV2StddevSampOrderBy>;
  sum?: InputMaybe<TokenActivitiesV2SumOrderBy>;
  var_pop?: InputMaybe<TokenActivitiesV2VarPopOrderBy>;
  var_samp?: InputMaybe<TokenActivitiesV2VarSampOrderBy>;
  variance?: InputMaybe<TokenActivitiesV2VarianceOrderBy>;
};

/** input type for inserting array relation for remote table "token_activities_v2" */
export type TokenActivitiesV2ArrRelInsertInput = {
  data: Array<TokenActivitiesV2InsertInput>;
  /** upsert condition */
  on_conflict?: InputMaybe<TokenActivitiesV2OnConflict>;
};

/** aggregate avg on columns */
export type TokenActivitiesV2AvgFields = {
  event_index?: Maybe<Scalars["Float"]["output"]>;
  property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  token_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** order by avg() on columns of table "token_activities_v2" */
export type TokenActivitiesV2AvgOrderBy = {
  event_index?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
  token_amount?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "token_activities_v2". All fields are combined with a logical 'AND'. */
export type TokenActivitiesV2BoolExp = {
  _and?: InputMaybe<Array<TokenActivitiesV2BoolExp>>;
  _not?: InputMaybe<TokenActivitiesV2BoolExp>;
  _or?: InputMaybe<Array<TokenActivitiesV2BoolExp>>;
  after_value?: InputMaybe<StringComparisonExp>;
  before_value?: InputMaybe<StringComparisonExp>;
  cedra_names_from?: InputMaybe<CurrentCedraNamesBoolExp>;
  cedra_names_from_aggregate?: InputMaybe<CurrentCedraNamesAggregateBoolExp>;
  cedra_names_to?: InputMaybe<CurrentCedraNamesBoolExp>;
  cedra_names_to_aggregate?: InputMaybe<CurrentCedraNamesAggregateBoolExp>;
  current_token_data?: InputMaybe<CurrentTokenDatasV2BoolExp>;
  entry_function_id_str?: InputMaybe<StringComparisonExp>;
  event_account_address?: InputMaybe<StringComparisonExp>;
  event_index?: InputMaybe<BigintComparisonExp>;
  from_address?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_fungible_v2?: InputMaybe<BooleanComparisonExp>;
  property_version_v1?: InputMaybe<NumericComparisonExp>;
  to_address?: InputMaybe<StringComparisonExp>;
  token_amount?: InputMaybe<NumericComparisonExp>;
  token_data_id?: InputMaybe<StringComparisonExp>;
  token_standard?: InputMaybe<StringComparisonExp>;
  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  type?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "token_activities_v2" */
export enum TokenActivitiesV2Constraint {
  /** unique or primary key constraint on columns "event_index", "transaction_version" */
  TokenActivitiesV2Pkey = "token_activities_v2_pkey",
}

/** input type for incrementing numeric columns in table "token_activities_v2" */
export type TokenActivitiesV2IncInput = {
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  token_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "token_activities_v2" */
export type TokenActivitiesV2InsertInput = {
  after_value?: InputMaybe<Scalars["String"]["input"]>;
  before_value?: InputMaybe<Scalars["String"]["input"]>;
  cedra_names_from?: InputMaybe<CurrentCedraNamesArrRelInsertInput>;
  cedra_names_to?: InputMaybe<CurrentCedraNamesArrRelInsertInput>;
  current_token_data?: InputMaybe<CurrentTokenDatasV2ObjRelInsertInput>;
  entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
  event_account_address?: InputMaybe<Scalars["String"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  from_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  to_address?: InputMaybe<Scalars["String"]["input"]>;
  token_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type TokenActivitiesV2MaxFields = {
  after_value?: Maybe<Scalars["String"]["output"]>;
  before_value?: Maybe<Scalars["String"]["output"]>;
  entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
  event_account_address?: Maybe<Scalars["String"]["output"]>;
  event_index?: Maybe<Scalars["bigint"]["output"]>;
  from_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
  to_address?: Maybe<Scalars["String"]["output"]>;
  token_amount?: Maybe<Scalars["numeric"]["output"]>;
  token_data_id?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  type?: Maybe<Scalars["String"]["output"]>;
};

/** order by max() on columns of table "token_activities_v2" */
export type TokenActivitiesV2MaxOrderBy = {
  after_value?: InputMaybe<OrderBy>;
  before_value?: InputMaybe<OrderBy>;
  entry_function_id_str?: InputMaybe<OrderBy>;
  event_account_address?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  from_address?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
  to_address?: InputMaybe<OrderBy>;
  token_amount?: InputMaybe<OrderBy>;
  token_data_id?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
  transaction_timestamp?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type TokenActivitiesV2MinFields = {
  after_value?: Maybe<Scalars["String"]["output"]>;
  before_value?: Maybe<Scalars["String"]["output"]>;
  entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
  event_account_address?: Maybe<Scalars["String"]["output"]>;
  event_index?: Maybe<Scalars["bigint"]["output"]>;
  from_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
  to_address?: Maybe<Scalars["String"]["output"]>;
  token_amount?: Maybe<Scalars["numeric"]["output"]>;
  token_data_id?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  type?: Maybe<Scalars["String"]["output"]>;
};

/** order by min() on columns of table "token_activities_v2" */
export type TokenActivitiesV2MinOrderBy = {
  after_value?: InputMaybe<OrderBy>;
  before_value?: InputMaybe<OrderBy>;
  entry_function_id_str?: InputMaybe<OrderBy>;
  event_account_address?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  from_address?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
  to_address?: InputMaybe<OrderBy>;
  token_amount?: InputMaybe<OrderBy>;
  token_data_id?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
  transaction_timestamp?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "token_activities_v2" */
export type TokenActivitiesV2MutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<TokenActivitiesV2>;
};

/** on_conflict condition type for table "token_activities_v2" */
export type TokenActivitiesV2OnConflict = {
  constraint: TokenActivitiesV2Constraint;
  update_columns?: Array<TokenActivitiesV2UpdateColumn>;
  where?: InputMaybe<TokenActivitiesV2BoolExp>;
};

/** Ordering options when selecting data from "token_activities_v2". */
export type TokenActivitiesV2OrderBy = {
  after_value?: InputMaybe<OrderBy>;
  before_value?: InputMaybe<OrderBy>;
  cedra_names_from_aggregate?: InputMaybe<CurrentCedraNamesAggregateOrderBy>;
  cedra_names_to_aggregate?: InputMaybe<CurrentCedraNamesAggregateOrderBy>;
  current_token_data?: InputMaybe<CurrentTokenDatasV2OrderBy>;
  entry_function_id_str?: InputMaybe<OrderBy>;
  event_account_address?: InputMaybe<OrderBy>;
  event_index?: InputMaybe<OrderBy>;
  from_address?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_fungible_v2?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
  to_address?: InputMaybe<OrderBy>;
  token_amount?: InputMaybe<OrderBy>;
  token_data_id?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
  transaction_timestamp?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: token_activities_v2 */
export type TokenActivitiesV2PkColumnsInput = {
  event_index: Scalars["bigint"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** select columns of table "token_activities_v2" */
export enum TokenActivitiesV2SelectColumn {
  /** column name */
  AfterValue = "after_value",
  /** column name */
  BeforeValue = "before_value",
  /** column name */
  EntryFunctionIdStr = "entry_function_id_str",
  /** column name */
  EventAccountAddress = "event_account_address",
  /** column name */
  EventIndex = "event_index",
  /** column name */
  FromAddress = "from_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsFungibleV2 = "is_fungible_v2",
  /** column name */
  PropertyVersionV1 = "property_version_v1",
  /** column name */
  ToAddress = "to_address",
  /** column name */
  TokenAmount = "token_amount",
  /** column name */
  TokenDataId = "token_data_id",
  /** column name */
  TokenStandard = "token_standard",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  Type = "type",
}

/** select "token_activities_v2_aggregate_bool_exp_bool_and_arguments_columns" columns of table "token_activities_v2" */
export enum TokenActivitiesV2SelectColumnTokenActivitiesV2AggregateBoolExpBoolAndArgumentsColumns {
  /** column name */
  IsFungibleV2 = "is_fungible_v2",
}

/** select "token_activities_v2_aggregate_bool_exp_bool_or_arguments_columns" columns of table "token_activities_v2" */
export enum TokenActivitiesV2SelectColumnTokenActivitiesV2AggregateBoolExpBoolOrArgumentsColumns {
  /** column name */
  IsFungibleV2 = "is_fungible_v2",
}

/** input type for updating data in table "token_activities_v2" */
export type TokenActivitiesV2SetInput = {
  after_value?: InputMaybe<Scalars["String"]["input"]>;
  before_value?: InputMaybe<Scalars["String"]["input"]>;
  entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
  event_account_address?: InputMaybe<Scalars["String"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  from_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  to_address?: InputMaybe<Scalars["String"]["input"]>;
  token_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type TokenActivitiesV2StddevFields = {
  event_index?: Maybe<Scalars["Float"]["output"]>;
  property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  token_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** order by stddev() on columns of table "token_activities_v2" */
export type TokenActivitiesV2StddevOrderBy = {
  event_index?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
  token_amount?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** aggregate stddev_pop on columns */
export type TokenActivitiesV2StddevPopFields = {
  event_index?: Maybe<Scalars["Float"]["output"]>;
  property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  token_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** order by stddev_pop() on columns of table "token_activities_v2" */
export type TokenActivitiesV2StddevPopOrderBy = {
  event_index?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
  token_amount?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** aggregate stddev_samp on columns */
export type TokenActivitiesV2StddevSampFields = {
  event_index?: Maybe<Scalars["Float"]["output"]>;
  property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  token_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** order by stddev_samp() on columns of table "token_activities_v2" */
export type TokenActivitiesV2StddevSampOrderBy = {
  event_index?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
  token_amount?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "token_activities_v2" */
export type TokenActivitiesV2StreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TokenActivitiesV2StreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TokenActivitiesV2StreamCursorValueInput = {
  after_value?: InputMaybe<Scalars["String"]["input"]>;
  before_value?: InputMaybe<Scalars["String"]["input"]>;
  entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
  event_account_address?: InputMaybe<Scalars["String"]["input"]>;
  event_index?: InputMaybe<Scalars["bigint"]["input"]>;
  from_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  to_address?: InputMaybe<Scalars["String"]["input"]>;
  token_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type TokenActivitiesV2SumFields = {
  event_index?: Maybe<Scalars["bigint"]["output"]>;
  property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
  token_amount?: Maybe<Scalars["numeric"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** order by sum() on columns of table "token_activities_v2" */
export type TokenActivitiesV2SumOrderBy = {
  event_index?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
  token_amount?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** update columns of table "token_activities_v2" */
export enum TokenActivitiesV2UpdateColumn {
  /** column name */
  AfterValue = "after_value",
  /** column name */
  BeforeValue = "before_value",
  /** column name */
  EntryFunctionIdStr = "entry_function_id_str",
  /** column name */
  EventAccountAddress = "event_account_address",
  /** column name */
  EventIndex = "event_index",
  /** column name */
  FromAddress = "from_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsFungibleV2 = "is_fungible_v2",
  /** column name */
  PropertyVersionV1 = "property_version_v1",
  /** column name */
  ToAddress = "to_address",
  /** column name */
  TokenAmount = "token_amount",
  /** column name */
  TokenDataId = "token_data_id",
  /** column name */
  TokenStandard = "token_standard",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  Type = "type",
}

export type TokenActivitiesV2Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TokenActivitiesV2IncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TokenActivitiesV2SetInput>;
  /** filter the rows which have to be updated */
  where: TokenActivitiesV2BoolExp;
};

/** aggregate var_pop on columns */
export type TokenActivitiesV2VarPopFields = {
  event_index?: Maybe<Scalars["Float"]["output"]>;
  property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  token_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** order by var_pop() on columns of table "token_activities_v2" */
export type TokenActivitiesV2VarPopOrderBy = {
  event_index?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
  token_amount?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** aggregate var_samp on columns */
export type TokenActivitiesV2VarSampFields = {
  event_index?: Maybe<Scalars["Float"]["output"]>;
  property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  token_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** order by var_samp() on columns of table "token_activities_v2" */
export type TokenActivitiesV2VarSampOrderBy = {
  event_index?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
  token_amount?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type TokenActivitiesV2VarianceFields = {
  event_index?: Maybe<Scalars["Float"]["output"]>;
  property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  token_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** order by variance() on columns of table "token_activities_v2" */
export type TokenActivitiesV2VarianceOrderBy = {
  event_index?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
  token_amount?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** aggregate var_pop on columns */
export type TokenActivitiesVarPopFields = {
  coin_amount?: Maybe<Scalars["Float"]["output"]>;
  event_creation_number?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
  token_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type TokenActivitiesVarSampFields = {
  coin_amount?: Maybe<Scalars["Float"]["output"]>;
  event_creation_number?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
  token_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type TokenActivitiesVarianceFields = {
  coin_amount?: Maybe<Scalars["Float"]["output"]>;
  event_creation_number?: Maybe<Scalars["Float"]["output"]>;
  event_index?: Maybe<Scalars["Float"]["output"]>;
  event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
  token_amount?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "token_datas" */
export type TokenDatas = {
  collection_data_id_hash: Scalars["String"]["output"];
  collection_name: Scalars["String"]["output"];
  creator_address: Scalars["String"]["output"];
  default_properties: Scalars["jsonb"]["output"];
  description: Scalars["String"]["output"];
  description_mutable: Scalars["Boolean"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  largest_property_version: Scalars["numeric"]["output"];
  maximum: Scalars["numeric"]["output"];
  maximum_mutable: Scalars["Boolean"]["output"];
  metadata_uri: Scalars["String"]["output"];
  name: Scalars["String"]["output"];
  payee_address: Scalars["String"]["output"];
  properties_mutable: Scalars["Boolean"]["output"];
  royalty_mutable: Scalars["Boolean"]["output"];
  royalty_points_denominator: Scalars["numeric"]["output"];
  royalty_points_numerator: Scalars["numeric"]["output"];
  supply: Scalars["numeric"]["output"];
  token_data_id_hash: Scalars["String"]["output"];
  transaction_timestamp: Scalars["timestamp"]["output"];
  transaction_version: Scalars["bigint"]["output"];
  uri_mutable: Scalars["Boolean"]["output"];
};

/** columns and relationships of "token_datas" */
export type TokenDatasDefaultPropertiesArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregated selection of "token_datas" */
export type TokenDatasAggregate = {
  aggregate?: Maybe<TokenDatasAggregateFields>;
  nodes: Array<TokenDatas>;
};

/** aggregate fields of "token_datas" */
export type TokenDatasAggregateFields = {
  avg?: Maybe<TokenDatasAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<TokenDatasMaxFields>;
  min?: Maybe<TokenDatasMinFields>;
  stddev?: Maybe<TokenDatasStddevFields>;
  stddev_pop?: Maybe<TokenDatasStddevPopFields>;
  stddev_samp?: Maybe<TokenDatasStddevSampFields>;
  sum?: Maybe<TokenDatasSumFields>;
  var_pop?: Maybe<TokenDatasVarPopFields>;
  var_samp?: Maybe<TokenDatasVarSampFields>;
  variance?: Maybe<TokenDatasVarianceFields>;
};

/** aggregate fields of "token_datas" */
export type TokenDatasAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TokenDatasSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type TokenDatasAppendInput = {
  default_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** aggregate avg on columns */
export type TokenDatasAvgFields = {
  largest_property_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "token_datas". All fields are combined with a logical 'AND'. */
export type TokenDatasBoolExp = {
  _and?: InputMaybe<Array<TokenDatasBoolExp>>;
  _not?: InputMaybe<TokenDatasBoolExp>;
  _or?: InputMaybe<Array<TokenDatasBoolExp>>;
  collection_data_id_hash?: InputMaybe<StringComparisonExp>;
  collection_name?: InputMaybe<StringComparisonExp>;
  creator_address?: InputMaybe<StringComparisonExp>;
  default_properties?: InputMaybe<JsonbComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  description_mutable?: InputMaybe<BooleanComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  largest_property_version?: InputMaybe<NumericComparisonExp>;
  maximum?: InputMaybe<NumericComparisonExp>;
  maximum_mutable?: InputMaybe<BooleanComparisonExp>;
  metadata_uri?: InputMaybe<StringComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  payee_address?: InputMaybe<StringComparisonExp>;
  properties_mutable?: InputMaybe<BooleanComparisonExp>;
  royalty_mutable?: InputMaybe<BooleanComparisonExp>;
  royalty_points_denominator?: InputMaybe<NumericComparisonExp>;
  royalty_points_numerator?: InputMaybe<NumericComparisonExp>;
  supply?: InputMaybe<NumericComparisonExp>;
  token_data_id_hash?: InputMaybe<StringComparisonExp>;
  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  uri_mutable?: InputMaybe<BooleanComparisonExp>;
};

/** unique or primary key constraints on table "token_datas" */
export enum TokenDatasConstraint {
  /** unique or primary key constraint on columns "token_data_id_hash", "transaction_version" */
  TokenDatasPkey = "token_datas_pkey",
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type TokenDatasDeleteAtPathInput = {
  default_properties?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type TokenDatasDeleteElemInput = {
  default_properties?: InputMaybe<Scalars["Int"]["input"]>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type TokenDatasDeleteKeyInput = {
  default_properties?: InputMaybe<Scalars["String"]["input"]>;
};

/** input type for incrementing numeric columns in table "token_datas" */
export type TokenDatasIncInput = {
  largest_property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
  royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "token_datas" */
export type TokenDatasInsertInput = {
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  default_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  largest_property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  payee_address?: InputMaybe<Scalars["String"]["input"]>;
  properties_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  royalty_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
  royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate max on columns */
export type TokenDatasMaxFields = {
  collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  description?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  largest_property_version?: Maybe<Scalars["numeric"]["output"]>;
  maximum?: Maybe<Scalars["numeric"]["output"]>;
  metadata_uri?: Maybe<Scalars["String"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  payee_address?: Maybe<Scalars["String"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["numeric"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["numeric"]["output"]>;
  supply?: Maybe<Scalars["numeric"]["output"]>;
  token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type TokenDatasMinFields = {
  collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  description?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  largest_property_version?: Maybe<Scalars["numeric"]["output"]>;
  maximum?: Maybe<Scalars["numeric"]["output"]>;
  metadata_uri?: Maybe<Scalars["String"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  payee_address?: Maybe<Scalars["String"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["numeric"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["numeric"]["output"]>;
  supply?: Maybe<Scalars["numeric"]["output"]>;
  token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "token_datas" */
export type TokenDatasMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<TokenDatas>;
};

/** on_conflict condition type for table "token_datas" */
export type TokenDatasOnConflict = {
  constraint: TokenDatasConstraint;
  update_columns?: Array<TokenDatasUpdateColumn>;
  where?: InputMaybe<TokenDatasBoolExp>;
};

/** Ordering options when selecting data from "token_datas". */
export type TokenDatasOrderBy = {
  collection_data_id_hash?: InputMaybe<OrderBy>;
  collection_name?: InputMaybe<OrderBy>;
  creator_address?: InputMaybe<OrderBy>;
  default_properties?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  description_mutable?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  largest_property_version?: InputMaybe<OrderBy>;
  maximum?: InputMaybe<OrderBy>;
  maximum_mutable?: InputMaybe<OrderBy>;
  metadata_uri?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  payee_address?: InputMaybe<OrderBy>;
  properties_mutable?: InputMaybe<OrderBy>;
  royalty_mutable?: InputMaybe<OrderBy>;
  royalty_points_denominator?: InputMaybe<OrderBy>;
  royalty_points_numerator?: InputMaybe<OrderBy>;
  supply?: InputMaybe<OrderBy>;
  token_data_id_hash?: InputMaybe<OrderBy>;
  transaction_timestamp?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  uri_mutable?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: token_datas */
export type TokenDatasPkColumnsInput = {
  token_data_id_hash: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type TokenDatasPrependInput = {
  default_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** select columns of table "token_datas" */
export enum TokenDatasSelectColumn {
  /** column name */
  CollectionDataIdHash = "collection_data_id_hash",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  DefaultProperties = "default_properties",
  /** column name */
  Description = "description",
  /** column name */
  DescriptionMutable = "description_mutable",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LargestPropertyVersion = "largest_property_version",
  /** column name */
  Maximum = "maximum",
  /** column name */
  MaximumMutable = "maximum_mutable",
  /** column name */
  MetadataUri = "metadata_uri",
  /** column name */
  Name = "name",
  /** column name */
  PayeeAddress = "payee_address",
  /** column name */
  PropertiesMutable = "properties_mutable",
  /** column name */
  RoyaltyMutable = "royalty_mutable",
  /** column name */
  RoyaltyPointsDenominator = "royalty_points_denominator",
  /** column name */
  RoyaltyPointsNumerator = "royalty_points_numerator",
  /** column name */
  Supply = "supply",
  /** column name */
  TokenDataIdHash = "token_data_id_hash",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  UriMutable = "uri_mutable",
}

/** input type for updating data in table "token_datas" */
export type TokenDatasSetInput = {
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  default_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  largest_property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  payee_address?: InputMaybe<Scalars["String"]["input"]>;
  properties_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  royalty_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
  royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate stddev on columns */
export type TokenDatasStddevFields = {
  largest_property_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type TokenDatasStddevPopFields = {
  largest_property_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type TokenDatasStddevSampFields = {
  largest_property_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "token_datas" */
export type TokenDatasStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TokenDatasStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TokenDatasStreamCursorValueInput = {
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  default_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  largest_property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  payee_address?: InputMaybe<Scalars["String"]["input"]>;
  properties_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  royalty_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
  royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
  royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate sum on columns */
export type TokenDatasSumFields = {
  largest_property_version?: Maybe<Scalars["numeric"]["output"]>;
  maximum?: Maybe<Scalars["numeric"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["numeric"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["numeric"]["output"]>;
  supply?: Maybe<Scalars["numeric"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "token_datas" */
export enum TokenDatasUpdateColumn {
  /** column name */
  CollectionDataIdHash = "collection_data_id_hash",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  DefaultProperties = "default_properties",
  /** column name */
  Description = "description",
  /** column name */
  DescriptionMutable = "description_mutable",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  LargestPropertyVersion = "largest_property_version",
  /** column name */
  Maximum = "maximum",
  /** column name */
  MaximumMutable = "maximum_mutable",
  /** column name */
  MetadataUri = "metadata_uri",
  /** column name */
  Name = "name",
  /** column name */
  PayeeAddress = "payee_address",
  /** column name */
  PropertiesMutable = "properties_mutable",
  /** column name */
  RoyaltyMutable = "royalty_mutable",
  /** column name */
  RoyaltyPointsDenominator = "royalty_points_denominator",
  /** column name */
  RoyaltyPointsNumerator = "royalty_points_numerator",
  /** column name */
  Supply = "supply",
  /** column name */
  TokenDataIdHash = "token_data_id_hash",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  UriMutable = "uri_mutable",
}

export type TokenDatasUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<TokenDatasAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<TokenDatasDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<TokenDatasDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<TokenDatasDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TokenDatasIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<TokenDatasPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TokenDatasSetInput>;
  /** filter the rows which have to be updated */
  where: TokenDatasBoolExp;
};

/** columns and relationships of "token_datas_v2" */
export type TokenDatasV2 = {
  collection_id: Scalars["String"]["output"];
  decimals?: Maybe<Scalars["bigint"]["output"]>;
  description: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  is_deleted_v2?: Maybe<Scalars["Boolean"]["output"]>;
  is_fungible_v2?: Maybe<Scalars["Boolean"]["output"]>;
  largest_property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
  maximum?: Maybe<Scalars["numeric"]["output"]>;
  supply?: Maybe<Scalars["numeric"]["output"]>;
  token_data_id: Scalars["String"]["output"];
  token_name: Scalars["String"]["output"];
  token_properties: Scalars["jsonb"]["output"];
  token_standard: Scalars["String"]["output"];
  token_uri: Scalars["String"]["output"];
  transaction_timestamp: Scalars["timestamp"]["output"];
  transaction_version: Scalars["bigint"]["output"];
  write_set_change_index: Scalars["bigint"]["output"];
};

/** columns and relationships of "token_datas_v2" */
export type TokenDatasV2TokenPropertiesArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregated selection of "token_datas_v2" */
export type TokenDatasV2Aggregate = {
  aggregate?: Maybe<TokenDatasV2AggregateFields>;
  nodes: Array<TokenDatasV2>;
};

/** aggregate fields of "token_datas_v2" */
export type TokenDatasV2AggregateFields = {
  avg?: Maybe<TokenDatasV2AvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<TokenDatasV2MaxFields>;
  min?: Maybe<TokenDatasV2MinFields>;
  stddev?: Maybe<TokenDatasV2StddevFields>;
  stddev_pop?: Maybe<TokenDatasV2StddevPopFields>;
  stddev_samp?: Maybe<TokenDatasV2StddevSampFields>;
  sum?: Maybe<TokenDatasV2SumFields>;
  var_pop?: Maybe<TokenDatasV2VarPopFields>;
  var_samp?: Maybe<TokenDatasV2VarSampFields>;
  variance?: Maybe<TokenDatasV2VarianceFields>;
};

/** aggregate fields of "token_datas_v2" */
export type TokenDatasV2AggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TokenDatasV2SelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type TokenDatasV2AppendInput = {
  token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** aggregate avg on columns */
export type TokenDatasV2AvgFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "token_datas_v2". All fields are combined with a logical 'AND'. */
export type TokenDatasV2BoolExp = {
  _and?: InputMaybe<Array<TokenDatasV2BoolExp>>;
  _not?: InputMaybe<TokenDatasV2BoolExp>;
  _or?: InputMaybe<Array<TokenDatasV2BoolExp>>;
  collection_id?: InputMaybe<StringComparisonExp>;
  decimals?: InputMaybe<BigintComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_deleted_v2?: InputMaybe<BooleanComparisonExp>;
  is_fungible_v2?: InputMaybe<BooleanComparisonExp>;
  largest_property_version_v1?: InputMaybe<NumericComparisonExp>;
  maximum?: InputMaybe<NumericComparisonExp>;
  supply?: InputMaybe<NumericComparisonExp>;
  token_data_id?: InputMaybe<StringComparisonExp>;
  token_name?: InputMaybe<StringComparisonExp>;
  token_properties?: InputMaybe<JsonbComparisonExp>;
  token_standard?: InputMaybe<StringComparisonExp>;
  token_uri?: InputMaybe<StringComparisonExp>;
  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  write_set_change_index?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "token_datas_v2" */
export enum TokenDatasV2Constraint {
  /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
  TokenDatasV2Pkey = "token_datas_v2_pkey",
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type TokenDatasV2DeleteAtPathInput = {
  token_properties?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type TokenDatasV2DeleteElemInput = {
  token_properties?: InputMaybe<Scalars["Int"]["input"]>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type TokenDatasV2DeleteKeyInput = {
  token_properties?: InputMaybe<Scalars["String"]["input"]>;
};

/** input type for incrementing numeric columns in table "token_datas_v2" */
export type TokenDatasV2IncInput = {
  decimals?: InputMaybe<Scalars["bigint"]["input"]>;
  largest_property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "token_datas_v2" */
export type TokenDatasV2InsertInput = {
  collection_id?: InputMaybe<Scalars["String"]["input"]>;
  decimals?: InputMaybe<Scalars["bigint"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  largest_property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  token_uri?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type TokenDatasV2MaxFields = {
  collection_id?: Maybe<Scalars["String"]["output"]>;
  decimals?: Maybe<Scalars["bigint"]["output"]>;
  description?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  largest_property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
  maximum?: Maybe<Scalars["numeric"]["output"]>;
  supply?: Maybe<Scalars["numeric"]["output"]>;
  token_data_id?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
  token_uri?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type TokenDatasV2MinFields = {
  collection_id?: Maybe<Scalars["String"]["output"]>;
  decimals?: Maybe<Scalars["bigint"]["output"]>;
  description?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  largest_property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
  maximum?: Maybe<Scalars["numeric"]["output"]>;
  supply?: Maybe<Scalars["numeric"]["output"]>;
  token_data_id?: Maybe<Scalars["String"]["output"]>;
  token_name?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
  token_uri?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "token_datas_v2" */
export type TokenDatasV2MutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<TokenDatasV2>;
};

/** on_conflict condition type for table "token_datas_v2" */
export type TokenDatasV2OnConflict = {
  constraint: TokenDatasV2Constraint;
  update_columns?: Array<TokenDatasV2UpdateColumn>;
  where?: InputMaybe<TokenDatasV2BoolExp>;
};

/** Ordering options when selecting data from "token_datas_v2". */
export type TokenDatasV2OrderBy = {
  collection_id?: InputMaybe<OrderBy>;
  decimals?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_deleted_v2?: InputMaybe<OrderBy>;
  is_fungible_v2?: InputMaybe<OrderBy>;
  largest_property_version_v1?: InputMaybe<OrderBy>;
  maximum?: InputMaybe<OrderBy>;
  supply?: InputMaybe<OrderBy>;
  token_data_id?: InputMaybe<OrderBy>;
  token_name?: InputMaybe<OrderBy>;
  token_properties?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
  token_uri?: InputMaybe<OrderBy>;
  transaction_timestamp?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  write_set_change_index?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: token_datas_v2 */
export type TokenDatasV2PkColumnsInput = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type TokenDatasV2PrependInput = {
  token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** select columns of table "token_datas_v2" */
export enum TokenDatasV2SelectColumn {
  /** column name */
  CollectionId = "collection_id",
  /** column name */
  Decimals = "decimals",
  /** column name */
  Description = "description",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeletedV2 = "is_deleted_v2",
  /** column name */
  IsFungibleV2 = "is_fungible_v2",
  /** column name */
  LargestPropertyVersionV1 = "largest_property_version_v1",
  /** column name */
  Maximum = "maximum",
  /** column name */
  Supply = "supply",
  /** column name */
  TokenDataId = "token_data_id",
  /** column name */
  TokenName = "token_name",
  /** column name */
  TokenProperties = "token_properties",
  /** column name */
  TokenStandard = "token_standard",
  /** column name */
  TokenUri = "token_uri",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

/** input type for updating data in table "token_datas_v2" */
export type TokenDatasV2SetInput = {
  collection_id?: InputMaybe<Scalars["String"]["input"]>;
  decimals?: InputMaybe<Scalars["bigint"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  largest_property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  token_uri?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type TokenDatasV2StddevFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type TokenDatasV2StddevPopFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type TokenDatasV2StddevSampFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "token_datas_v2" */
export type TokenDatasV2StreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TokenDatasV2StreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TokenDatasV2StreamCursorValueInput = {
  collection_id?: InputMaybe<Scalars["String"]["input"]>;
  decimals?: InputMaybe<Scalars["bigint"]["input"]>;
  description?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_deleted_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  largest_property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  maximum?: InputMaybe<Scalars["numeric"]["input"]>;
  supply?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
  token_name?: InputMaybe<Scalars["String"]["input"]>;
  token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  token_uri?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type TokenDatasV2SumFields = {
  decimals?: Maybe<Scalars["bigint"]["output"]>;
  largest_property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
  maximum?: Maybe<Scalars["numeric"]["output"]>;
  supply?: Maybe<Scalars["numeric"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "token_datas_v2" */
export enum TokenDatasV2UpdateColumn {
  /** column name */
  CollectionId = "collection_id",
  /** column name */
  Decimals = "decimals",
  /** column name */
  Description = "description",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsDeletedV2 = "is_deleted_v2",
  /** column name */
  IsFungibleV2 = "is_fungible_v2",
  /** column name */
  LargestPropertyVersionV1 = "largest_property_version_v1",
  /** column name */
  Maximum = "maximum",
  /** column name */
  Supply = "supply",
  /** column name */
  TokenDataId = "token_data_id",
  /** column name */
  TokenName = "token_name",
  /** column name */
  TokenProperties = "token_properties",
  /** column name */
  TokenStandard = "token_standard",
  /** column name */
  TokenUri = "token_uri",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

export type TokenDatasV2Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<TokenDatasV2AppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<TokenDatasV2DeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<TokenDatasV2DeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<TokenDatasV2DeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TokenDatasV2IncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<TokenDatasV2PrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TokenDatasV2SetInput>;
  /** filter the rows which have to be updated */
  where: TokenDatasV2BoolExp;
};

/** aggregate var_pop on columns */
export type TokenDatasV2VarPopFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type TokenDatasV2VarSampFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type TokenDatasV2VarianceFields = {
  decimals?: Maybe<Scalars["Float"]["output"]>;
  largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_pop on columns */
export type TokenDatasVarPopFields = {
  largest_property_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type TokenDatasVarSampFields = {
  largest_property_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type TokenDatasVarianceFields = {
  largest_property_version?: Maybe<Scalars["Float"]["output"]>;
  maximum?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
  royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
  supply?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "token_ownerships" */
export type TokenOwnerships = {
  amount: Scalars["numeric"]["output"];
  collection_data_id_hash: Scalars["String"]["output"];
  collection_name: Scalars["String"]["output"];
  creator_address: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  name: Scalars["String"]["output"];
  owner_address?: Maybe<Scalars["String"]["output"]>;
  property_version: Scalars["numeric"]["output"];
  table_handle: Scalars["String"]["output"];
  table_type?: Maybe<Scalars["String"]["output"]>;
  token_data_id_hash: Scalars["String"]["output"];
  transaction_timestamp: Scalars["timestamp"]["output"];
  transaction_version: Scalars["bigint"]["output"];
};

/** aggregated selection of "token_ownerships" */
export type TokenOwnershipsAggregate = {
  aggregate?: Maybe<TokenOwnershipsAggregateFields>;
  nodes: Array<TokenOwnerships>;
};

/** aggregate fields of "token_ownerships" */
export type TokenOwnershipsAggregateFields = {
  avg?: Maybe<TokenOwnershipsAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<TokenOwnershipsMaxFields>;
  min?: Maybe<TokenOwnershipsMinFields>;
  stddev?: Maybe<TokenOwnershipsStddevFields>;
  stddev_pop?: Maybe<TokenOwnershipsStddevPopFields>;
  stddev_samp?: Maybe<TokenOwnershipsStddevSampFields>;
  sum?: Maybe<TokenOwnershipsSumFields>;
  var_pop?: Maybe<TokenOwnershipsVarPopFields>;
  var_samp?: Maybe<TokenOwnershipsVarSampFields>;
  variance?: Maybe<TokenOwnershipsVarianceFields>;
};

/** aggregate fields of "token_ownerships" */
export type TokenOwnershipsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TokenOwnershipsSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type TokenOwnershipsAvgFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "token_ownerships". All fields are combined with a logical 'AND'. */
export type TokenOwnershipsBoolExp = {
  _and?: InputMaybe<Array<TokenOwnershipsBoolExp>>;
  _not?: InputMaybe<TokenOwnershipsBoolExp>;
  _or?: InputMaybe<Array<TokenOwnershipsBoolExp>>;
  amount?: InputMaybe<NumericComparisonExp>;
  collection_data_id_hash?: InputMaybe<StringComparisonExp>;
  collection_name?: InputMaybe<StringComparisonExp>;
  creator_address?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  owner_address?: InputMaybe<StringComparisonExp>;
  property_version?: InputMaybe<NumericComparisonExp>;
  table_handle?: InputMaybe<StringComparisonExp>;
  table_type?: InputMaybe<StringComparisonExp>;
  token_data_id_hash?: InputMaybe<StringComparisonExp>;
  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "token_ownerships" */
export enum TokenOwnershipsConstraint {
  /** unique or primary key constraint on columns "property_version", "table_handle", "token_data_id_hash", "transaction_version" */
  TokenOwnershipsPkey = "token_ownerships_pkey",
}

/** input type for incrementing numeric columns in table "token_ownerships" */
export type TokenOwnershipsIncInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "token_ownerships" */
export type TokenOwnershipsInsertInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  table_type?: InputMaybe<Scalars["String"]["input"]>;
  token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type TokenOwnershipsMaxFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  property_version?: Maybe<Scalars["numeric"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
  table_type?: Maybe<Scalars["String"]["output"]>;
  token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type TokenOwnershipsMinFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  property_version?: Maybe<Scalars["numeric"]["output"]>;
  table_handle?: Maybe<Scalars["String"]["output"]>;
  table_type?: Maybe<Scalars["String"]["output"]>;
  token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "token_ownerships" */
export type TokenOwnershipsMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<TokenOwnerships>;
};

/** on_conflict condition type for table "token_ownerships" */
export type TokenOwnershipsOnConflict = {
  constraint: TokenOwnershipsConstraint;
  update_columns?: Array<TokenOwnershipsUpdateColumn>;
  where?: InputMaybe<TokenOwnershipsBoolExp>;
};

/** Ordering options when selecting data from "token_ownerships". */
export type TokenOwnershipsOrderBy = {
  amount?: InputMaybe<OrderBy>;
  collection_data_id_hash?: InputMaybe<OrderBy>;
  collection_name?: InputMaybe<OrderBy>;
  creator_address?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  owner_address?: InputMaybe<OrderBy>;
  property_version?: InputMaybe<OrderBy>;
  table_handle?: InputMaybe<OrderBy>;
  table_type?: InputMaybe<OrderBy>;
  token_data_id_hash?: InputMaybe<OrderBy>;
  transaction_timestamp?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: token_ownerships */
export type TokenOwnershipsPkColumnsInput = {
  property_version: Scalars["numeric"]["input"];
  table_handle: Scalars["String"]["input"];
  token_data_id_hash: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** select columns of table "token_ownerships" */
export enum TokenOwnershipsSelectColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  CollectionDataIdHash = "collection_data_id_hash",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  Name = "name",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  PropertyVersion = "property_version",
  /** column name */
  TableHandle = "table_handle",
  /** column name */
  TableType = "table_type",
  /** column name */
  TokenDataIdHash = "token_data_id_hash",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
}

/** input type for updating data in table "token_ownerships" */
export type TokenOwnershipsSetInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  table_type?: InputMaybe<Scalars["String"]["input"]>;
  token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type TokenOwnershipsStddevFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type TokenOwnershipsStddevPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type TokenOwnershipsStddevSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "token_ownerships" */
export type TokenOwnershipsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TokenOwnershipsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TokenOwnershipsStreamCursorValueInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  table_handle?: InputMaybe<Scalars["String"]["input"]>;
  table_type?: InputMaybe<Scalars["String"]["input"]>;
  token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type TokenOwnershipsSumFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  property_version?: Maybe<Scalars["numeric"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "token_ownerships" */
export enum TokenOwnershipsUpdateColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  CollectionDataIdHash = "collection_data_id_hash",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  Name = "name",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  PropertyVersion = "property_version",
  /** column name */
  TableHandle = "table_handle",
  /** column name */
  TableType = "table_type",
  /** column name */
  TokenDataIdHash = "token_data_id_hash",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
}

export type TokenOwnershipsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TokenOwnershipsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TokenOwnershipsSetInput>;
  /** filter the rows which have to be updated */
  where: TokenOwnershipsBoolExp;
};

/** columns and relationships of "token_ownerships_v2" */
export type TokenOwnershipsV2 = {
  amount: Scalars["numeric"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  is_fungible_v2?: Maybe<Scalars["Boolean"]["output"]>;
  is_soulbound_v2?: Maybe<Scalars["Boolean"]["output"]>;
  non_transferrable_by_owner?: Maybe<Scalars["Boolean"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  property_version_v1: Scalars["numeric"]["output"];
  storage_id: Scalars["String"]["output"];
  table_type_v1?: Maybe<Scalars["String"]["output"]>;
  token_data_id: Scalars["String"]["output"];
  token_properties_mutated_v1?: Maybe<Scalars["jsonb"]["output"]>;
  token_standard: Scalars["String"]["output"];
  transaction_timestamp: Scalars["timestamp"]["output"];
  transaction_version: Scalars["bigint"]["output"];
  write_set_change_index: Scalars["bigint"]["output"];
};

/** columns and relationships of "token_ownerships_v2" */
export type TokenOwnershipsV2TokenPropertiesMutatedV1Args = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregated selection of "token_ownerships_v2" */
export type TokenOwnershipsV2Aggregate = {
  aggregate?: Maybe<TokenOwnershipsV2AggregateFields>;
  nodes: Array<TokenOwnershipsV2>;
};

/** aggregate fields of "token_ownerships_v2" */
export type TokenOwnershipsV2AggregateFields = {
  avg?: Maybe<TokenOwnershipsV2AvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<TokenOwnershipsV2MaxFields>;
  min?: Maybe<TokenOwnershipsV2MinFields>;
  stddev?: Maybe<TokenOwnershipsV2StddevFields>;
  stddev_pop?: Maybe<TokenOwnershipsV2StddevPopFields>;
  stddev_samp?: Maybe<TokenOwnershipsV2StddevSampFields>;
  sum?: Maybe<TokenOwnershipsV2SumFields>;
  var_pop?: Maybe<TokenOwnershipsV2VarPopFields>;
  var_samp?: Maybe<TokenOwnershipsV2VarSampFields>;
  variance?: Maybe<TokenOwnershipsV2VarianceFields>;
};

/** aggregate fields of "token_ownerships_v2" */
export type TokenOwnershipsV2AggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TokenOwnershipsV2SelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type TokenOwnershipsV2AppendInput = {
  token_properties_mutated_v1?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** aggregate avg on columns */
export type TokenOwnershipsV2AvgFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "token_ownerships_v2". All fields are combined with a logical 'AND'. */
export type TokenOwnershipsV2BoolExp = {
  _and?: InputMaybe<Array<TokenOwnershipsV2BoolExp>>;
  _not?: InputMaybe<TokenOwnershipsV2BoolExp>;
  _or?: InputMaybe<Array<TokenOwnershipsV2BoolExp>>;
  amount?: InputMaybe<NumericComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  is_fungible_v2?: InputMaybe<BooleanComparisonExp>;
  is_soulbound_v2?: InputMaybe<BooleanComparisonExp>;
  non_transferrable_by_owner?: InputMaybe<BooleanComparisonExp>;
  owner_address?: InputMaybe<StringComparisonExp>;
  property_version_v1?: InputMaybe<NumericComparisonExp>;
  storage_id?: InputMaybe<StringComparisonExp>;
  table_type_v1?: InputMaybe<StringComparisonExp>;
  token_data_id?: InputMaybe<StringComparisonExp>;
  token_properties_mutated_v1?: InputMaybe<JsonbComparisonExp>;
  token_standard?: InputMaybe<StringComparisonExp>;
  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
  write_set_change_index?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "token_ownerships_v2" */
export enum TokenOwnershipsV2Constraint {
  /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
  TokenOwnershipsV2Pkey = "token_ownerships_v2_pkey",
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type TokenOwnershipsV2DeleteAtPathInput = {
  token_properties_mutated_v1?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type TokenOwnershipsV2DeleteElemInput = {
  token_properties_mutated_v1?: InputMaybe<Scalars["Int"]["input"]>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type TokenOwnershipsV2DeleteKeyInput = {
  token_properties_mutated_v1?: InputMaybe<Scalars["String"]["input"]>;
};

/** input type for incrementing numeric columns in table "token_ownerships_v2" */
export type TokenOwnershipsV2IncInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "token_ownerships_v2" */
export type TokenOwnershipsV2InsertInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_soulbound_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  non_transferrable_by_owner?: InputMaybe<Scalars["Boolean"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  storage_id?: InputMaybe<Scalars["String"]["input"]>;
  table_type_v1?: InputMaybe<Scalars["String"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
  token_properties_mutated_v1?: InputMaybe<Scalars["jsonb"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type TokenOwnershipsV2MaxFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
  storage_id?: Maybe<Scalars["String"]["output"]>;
  table_type_v1?: Maybe<Scalars["String"]["output"]>;
  token_data_id?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type TokenOwnershipsV2MinFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  owner_address?: Maybe<Scalars["String"]["output"]>;
  property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
  storage_id?: Maybe<Scalars["String"]["output"]>;
  table_type_v1?: Maybe<Scalars["String"]["output"]>;
  token_data_id?: Maybe<Scalars["String"]["output"]>;
  token_standard?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "token_ownerships_v2" */
export type TokenOwnershipsV2MutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<TokenOwnershipsV2>;
};

/** on_conflict condition type for table "token_ownerships_v2" */
export type TokenOwnershipsV2OnConflict = {
  constraint: TokenOwnershipsV2Constraint;
  update_columns?: Array<TokenOwnershipsV2UpdateColumn>;
  where?: InputMaybe<TokenOwnershipsV2BoolExp>;
};

/** Ordering options when selecting data from "token_ownerships_v2". */
export type TokenOwnershipsV2OrderBy = {
  amount?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  is_fungible_v2?: InputMaybe<OrderBy>;
  is_soulbound_v2?: InputMaybe<OrderBy>;
  non_transferrable_by_owner?: InputMaybe<OrderBy>;
  owner_address?: InputMaybe<OrderBy>;
  property_version_v1?: InputMaybe<OrderBy>;
  storage_id?: InputMaybe<OrderBy>;
  table_type_v1?: InputMaybe<OrderBy>;
  token_data_id?: InputMaybe<OrderBy>;
  token_properties_mutated_v1?: InputMaybe<OrderBy>;
  token_standard?: InputMaybe<OrderBy>;
  transaction_timestamp?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
  write_set_change_index?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: token_ownerships_v2 */
export type TokenOwnershipsV2PkColumnsInput = {
  transaction_version: Scalars["bigint"]["input"];
  write_set_change_index: Scalars["bigint"]["input"];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type TokenOwnershipsV2PrependInput = {
  token_properties_mutated_v1?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** select columns of table "token_ownerships_v2" */
export enum TokenOwnershipsV2SelectColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsFungibleV2 = "is_fungible_v2",
  /** column name */
  IsSoulboundV2 = "is_soulbound_v2",
  /** column name */
  NonTransferrableByOwner = "non_transferrable_by_owner",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  PropertyVersionV1 = "property_version_v1",
  /** column name */
  StorageId = "storage_id",
  /** column name */
  TableTypeV1 = "table_type_v1",
  /** column name */
  TokenDataId = "token_data_id",
  /** column name */
  TokenPropertiesMutatedV1 = "token_properties_mutated_v1",
  /** column name */
  TokenStandard = "token_standard",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

/** input type for updating data in table "token_ownerships_v2" */
export type TokenOwnershipsV2SetInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_soulbound_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  non_transferrable_by_owner?: InputMaybe<Scalars["Boolean"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  storage_id?: InputMaybe<Scalars["String"]["input"]>;
  table_type_v1?: InputMaybe<Scalars["String"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
  token_properties_mutated_v1?: InputMaybe<Scalars["jsonb"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type TokenOwnershipsV2StddevFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type TokenOwnershipsV2StddevPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type TokenOwnershipsV2StddevSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "token_ownerships_v2" */
export type TokenOwnershipsV2StreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TokenOwnershipsV2StreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TokenOwnershipsV2StreamCursorValueInput = {
  amount?: InputMaybe<Scalars["numeric"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  is_soulbound_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
  non_transferrable_by_owner?: InputMaybe<Scalars["Boolean"]["input"]>;
  owner_address?: InputMaybe<Scalars["String"]["input"]>;
  property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
  storage_id?: InputMaybe<Scalars["String"]["input"]>;
  table_type_v1?: InputMaybe<Scalars["String"]["input"]>;
  token_data_id?: InputMaybe<Scalars["String"]["input"]>;
  token_properties_mutated_v1?: InputMaybe<Scalars["jsonb"]["input"]>;
  token_standard?: InputMaybe<Scalars["String"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
  write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type TokenOwnershipsV2SumFields = {
  amount?: Maybe<Scalars["numeric"]["output"]>;
  property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
  write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "token_ownerships_v2" */
export enum TokenOwnershipsV2UpdateColumn {
  /** column name */
  Amount = "amount",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  IsFungibleV2 = "is_fungible_v2",
  /** column name */
  IsSoulboundV2 = "is_soulbound_v2",
  /** column name */
  NonTransferrableByOwner = "non_transferrable_by_owner",
  /** column name */
  OwnerAddress = "owner_address",
  /** column name */
  PropertyVersionV1 = "property_version_v1",
  /** column name */
  StorageId = "storage_id",
  /** column name */
  TableTypeV1 = "table_type_v1",
  /** column name */
  TokenDataId = "token_data_id",
  /** column name */
  TokenPropertiesMutatedV1 = "token_properties_mutated_v1",
  /** column name */
  TokenStandard = "token_standard",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
  /** column name */
  WriteSetChangeIndex = "write_set_change_index",
}

export type TokenOwnershipsV2Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<TokenOwnershipsV2AppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<TokenOwnershipsV2DeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<TokenOwnershipsV2DeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<TokenOwnershipsV2DeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TokenOwnershipsV2IncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<TokenOwnershipsV2PrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TokenOwnershipsV2SetInput>;
  /** filter the rows which have to be updated */
  where: TokenOwnershipsV2BoolExp;
};

/** aggregate var_pop on columns */
export type TokenOwnershipsV2VarPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type TokenOwnershipsV2VarSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type TokenOwnershipsV2VarianceFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  property_version_v1?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
  write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_pop on columns */
export type TokenOwnershipsVarPopFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type TokenOwnershipsVarSampFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type TokenOwnershipsVarianceFields = {
  amount?: Maybe<Scalars["Float"]["output"]>;
  property_version?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "tokens" */
export type Tokens = {
  collection_data_id_hash: Scalars["String"]["output"];
  collection_name: Scalars["String"]["output"];
  creator_address: Scalars["String"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  name: Scalars["String"]["output"];
  property_version: Scalars["numeric"]["output"];
  token_data_id_hash: Scalars["String"]["output"];
  token_properties: Scalars["jsonb"]["output"];
  transaction_timestamp: Scalars["timestamp"]["output"];
  transaction_version: Scalars["bigint"]["output"];
};

/** columns and relationships of "tokens" */
export type TokensTokenPropertiesArgs = {
  path?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregated selection of "tokens" */
export type TokensAggregate = {
  aggregate?: Maybe<TokensAggregateFields>;
  nodes: Array<Tokens>;
};

/** aggregate fields of "tokens" */
export type TokensAggregateFields = {
  avg?: Maybe<TokensAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<TokensMaxFields>;
  min?: Maybe<TokensMinFields>;
  stddev?: Maybe<TokensStddevFields>;
  stddev_pop?: Maybe<TokensStddevPopFields>;
  stddev_samp?: Maybe<TokensStddevSampFields>;
  sum?: Maybe<TokensSumFields>;
  var_pop?: Maybe<TokensVarPopFields>;
  var_samp?: Maybe<TokensVarSampFields>;
  variance?: Maybe<TokensVarianceFields>;
};

/** aggregate fields of "tokens" */
export type TokensAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TokensSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type TokensAppendInput = {
  token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** aggregate avg on columns */
export type TokensAvgFields = {
  property_version?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "tokens". All fields are combined with a logical 'AND'. */
export type TokensBoolExp = {
  _and?: InputMaybe<Array<TokensBoolExp>>;
  _not?: InputMaybe<TokensBoolExp>;
  _or?: InputMaybe<Array<TokensBoolExp>>;
  collection_data_id_hash?: InputMaybe<StringComparisonExp>;
  collection_name?: InputMaybe<StringComparisonExp>;
  creator_address?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  property_version?: InputMaybe<NumericComparisonExp>;
  token_data_id_hash?: InputMaybe<StringComparisonExp>;
  token_properties?: InputMaybe<JsonbComparisonExp>;
  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "tokens" */
export enum TokensConstraint {
  /** unique or primary key constraint on columns "property_version", "token_data_id_hash", "transaction_version" */
  TokensPkey = "tokens_pkey",
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type TokensDeleteAtPathInput = {
  token_properties?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type TokensDeleteElemInput = {
  token_properties?: InputMaybe<Scalars["Int"]["input"]>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type TokensDeleteKeyInput = {
  token_properties?: InputMaybe<Scalars["String"]["input"]>;
};

/** input type for incrementing numeric columns in table "tokens" */
export type TokensIncInput = {
  property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "tokens" */
export type TokensInsertInput = {
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type TokensMaxFields = {
  collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  property_version?: Maybe<Scalars["numeric"]["output"]>;
  token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type TokensMinFields = {
  collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  collection_name?: Maybe<Scalars["String"]["output"]>;
  creator_address?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  name?: Maybe<Scalars["String"]["output"]>;
  property_version?: Maybe<Scalars["numeric"]["output"]>;
  token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
  transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "tokens" */
export type TokensMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<Tokens>;
};

/** on_conflict condition type for table "tokens" */
export type TokensOnConflict = {
  constraint: TokensConstraint;
  update_columns?: Array<TokensUpdateColumn>;
  where?: InputMaybe<TokensBoolExp>;
};

/** Ordering options when selecting data from "tokens". */
export type TokensOrderBy = {
  collection_data_id_hash?: InputMaybe<OrderBy>;
  collection_name?: InputMaybe<OrderBy>;
  creator_address?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  property_version?: InputMaybe<OrderBy>;
  token_data_id_hash?: InputMaybe<OrderBy>;
  token_properties?: InputMaybe<OrderBy>;
  transaction_timestamp?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: tokens */
export type TokensPkColumnsInput = {
  property_version: Scalars["numeric"]["input"];
  token_data_id_hash: Scalars["String"]["input"];
  transaction_version: Scalars["bigint"]["input"];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type TokensPrependInput = {
  token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};

/** select columns of table "tokens" */
export enum TokensSelectColumn {
  /** column name */
  CollectionDataIdHash = "collection_data_id_hash",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  Name = "name",
  /** column name */
  PropertyVersion = "property_version",
  /** column name */
  TokenDataIdHash = "token_data_id_hash",
  /** column name */
  TokenProperties = "token_properties",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
}

/** input type for updating data in table "tokens" */
export type TokensSetInput = {
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type TokensStddevFields = {
  property_version?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type TokensStddevPopFields = {
  property_version?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type TokensStddevSampFields = {
  property_version?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "tokens" */
export type TokensStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TokensStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TokensStreamCursorValueInput = {
  collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  collection_name?: InputMaybe<Scalars["String"]["input"]>;
  creator_address?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  name?: InputMaybe<Scalars["String"]["input"]>;
  property_version?: InputMaybe<Scalars["numeric"]["input"]>;
  token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
  token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
  transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type TokensSumFields = {
  property_version?: Maybe<Scalars["numeric"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "tokens" */
export enum TokensUpdateColumn {
  /** column name */
  CollectionDataIdHash = "collection_data_id_hash",
  /** column name */
  CollectionName = "collection_name",
  /** column name */
  CreatorAddress = "creator_address",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  Name = "name",
  /** column name */
  PropertyVersion = "property_version",
  /** column name */
  TokenDataIdHash = "token_data_id_hash",
  /** column name */
  TokenProperties = "token_properties",
  /** column name */
  TransactionTimestamp = "transaction_timestamp",
  /** column name */
  TransactionVersion = "transaction_version",
}

export type TokensUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<TokensAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<TokensDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<TokensDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<TokensDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TokensIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<TokensPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TokensSetInput>;
  /** filter the rows which have to be updated */
  where: TokensBoolExp;
};

/** aggregate var_pop on columns */
export type TokensVarPopFields = {
  property_version?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type TokensVarSampFields = {
  property_version?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type TokensVarianceFields = {
  property_version?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "transaction_size_info" */
export type TransactionSizeInfo = {
  inserted_at: Scalars["timestamp"]["output"];
  size_bytes: Scalars["bigint"]["output"];
  transaction_version: Scalars["bigint"]["output"];
};

/** aggregated selection of "transaction_size_info" */
export type TransactionSizeInfoAggregate = {
  aggregate?: Maybe<TransactionSizeInfoAggregateFields>;
  nodes: Array<TransactionSizeInfo>;
};

/** aggregate fields of "transaction_size_info" */
export type TransactionSizeInfoAggregateFields = {
  avg?: Maybe<TransactionSizeInfoAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<TransactionSizeInfoMaxFields>;
  min?: Maybe<TransactionSizeInfoMinFields>;
  stddev?: Maybe<TransactionSizeInfoStddevFields>;
  stddev_pop?: Maybe<TransactionSizeInfoStddevPopFields>;
  stddev_samp?: Maybe<TransactionSizeInfoStddevSampFields>;
  sum?: Maybe<TransactionSizeInfoSumFields>;
  var_pop?: Maybe<TransactionSizeInfoVarPopFields>;
  var_samp?: Maybe<TransactionSizeInfoVarSampFields>;
  variance?: Maybe<TransactionSizeInfoVarianceFields>;
};

/** aggregate fields of "transaction_size_info" */
export type TransactionSizeInfoAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TransactionSizeInfoSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type TransactionSizeInfoAvgFields = {
  size_bytes?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "transaction_size_info". All fields are combined with a logical 'AND'. */
export type TransactionSizeInfoBoolExp = {
  _and?: InputMaybe<Array<TransactionSizeInfoBoolExp>>;
  _not?: InputMaybe<TransactionSizeInfoBoolExp>;
  _or?: InputMaybe<Array<TransactionSizeInfoBoolExp>>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  size_bytes?: InputMaybe<BigintComparisonExp>;
  transaction_version?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "transaction_size_info" */
export enum TransactionSizeInfoConstraint {
  /** unique or primary key constraint on columns "transaction_version" */
  TransactionSizeInfoPkey = "transaction_size_info_pkey",
}

/** input type for incrementing numeric columns in table "transaction_size_info" */
export type TransactionSizeInfoIncInput = {
  size_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "transaction_size_info" */
export type TransactionSizeInfoInsertInput = {
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  size_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type TransactionSizeInfoMaxFields = {
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  size_bytes?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type TransactionSizeInfoMinFields = {
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  size_bytes?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "transaction_size_info" */
export type TransactionSizeInfoMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<TransactionSizeInfo>;
};

/** on_conflict condition type for table "transaction_size_info" */
export type TransactionSizeInfoOnConflict = {
  constraint: TransactionSizeInfoConstraint;
  update_columns?: Array<TransactionSizeInfoUpdateColumn>;
  where?: InputMaybe<TransactionSizeInfoBoolExp>;
};

/** Ordering options when selecting data from "transaction_size_info". */
export type TransactionSizeInfoOrderBy = {
  inserted_at?: InputMaybe<OrderBy>;
  size_bytes?: InputMaybe<OrderBy>;
  transaction_version?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: transaction_size_info */
export type TransactionSizeInfoPkColumnsInput = {
  transaction_version: Scalars["bigint"]["input"];
};

/** select columns of table "transaction_size_info" */
export enum TransactionSizeInfoSelectColumn {
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  SizeBytes = "size_bytes",
  /** column name */
  TransactionVersion = "transaction_version",
}

/** input type for updating data in table "transaction_size_info" */
export type TransactionSizeInfoSetInput = {
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  size_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type TransactionSizeInfoStddevFields = {
  size_bytes?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type TransactionSizeInfoStddevPopFields = {
  size_bytes?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type TransactionSizeInfoStddevSampFields = {
  size_bytes?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "transaction_size_info" */
export type TransactionSizeInfoStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TransactionSizeInfoStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TransactionSizeInfoStreamCursorValueInput = {
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  size_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
  transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type TransactionSizeInfoSumFields = {
  size_bytes?: Maybe<Scalars["bigint"]["output"]>;
  transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "transaction_size_info" */
export enum TransactionSizeInfoUpdateColumn {
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  SizeBytes = "size_bytes",
  /** column name */
  TransactionVersion = "transaction_version",
}

export type TransactionSizeInfoUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TransactionSizeInfoIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TransactionSizeInfoSetInput>;
  /** filter the rows which have to be updated */
  where: TransactionSizeInfoBoolExp;
};

/** aggregate var_pop on columns */
export type TransactionSizeInfoVarPopFields = {
  size_bytes?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type TransactionSizeInfoVarSampFields = {
  size_bytes?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type TransactionSizeInfoVarianceFields = {
  size_bytes?: Maybe<Scalars["Float"]["output"]>;
  transaction_version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "transactions_view" */
export type TransactionsView = {
  accumulator_root_hash?: Maybe<Scalars["String"]["output"]>;
  block_height?: Maybe<Scalars["bigint"]["output"]>;
  event_root_hash?: Maybe<Scalars["String"]["output"]>;
  gas_used?: Maybe<Scalars["numeric"]["output"]>;
  hash?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  json_payload?: Maybe<Scalars["String"]["output"]>;
  num_events?: Maybe<Scalars["bigint"]["output"]>;
  num_write_set_changes?: Maybe<Scalars["bigint"]["output"]>;
  state_change_hash?: Maybe<Scalars["String"]["output"]>;
  state_checkpoint_hash?: Maybe<Scalars["String"]["output"]>;
  success?: Maybe<Scalars["Boolean"]["output"]>;
  type?: Maybe<Scalars["String"]["output"]>;
  version?: Maybe<Scalars["bigint"]["output"]>;
  vm_status?: Maybe<Scalars["String"]["output"]>;
};

/** aggregated selection of "transactions_view" */
export type TransactionsViewAggregate = {
  aggregate?: Maybe<TransactionsViewAggregateFields>;
  nodes: Array<TransactionsView>;
};

/** aggregate fields of "transactions_view" */
export type TransactionsViewAggregateFields = {
  avg?: Maybe<TransactionsViewAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<TransactionsViewMaxFields>;
  min?: Maybe<TransactionsViewMinFields>;
  stddev?: Maybe<TransactionsViewStddevFields>;
  stddev_pop?: Maybe<TransactionsViewStddevPopFields>;
  stddev_samp?: Maybe<TransactionsViewStddevSampFields>;
  sum?: Maybe<TransactionsViewSumFields>;
  var_pop?: Maybe<TransactionsViewVarPopFields>;
  var_samp?: Maybe<TransactionsViewVarSampFields>;
  variance?: Maybe<TransactionsViewVarianceFields>;
};

/** aggregate fields of "transactions_view" */
export type TransactionsViewAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TransactionsViewSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type TransactionsViewAvgFields = {
  block_height?: Maybe<Scalars["Float"]["output"]>;
  gas_used?: Maybe<Scalars["Float"]["output"]>;
  num_events?: Maybe<Scalars["Float"]["output"]>;
  num_write_set_changes?: Maybe<Scalars["Float"]["output"]>;
  version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "transactions_view". All fields are combined with a logical 'AND'. */
export type TransactionsViewBoolExp = {
  _and?: InputMaybe<Array<TransactionsViewBoolExp>>;
  _not?: InputMaybe<TransactionsViewBoolExp>;
  _or?: InputMaybe<Array<TransactionsViewBoolExp>>;
  accumulator_root_hash?: InputMaybe<StringComparisonExp>;
  block_height?: InputMaybe<BigintComparisonExp>;
  event_root_hash?: InputMaybe<StringComparisonExp>;
  gas_used?: InputMaybe<NumericComparisonExp>;
  hash?: InputMaybe<StringComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  json_payload?: InputMaybe<StringComparisonExp>;
  num_events?: InputMaybe<BigintComparisonExp>;
  num_write_set_changes?: InputMaybe<BigintComparisonExp>;
  state_change_hash?: InputMaybe<StringComparisonExp>;
  state_checkpoint_hash?: InputMaybe<StringComparisonExp>;
  success?: InputMaybe<BooleanComparisonExp>;
  type?: InputMaybe<StringComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
  vm_status?: InputMaybe<StringComparisonExp>;
};

/** input type for incrementing numeric columns in table "transactions_view" */
export type TransactionsViewIncInput = {
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  gas_used?: InputMaybe<Scalars["numeric"]["input"]>;
  num_events?: InputMaybe<Scalars["bigint"]["input"]>;
  num_write_set_changes?: InputMaybe<Scalars["bigint"]["input"]>;
  version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "transactions_view" */
export type TransactionsViewInsertInput = {
  accumulator_root_hash?: InputMaybe<Scalars["String"]["input"]>;
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  event_root_hash?: InputMaybe<Scalars["String"]["input"]>;
  gas_used?: InputMaybe<Scalars["numeric"]["input"]>;
  hash?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  json_payload?: InputMaybe<Scalars["String"]["input"]>;
  num_events?: InputMaybe<Scalars["bigint"]["input"]>;
  num_write_set_changes?: InputMaybe<Scalars["bigint"]["input"]>;
  state_change_hash?: InputMaybe<Scalars["String"]["input"]>;
  state_checkpoint_hash?: InputMaybe<Scalars["String"]["input"]>;
  success?: InputMaybe<Scalars["Boolean"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
  version?: InputMaybe<Scalars["bigint"]["input"]>;
  vm_status?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate max on columns */
export type TransactionsViewMaxFields = {
  accumulator_root_hash?: Maybe<Scalars["String"]["output"]>;
  block_height?: Maybe<Scalars["bigint"]["output"]>;
  event_root_hash?: Maybe<Scalars["String"]["output"]>;
  gas_used?: Maybe<Scalars["numeric"]["output"]>;
  hash?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  json_payload?: Maybe<Scalars["String"]["output"]>;
  num_events?: Maybe<Scalars["bigint"]["output"]>;
  num_write_set_changes?: Maybe<Scalars["bigint"]["output"]>;
  state_change_hash?: Maybe<Scalars["String"]["output"]>;
  state_checkpoint_hash?: Maybe<Scalars["String"]["output"]>;
  type?: Maybe<Scalars["String"]["output"]>;
  version?: Maybe<Scalars["bigint"]["output"]>;
  vm_status?: Maybe<Scalars["String"]["output"]>;
};

/** aggregate min on columns */
export type TransactionsViewMinFields = {
  accumulator_root_hash?: Maybe<Scalars["String"]["output"]>;
  block_height?: Maybe<Scalars["bigint"]["output"]>;
  event_root_hash?: Maybe<Scalars["String"]["output"]>;
  gas_used?: Maybe<Scalars["numeric"]["output"]>;
  hash?: Maybe<Scalars["String"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  json_payload?: Maybe<Scalars["String"]["output"]>;
  num_events?: Maybe<Scalars["bigint"]["output"]>;
  num_write_set_changes?: Maybe<Scalars["bigint"]["output"]>;
  state_change_hash?: Maybe<Scalars["String"]["output"]>;
  state_checkpoint_hash?: Maybe<Scalars["String"]["output"]>;
  type?: Maybe<Scalars["String"]["output"]>;
  version?: Maybe<Scalars["bigint"]["output"]>;
  vm_status?: Maybe<Scalars["String"]["output"]>;
};

/** response of any mutation on the table "transactions_view" */
export type TransactionsViewMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<TransactionsView>;
};

/** Ordering options when selecting data from "transactions_view". */
export type TransactionsViewOrderBy = {
  accumulator_root_hash?: InputMaybe<OrderBy>;
  block_height?: InputMaybe<OrderBy>;
  event_root_hash?: InputMaybe<OrderBy>;
  gas_used?: InputMaybe<OrderBy>;
  hash?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  json_payload?: InputMaybe<OrderBy>;
  num_events?: InputMaybe<OrderBy>;
  num_write_set_changes?: InputMaybe<OrderBy>;
  state_change_hash?: InputMaybe<OrderBy>;
  state_checkpoint_hash?: InputMaybe<OrderBy>;
  success?: InputMaybe<OrderBy>;
  type?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
  vm_status?: InputMaybe<OrderBy>;
};

/** select columns of table "transactions_view" */
export enum TransactionsViewSelectColumn {
  /** column name */
  AccumulatorRootHash = "accumulator_root_hash",
  /** column name */
  BlockHeight = "block_height",
  /** column name */
  EventRootHash = "event_root_hash",
  /** column name */
  GasUsed = "gas_used",
  /** column name */
  Hash = "hash",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  JsonPayload = "json_payload",
  /** column name */
  NumEvents = "num_events",
  /** column name */
  NumWriteSetChanges = "num_write_set_changes",
  /** column name */
  StateChangeHash = "state_change_hash",
  /** column name */
  StateCheckpointHash = "state_checkpoint_hash",
  /** column name */
  Success = "success",
  /** column name */
  Type = "type",
  /** column name */
  Version = "version",
  /** column name */
  VmStatus = "vm_status",
}

/** input type for updating data in table "transactions_view" */
export type TransactionsViewSetInput = {
  accumulator_root_hash?: InputMaybe<Scalars["String"]["input"]>;
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  event_root_hash?: InputMaybe<Scalars["String"]["input"]>;
  gas_used?: InputMaybe<Scalars["numeric"]["input"]>;
  hash?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  json_payload?: InputMaybe<Scalars["String"]["input"]>;
  num_events?: InputMaybe<Scalars["bigint"]["input"]>;
  num_write_set_changes?: InputMaybe<Scalars["bigint"]["input"]>;
  state_change_hash?: InputMaybe<Scalars["String"]["input"]>;
  state_checkpoint_hash?: InputMaybe<Scalars["String"]["input"]>;
  success?: InputMaybe<Scalars["Boolean"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
  version?: InputMaybe<Scalars["bigint"]["input"]>;
  vm_status?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate stddev on columns */
export type TransactionsViewStddevFields = {
  block_height?: Maybe<Scalars["Float"]["output"]>;
  gas_used?: Maybe<Scalars["Float"]["output"]>;
  num_events?: Maybe<Scalars["Float"]["output"]>;
  num_write_set_changes?: Maybe<Scalars["Float"]["output"]>;
  version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type TransactionsViewStddevPopFields = {
  block_height?: Maybe<Scalars["Float"]["output"]>;
  gas_used?: Maybe<Scalars["Float"]["output"]>;
  num_events?: Maybe<Scalars["Float"]["output"]>;
  num_write_set_changes?: Maybe<Scalars["Float"]["output"]>;
  version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type TransactionsViewStddevSampFields = {
  block_height?: Maybe<Scalars["Float"]["output"]>;
  gas_used?: Maybe<Scalars["Float"]["output"]>;
  num_events?: Maybe<Scalars["Float"]["output"]>;
  num_write_set_changes?: Maybe<Scalars["Float"]["output"]>;
  version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "transactions_view" */
export type TransactionsViewStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: TransactionsViewStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TransactionsViewStreamCursorValueInput = {
  accumulator_root_hash?: InputMaybe<Scalars["String"]["input"]>;
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  event_root_hash?: InputMaybe<Scalars["String"]["input"]>;
  gas_used?: InputMaybe<Scalars["numeric"]["input"]>;
  hash?: InputMaybe<Scalars["String"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  json_payload?: InputMaybe<Scalars["String"]["input"]>;
  num_events?: InputMaybe<Scalars["bigint"]["input"]>;
  num_write_set_changes?: InputMaybe<Scalars["bigint"]["input"]>;
  state_change_hash?: InputMaybe<Scalars["String"]["input"]>;
  state_checkpoint_hash?: InputMaybe<Scalars["String"]["input"]>;
  success?: InputMaybe<Scalars["Boolean"]["input"]>;
  type?: InputMaybe<Scalars["String"]["input"]>;
  version?: InputMaybe<Scalars["bigint"]["input"]>;
  vm_status?: InputMaybe<Scalars["String"]["input"]>;
};

/** aggregate sum on columns */
export type TransactionsViewSumFields = {
  block_height?: Maybe<Scalars["bigint"]["output"]>;
  gas_used?: Maybe<Scalars["numeric"]["output"]>;
  num_events?: Maybe<Scalars["bigint"]["output"]>;
  num_write_set_changes?: Maybe<Scalars["bigint"]["output"]>;
  version?: Maybe<Scalars["bigint"]["output"]>;
};

export type TransactionsViewUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TransactionsViewIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TransactionsViewSetInput>;
  /** filter the rows which have to be updated */
  where: TransactionsViewBoolExp;
};

/** aggregate var_pop on columns */
export type TransactionsViewVarPopFields = {
  block_height?: Maybe<Scalars["Float"]["output"]>;
  gas_used?: Maybe<Scalars["Float"]["output"]>;
  num_events?: Maybe<Scalars["Float"]["output"]>;
  num_write_set_changes?: Maybe<Scalars["Float"]["output"]>;
  version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type TransactionsViewVarSampFields = {
  block_height?: Maybe<Scalars["Float"]["output"]>;
  gas_used?: Maybe<Scalars["Float"]["output"]>;
  num_events?: Maybe<Scalars["Float"]["output"]>;
  num_write_set_changes?: Maybe<Scalars["Float"]["output"]>;
  version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type TransactionsViewVarianceFields = {
  block_height?: Maybe<Scalars["Float"]["output"]>;
  gas_used?: Maybe<Scalars["Float"]["output"]>;
  num_events?: Maybe<Scalars["Float"]["output"]>;
  num_write_set_changes?: Maybe<Scalars["Float"]["output"]>;
  version?: Maybe<Scalars["Float"]["output"]>;
};

/** columns and relationships of "user_transactions" */
export type UserTransactions = {
  block_height: Scalars["bigint"]["output"];
  entry_function_contract_address?: Maybe<Scalars["String"]["output"]>;
  entry_function_function_name?: Maybe<Scalars["String"]["output"]>;
  entry_function_id_str: Scalars["String"]["output"];
  entry_function_module_name?: Maybe<Scalars["String"]["output"]>;
  epoch: Scalars["bigint"]["output"];
  expiration_timestamp_secs: Scalars["timestamp"]["output"];
  gas_unit_price: Scalars["numeric"]["output"];
  inserted_at: Scalars["timestamp"]["output"];
  max_gas_amount: Scalars["numeric"]["output"];
  parent_signature_type: Scalars["String"]["output"];
  sender: Scalars["String"]["output"];
  sequence_number: Scalars["bigint"]["output"];
  timestamp: Scalars["timestamp"]["output"];
  version: Scalars["bigint"]["output"];
};

/** aggregated selection of "user_transactions" */
export type UserTransactionsAggregate = {
  aggregate?: Maybe<UserTransactionsAggregateFields>;
  nodes: Array<UserTransactions>;
};

/** aggregate fields of "user_transactions" */
export type UserTransactionsAggregateFields = {
  avg?: Maybe<UserTransactionsAvgFields>;
  count: Scalars["Int"]["output"];
  max?: Maybe<UserTransactionsMaxFields>;
  min?: Maybe<UserTransactionsMinFields>;
  stddev?: Maybe<UserTransactionsStddevFields>;
  stddev_pop?: Maybe<UserTransactionsStddevPopFields>;
  stddev_samp?: Maybe<UserTransactionsStddevSampFields>;
  sum?: Maybe<UserTransactionsSumFields>;
  var_pop?: Maybe<UserTransactionsVarPopFields>;
  var_samp?: Maybe<UserTransactionsVarSampFields>;
  variance?: Maybe<UserTransactionsVarianceFields>;
};

/** aggregate fields of "user_transactions" */
export type UserTransactionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserTransactionsSelectColumn>>;
  distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** aggregate avg on columns */
export type UserTransactionsAvgFields = {
  block_height?: Maybe<Scalars["Float"]["output"]>;
  epoch?: Maybe<Scalars["Float"]["output"]>;
  gas_unit_price?: Maybe<Scalars["Float"]["output"]>;
  max_gas_amount?: Maybe<Scalars["Float"]["output"]>;
  sequence_number?: Maybe<Scalars["Float"]["output"]>;
  version?: Maybe<Scalars["Float"]["output"]>;
};

/** Boolean expression to filter rows from the table "user_transactions". All fields are combined with a logical 'AND'. */
export type UserTransactionsBoolExp = {
  _and?: InputMaybe<Array<UserTransactionsBoolExp>>;
  _not?: InputMaybe<UserTransactionsBoolExp>;
  _or?: InputMaybe<Array<UserTransactionsBoolExp>>;
  block_height?: InputMaybe<BigintComparisonExp>;
  entry_function_contract_address?: InputMaybe<StringComparisonExp>;
  entry_function_function_name?: InputMaybe<StringComparisonExp>;
  entry_function_id_str?: InputMaybe<StringComparisonExp>;
  entry_function_module_name?: InputMaybe<StringComparisonExp>;
  epoch?: InputMaybe<BigintComparisonExp>;
  expiration_timestamp_secs?: InputMaybe<TimestampComparisonExp>;
  gas_unit_price?: InputMaybe<NumericComparisonExp>;
  inserted_at?: InputMaybe<TimestampComparisonExp>;
  max_gas_amount?: InputMaybe<NumericComparisonExp>;
  parent_signature_type?: InputMaybe<StringComparisonExp>;
  sender?: InputMaybe<StringComparisonExp>;
  sequence_number?: InputMaybe<BigintComparisonExp>;
  timestamp?: InputMaybe<TimestampComparisonExp>;
  version?: InputMaybe<BigintComparisonExp>;
};

/** unique or primary key constraints on table "user_transactions" */
export enum UserTransactionsConstraint {
  /** unique or primary key constraint on columns "version" */
  UserTransactionsPkey = "user_transactions_pkey",
  /** unique or primary key constraint on columns "sender", "sequence_number" */
  UserTransactionsSenderSequenceNumberKey = "user_transactions_sender_sequence_number_key",
}

/** input type for incrementing numeric columns in table "user_transactions" */
export type UserTransactionsIncInput = {
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  epoch?: InputMaybe<Scalars["bigint"]["input"]>;
  gas_unit_price?: InputMaybe<Scalars["numeric"]["input"]>;
  max_gas_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
  version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** input type for inserting data into table "user_transactions" */
export type UserTransactionsInsertInput = {
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  entry_function_contract_address?: InputMaybe<Scalars["String"]["input"]>;
  entry_function_function_name?: InputMaybe<Scalars["String"]["input"]>;
  entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
  entry_function_module_name?: InputMaybe<Scalars["String"]["input"]>;
  epoch?: InputMaybe<Scalars["bigint"]["input"]>;
  expiration_timestamp_secs?: InputMaybe<Scalars["timestamp"]["input"]>;
  gas_unit_price?: InputMaybe<Scalars["numeric"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  max_gas_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  parent_signature_type?: InputMaybe<Scalars["String"]["input"]>;
  sender?: InputMaybe<Scalars["String"]["input"]>;
  sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
  timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate max on columns */
export type UserTransactionsMaxFields = {
  block_height?: Maybe<Scalars["bigint"]["output"]>;
  entry_function_contract_address?: Maybe<Scalars["String"]["output"]>;
  entry_function_function_name?: Maybe<Scalars["String"]["output"]>;
  entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
  entry_function_module_name?: Maybe<Scalars["String"]["output"]>;
  epoch?: Maybe<Scalars["bigint"]["output"]>;
  expiration_timestamp_secs?: Maybe<Scalars["timestamp"]["output"]>;
  gas_unit_price?: Maybe<Scalars["numeric"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  max_gas_amount?: Maybe<Scalars["numeric"]["output"]>;
  parent_signature_type?: Maybe<Scalars["String"]["output"]>;
  sender?: Maybe<Scalars["String"]["output"]>;
  sequence_number?: Maybe<Scalars["bigint"]["output"]>;
  timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  version?: Maybe<Scalars["bigint"]["output"]>;
};

/** aggregate min on columns */
export type UserTransactionsMinFields = {
  block_height?: Maybe<Scalars["bigint"]["output"]>;
  entry_function_contract_address?: Maybe<Scalars["String"]["output"]>;
  entry_function_function_name?: Maybe<Scalars["String"]["output"]>;
  entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
  entry_function_module_name?: Maybe<Scalars["String"]["output"]>;
  epoch?: Maybe<Scalars["bigint"]["output"]>;
  expiration_timestamp_secs?: Maybe<Scalars["timestamp"]["output"]>;
  gas_unit_price?: Maybe<Scalars["numeric"]["output"]>;
  inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
  max_gas_amount?: Maybe<Scalars["numeric"]["output"]>;
  parent_signature_type?: Maybe<Scalars["String"]["output"]>;
  sender?: Maybe<Scalars["String"]["output"]>;
  sequence_number?: Maybe<Scalars["bigint"]["output"]>;
  timestamp?: Maybe<Scalars["timestamp"]["output"]>;
  version?: Maybe<Scalars["bigint"]["output"]>;
};

/** response of any mutation on the table "user_transactions" */
export type UserTransactionsMutationResponse = {
  /** number of rows affected by the mutation */
  affected_rows: Scalars["Int"]["output"];
  /** data from the rows affected by the mutation */
  returning: Array<UserTransactions>;
};

/** input type for inserting object relation for remote table "user_transactions" */
export type UserTransactionsObjRelInsertInput = {
  data: UserTransactionsInsertInput;
  /** upsert condition */
  on_conflict?: InputMaybe<UserTransactionsOnConflict>;
};

/** on_conflict condition type for table "user_transactions" */
export type UserTransactionsOnConflict = {
  constraint: UserTransactionsConstraint;
  update_columns?: Array<UserTransactionsUpdateColumn>;
  where?: InputMaybe<UserTransactionsBoolExp>;
};

/** Ordering options when selecting data from "user_transactions". */
export type UserTransactionsOrderBy = {
  block_height?: InputMaybe<OrderBy>;
  entry_function_contract_address?: InputMaybe<OrderBy>;
  entry_function_function_name?: InputMaybe<OrderBy>;
  entry_function_id_str?: InputMaybe<OrderBy>;
  entry_function_module_name?: InputMaybe<OrderBy>;
  epoch?: InputMaybe<OrderBy>;
  expiration_timestamp_secs?: InputMaybe<OrderBy>;
  gas_unit_price?: InputMaybe<OrderBy>;
  inserted_at?: InputMaybe<OrderBy>;
  max_gas_amount?: InputMaybe<OrderBy>;
  parent_signature_type?: InputMaybe<OrderBy>;
  sender?: InputMaybe<OrderBy>;
  sequence_number?: InputMaybe<OrderBy>;
  timestamp?: InputMaybe<OrderBy>;
  version?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_transactions */
export type UserTransactionsPkColumnsInput = {
  version: Scalars["bigint"]["input"];
};

/** select columns of table "user_transactions" */
export enum UserTransactionsSelectColumn {
  /** column name */
  BlockHeight = "block_height",
  /** column name */
  EntryFunctionContractAddress = "entry_function_contract_address",
  /** column name */
  EntryFunctionFunctionName = "entry_function_function_name",
  /** column name */
  EntryFunctionIdStr = "entry_function_id_str",
  /** column name */
  EntryFunctionModuleName = "entry_function_module_name",
  /** column name */
  Epoch = "epoch",
  /** column name */
  ExpirationTimestampSecs = "expiration_timestamp_secs",
  /** column name */
  GasUnitPrice = "gas_unit_price",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  MaxGasAmount = "max_gas_amount",
  /** column name */
  ParentSignatureType = "parent_signature_type",
  /** column name */
  Sender = "sender",
  /** column name */
  SequenceNumber = "sequence_number",
  /** column name */
  Timestamp = "timestamp",
  /** column name */
  Version = "version",
}

/** input type for updating data in table "user_transactions" */
export type UserTransactionsSetInput = {
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  entry_function_contract_address?: InputMaybe<Scalars["String"]["input"]>;
  entry_function_function_name?: InputMaybe<Scalars["String"]["input"]>;
  entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
  entry_function_module_name?: InputMaybe<Scalars["String"]["input"]>;
  epoch?: InputMaybe<Scalars["bigint"]["input"]>;
  expiration_timestamp_secs?: InputMaybe<Scalars["timestamp"]["input"]>;
  gas_unit_price?: InputMaybe<Scalars["numeric"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  max_gas_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  parent_signature_type?: InputMaybe<Scalars["String"]["input"]>;
  sender?: InputMaybe<Scalars["String"]["input"]>;
  sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
  timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate stddev on columns */
export type UserTransactionsStddevFields = {
  block_height?: Maybe<Scalars["Float"]["output"]>;
  epoch?: Maybe<Scalars["Float"]["output"]>;
  gas_unit_price?: Maybe<Scalars["Float"]["output"]>;
  max_gas_amount?: Maybe<Scalars["Float"]["output"]>;
  sequence_number?: Maybe<Scalars["Float"]["output"]>;
  version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_pop on columns */
export type UserTransactionsStddevPopFields = {
  block_height?: Maybe<Scalars["Float"]["output"]>;
  epoch?: Maybe<Scalars["Float"]["output"]>;
  gas_unit_price?: Maybe<Scalars["Float"]["output"]>;
  max_gas_amount?: Maybe<Scalars["Float"]["output"]>;
  sequence_number?: Maybe<Scalars["Float"]["output"]>;
  version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate stddev_samp on columns */
export type UserTransactionsStddevSampFields = {
  block_height?: Maybe<Scalars["Float"]["output"]>;
  epoch?: Maybe<Scalars["Float"]["output"]>;
  gas_unit_price?: Maybe<Scalars["Float"]["output"]>;
  max_gas_amount?: Maybe<Scalars["Float"]["output"]>;
  sequence_number?: Maybe<Scalars["Float"]["output"]>;
  version?: Maybe<Scalars["Float"]["output"]>;
};

/** Streaming cursor of the table "user_transactions" */
export type UserTransactionsStreamCursorInput = {
  /** Stream column input with initial value */
  initial_value: UserTransactionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserTransactionsStreamCursorValueInput = {
  block_height?: InputMaybe<Scalars["bigint"]["input"]>;
  entry_function_contract_address?: InputMaybe<Scalars["String"]["input"]>;
  entry_function_function_name?: InputMaybe<Scalars["String"]["input"]>;
  entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
  entry_function_module_name?: InputMaybe<Scalars["String"]["input"]>;
  epoch?: InputMaybe<Scalars["bigint"]["input"]>;
  expiration_timestamp_secs?: InputMaybe<Scalars["timestamp"]["input"]>;
  gas_unit_price?: InputMaybe<Scalars["numeric"]["input"]>;
  inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
  max_gas_amount?: InputMaybe<Scalars["numeric"]["input"]>;
  parent_signature_type?: InputMaybe<Scalars["String"]["input"]>;
  sender?: InputMaybe<Scalars["String"]["input"]>;
  sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
  timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
  version?: InputMaybe<Scalars["bigint"]["input"]>;
};

/** aggregate sum on columns */
export type UserTransactionsSumFields = {
  block_height?: Maybe<Scalars["bigint"]["output"]>;
  epoch?: Maybe<Scalars["bigint"]["output"]>;
  gas_unit_price?: Maybe<Scalars["numeric"]["output"]>;
  max_gas_amount?: Maybe<Scalars["numeric"]["output"]>;
  sequence_number?: Maybe<Scalars["bigint"]["output"]>;
  version?: Maybe<Scalars["bigint"]["output"]>;
};

/** update columns of table "user_transactions" */
export enum UserTransactionsUpdateColumn {
  /** column name */
  BlockHeight = "block_height",
  /** column name */
  EntryFunctionContractAddress = "entry_function_contract_address",
  /** column name */
  EntryFunctionFunctionName = "entry_function_function_name",
  /** column name */
  EntryFunctionIdStr = "entry_function_id_str",
  /** column name */
  EntryFunctionModuleName = "entry_function_module_name",
  /** column name */
  Epoch = "epoch",
  /** column name */
  ExpirationTimestampSecs = "expiration_timestamp_secs",
  /** column name */
  GasUnitPrice = "gas_unit_price",
  /** column name */
  InsertedAt = "inserted_at",
  /** column name */
  MaxGasAmount = "max_gas_amount",
  /** column name */
  ParentSignatureType = "parent_signature_type",
  /** column name */
  Sender = "sender",
  /** column name */
  SequenceNumber = "sequence_number",
  /** column name */
  Timestamp = "timestamp",
  /** column name */
  Version = "version",
}

export type UserTransactionsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<UserTransactionsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserTransactionsSetInput>;
  /** filter the rows which have to be updated */
  where: UserTransactionsBoolExp;
};

/** aggregate var_pop on columns */
export type UserTransactionsVarPopFields = {
  block_height?: Maybe<Scalars["Float"]["output"]>;
  epoch?: Maybe<Scalars["Float"]["output"]>;
  gas_unit_price?: Maybe<Scalars["Float"]["output"]>;
  max_gas_amount?: Maybe<Scalars["Float"]["output"]>;
  sequence_number?: Maybe<Scalars["Float"]["output"]>;
  version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate var_samp on columns */
export type UserTransactionsVarSampFields = {
  block_height?: Maybe<Scalars["Float"]["output"]>;
  epoch?: Maybe<Scalars["Float"]["output"]>;
  gas_unit_price?: Maybe<Scalars["Float"]["output"]>;
  max_gas_amount?: Maybe<Scalars["Float"]["output"]>;
  sequence_number?: Maybe<Scalars["Float"]["output"]>;
  version?: Maybe<Scalars["Float"]["output"]>;
};

/** aggregate variance on columns */
export type UserTransactionsVarianceFields = {
  block_height?: Maybe<Scalars["Float"]["output"]>;
  epoch?: Maybe<Scalars["Float"]["output"]>;
  gas_unit_price?: Maybe<Scalars["Float"]["output"]>;
  max_gas_amount?: Maybe<Scalars["Float"]["output"]>;
  sequence_number?: Maybe<Scalars["Float"]["output"]>;
  version?: Maybe<Scalars["Float"]["output"]>;
};
